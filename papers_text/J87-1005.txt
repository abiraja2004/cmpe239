AN ALGORITHM FOR GENERATING QUANTIF IER  SCOPINGS 
Jerry R. Hobbs  and Stuart  M.  Sh ieber  
Artificial Intelligence Center 
SRI International 
Menlo Park, CA 94025 
and 
Center for the Study of Language and Information 
Stanford University 
Stanford, CA 94305 
The syntactic structure of a sentence often manifests quite clearly the predicate-argument s ructure and 
relations of grammatical subordination. But scope dependencies are not so transparent. As a result, many 
systems for representing the semantics of sentences have ignored scoping or generated scopings with 
mechanisms that have often been inexplicit as to the range of scopings they choose among or profligate in 
the scopings they allow. 
This paper presents, along with proofs of some of its important properties, an algorithm that generates 
scoped semantic forms from unscoped expressions encoding predicate-argument s ructure. The algorithm 
is not profligate as are those based on permutation of quantifiers, and it can provide a solid foundation for 
computational solutions where completeness i sacrificed for efficiency and heuristic efficacy. 
1 INTRODUCTION 
A principal focus of computational linguistics, as a 
branch of computer science, ought to be the design of 
algorithms. A large number of algorithms have undoubt- 
edly been devised for dealing with problems every 
researcher has to face in constructing a natural anguage 
system, but they simply have not received wide circu- 
lation. These algorithms are part of the "folk culture", 
buried in the most technical, unreadable portions of thes- 
es, passed among colleagues informally at best, and often 
reinvented. It should be a practice to publish these algo- 
rithms in isolation, independent of a particular implemen- 
tation or system. 
This paper constitutes an effort to initiate such a prac- 
tice. A problem that many natural-language efforts have 
faced is the recovery of implicit semantic scope depend- 
ency possibilities - such as those manifest in quantifiers 
and modals - from predicate-argument relations and 
relations of grammatical subordination, which are more 
or less transparently conveyed by the syntactic structure 
of sentences. Previous computational efforts typically 
have not been based on an explicit notion of the range of 
possible scopings. In response to this problem, we 
present an algorithm that generates quantifier scopings 
for English sentences. 
I.I THE PROBLEM OF GENERATING QUANTIFIER SCOPINGS 
The naive algorithm for generating quantifier scopings is 
to generate all permutations of the quantifiers. For a 
sentence with n quantified noun phrases this will gener- 
ate n! different readings. But for the sentence 
(1) Every representative of a company saw most 
samples. 
there are not six different readings, but only five. The 
reading that is missing is the one in which most samples is 
outscoped by every representative but outscopes a compa- 
ny. A model for the disallowed reading could include a 
different company not only for each representative but 
also for each sample. 
The reduction in number of readings for a given 
sentence is not significant for sentence (1), but in the 
sentence 
(2) Some representative of every department in most 
companies saw a few samples of each product. 
there are only 42 valid readings, as opposed to the 120 
readings the naive algorithm would generate, and this 
Copyright1987 by the Association for Computational Linguistics. Permission tocopy without fee all or part of this material isgranted provided that 
the copies are not made for direct commercial dvantage and the CL reference and this copyright notice are included on the first page. To.copy 
otherwisc, or to republish, requires a fee and/or specific permission. 
0362-613X/87/010047-63503.00 
Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 47 
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings 
constitutes a significant difference indeed. The recent 
trend in computational linguistics has been to view more 
and more noun phrases, as well as other constituents, as 
introducing quantifiers, so that sentences with this much 
quantificational complexity are not at all unusual. (The 
immediately preceding sentence, for example, has six or 
seven quantifiers.) 
This observation of "illegitimate readings" is not 
intended as a new or controversial claim about an idio- 
syncrasy of English. It accords well with semantic judg- 
ments about the possibility of such readings. For 
instance, we find it impossible to view sentence (1) as 
expressing that for each representative there was a group 
of most samples which he saw, and furthermore, for each 
sample he saw, there was a company he was a represen- 
tative of. 
We can find the same problem of illegitimate readings 
in the standard account of the "Cooper storage" mech- 
anism for generating quantifier scopings (Cooper 1983). 
Cooper's method generates an expression in intensional 
logic for the illegitimate readings, but the expression 
contains an unbound variable and a vacuous quantifier. 1
Finally, the observation follows merely syntactically 
from the ill-formedness of certain logical form 
expressions. Let us examine why this is so. The proposi- 
tional content of a sentence can be seen as combining 
specifications that restrict he range of quantified entities, 
together with assertions about the entities so specified. 
This intuition is often made formal in the use of logical 
languages that syntactically separate the notion of the 
range of a quantified expression from its scope by placing 
the information about the range in a part of the 
expression we call the restriction and the assertions in a 
part called the body. (Henceforth, we will uniformly use 
the terms restriction and body.) The separation of these 
two semantic roles of range and scope into restriction 
and body as an important fact of the logical structure of 
English can be seen, for example, in Woods's four-part 
quantifier structures (Woods 1977), in the recommen- 
dations of Moore (1981), and in the generalized quantifi- 
er research of Barwise and Cooper and others. The 
latter have demonstrated the necessity of such a sepa- 
ration for quantifiers other than the standard first-order 
ones (Barwise and Cooper, 1981 ; Cushing, 1976). 
But under this understanding of English logical struc- 
ture, it follows that no sixth reading exists for sentence 
(1) above. Consider the reading in which the universal 
outscopes the most which outscopes the existential in the 
logical form for this sentence. Then, using the notation 
of Moore (1981) for four-part quantifier structures, the 
logical form must have the following structure: 
all(r, representative(r) ....... ) 
since the universal is outermost. Now the existential is 
within the scope of the universal by hypothesis, and since 
it provides a restriction on the range of the variable r, it 
must occur in the restriction of the quantifier. Thus, we 
have: 
all(r, representative(r) & some(c, company(c), 
of(c,r)) .... saw(r,s)...) 
But where can the quantifier most be put to bind the vari- 
able s corresponding to the samples seen? It must 
outscope its occurrence in the body of the universal, but 
it must also by hypothesis outscope the existential in the 
restriction of the universal. To outscope both, it must 
outscope the universal itself, but this violates the 
assumed scope relations. Thus, no such reading is possi- 
ble. By a similar argument, it follows from the logical 
structure of English that in general a quantifier from else- 
where in a sentence cannot come after the quantifier 
associated with a head noun and before the quantifier 
associated with a noun phrase in the head noun's comple- 
ment. 
Most research in linguistic semantics, e.g., Montague 
(1973) and Cooper (1983), has concentrated on explicit- 
ly defining the range of possible scope relationships that 
can be manifested in sentences. But, to our knowledge, 
all fall prey to the profligacy of generation just outlined. 
1.2 OTHER ISSUES IN QUANTIFIER SCOPING 
1.2.1 OTHER SPURIOUS SCOPINGS 
We are concerned here only with suppressing readings 
that are spurious for purely structural reasons, that is, for 
reasons that follow from the general relationship between 
the structure of sentences and the structure of their 
logical forms and independent of the meanings of the 
particular sentences. For instance, we are not concerned 
with logical redundancies, such as those due to the 
commutativity of successive universal quantifiers. When 
we move beyond the two first-order logical quantifiers to 
deal with the so-called generalized quantifiers such as 
most, these logical redundancies become quite rare. Simi- 
larly, we are not concerned with the infelicity of certain 
readings due to lexical semantic or world knowledge, 
such as the fact that a child cannot outscope very man in 
the sentence 
I've met a child of every man in this room. 
1.2.2 HEURISTICALLY PRIMARY SCOPINGS 
Computational research on quantifier scoping has 
emphasized generating a single scoping, which can be 
thought of as heuristically primary, as discussed by, for 
example, Woods (1977), Pereira (1983), and Grosz et al 
(1985). We are concerned not with generating the best 
reading but with generating all readings. The reader may 
object that it is inappropriate in a practical natural 
language system to generate scopings one by one for 
testing against semantic and pragmatic riteria. Instead, 
one should appeal to various heuristics to generate only 
the most likely reading, or at least to generate readings in 
order of their plausibility. These include the following: 
? lexical heuristics, e.g., each usually outscopes some; 
? syntactic heuristics, e.g., a noun phrase in a relative 
clause is usually outscoped by the head noun, and a 
noun phrase in a prepositional phrase complement of a 
48 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings 
relational head noun usually outscopes the head noun; 
and 
? ordering heuristics, such as the principle that left-to- 
right order at the same syntactic level is generally 
preserved in the quantifier order. 2 
We are sympathetic with this view. Nevertheless, there 
are several reasons that codifying a complete algorithm 
remains useful. First, a complete and sound algorithm 
provides a benchmark against which other approaches 
can be tested. Second, one may actually wish to use a 
generate-and-test mechanism in simpler implementations, 
and it should be correct and as efficient as possible. It 
should not generate scopings that can be ruled out on 
purely structural grounds. Finally, the algorithm we 
present might be modified to incorporate heuristics to 
generate scopings in a certain order or only certain of the 
scopings. The soundness and correctness of the underly- 
ing algorithm, provide a guarantee of soundness for a 
heuristically guided version. We include a few comments 
below about incorporating ordering heuristics into our 
scoping generation algorithm, although we should point 
out that the possibilities are somewhat limited due to the 
local nature of where the heuristics can be applied. A 
full discussion of heuristically-guided scoping generation 
is, of course, beyond the scope of this paper. 
1.2.3 SCOPE OF OPAQUE PREDICATES 
In addition to handling the scoping of quantifiers relative 
to each other, the algorithm we present also allows quan- 
tifiers to be scoped within or outside of opaque argu- 
ments of higher-order predicates. For instance, the 
algorithm generates two readings for the sentence 
Everyone isn't here. 
corresponding to the two relative scopings of the 
universal quantifier and the negation. 
2 THE ALGORITHM 
In the discussion below, we assume that parsing has 
made explicit the predicate-argument relations and the 
relations of grammatical subordination i  the form of a 
logical encoding in an input language. A well-formed 
formula (wff) in the input language is a predicate or other 
operator applied to one or more arguments. An argu- 
ment can be a constant or variable, another wff, or what 
we will call a complex term. A complex term is an 
ordered triple consisting of a quantifier, a variable, and a 
wff (called the restriction), which represents the predi- 
cation that is grammatically subordinated to the variable. 
The input representation for sentence (2) is, then, the 
following (ignoring tense): 
see(<some r 
and(rep(r),  
of(r,<every d 
and(dept(d), 
in(d,<most c co(e)>) )>) )>,  
<a-few s and(samp(s), 
of(s,<each p prod(p)>))>) 
A complex term can be read "quantifier variable such 
that restriction", e.g., "most c such that c is a company". 
The output language is identical to the input language, 
except hat it does not contain complex terms. Quantifi- 
ers are expressed in the output language as operators that 
take three arguments: the variable bound by the quantifi- 
er, a wff restricting the range of the quantified variable, 
and the body scoped by the quantification, schematically 
quantifier(variable, r striction, body) 
This encoding of quantification is the same as that found 
in Woods (1977) and Moore (1981). We will refer to 
such expressions as quantified wffs. Thus, one reading 
for sentence (2) is represented by the following quanti- 
fied wff: 
some(r, and(rep(r), 
every(d, and(dept(d), 
most(c, co(c), 
in(d, c))), 
of(r, d))), 
a-few(s, and(samp(s), 
each(p, prod(p), 
of(s, p))), 
see(r, s))) 
Intermediate structures built during the course of scoping 
include both complex terms and quantified wffs. We use 
the term full seoping for an expression in the output 
language, i.e., one that has no complex terms. 
We also will use the terms bound and free as follows: 
An expression binds a variable v if the expression is of the 
form < q v r > or q(v, r ,s)  where q is a quantifier. The 
variable v is said to be bound in the expressions r, or r 
and s, respectively. A variable v is unbound or free in an 
expression a if there is an occurrence of v in a that is not 
also an occurrence in a subexpression of a binding v. 
Note that here quantified wffs and complex terms are 
both thought of as expressions binding a variable. 
2.1 SUMMARY OF THE ALGORITHM 
We present both nondeterministic and deterministic 
versions of the algorithm 3 in an ALGOL-like language. 
Both algorithms, however, have the same underlying 
structure, based on the primitive operation of "applying" 
a complex term to a wff in which it occurs: a complex 
term in a wff is replaced by the variable it restricts, and 
that variable is then bound by wrapping the entire form 
in the appropriate quantifier. Thus, applying the term 
< q x r(x) > to a wff containing that complex term, say, 
p( < q x r(x) > ), yields the quantified wff 
Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 49 
Jerry R. Hobbs and Sluart M. Shieber An Algorithm for Generating Quantifier Scopings 
q(x, r(x),p(x)). This is the primitive operation by which 
complex terms are removed from a wff and quantified 
wffs are introduced. It is implemented by the function 
apply. 
The generation of a scoping from a wff proceeds in 
two stages. First, the opaque argument positions within 
the wff are scoped. The function pull-opaque-args 
performs this task by replacing wffs in opaque argument 
positions by a (full or partial) scoping of the original wff. 
For instance, if p were a predicate opaque in its only 
argument, then, for the wff p(s (<qxr (x )  > )), pull- 
opaque-args would generate the wff p(q(x, r(x), s(x))) or 
the unchanged wff p(s( < qx r(x) > )). In the former, 
the opaque predicate p outscopes the quantifier q. In the 
latter, the quantifier q has not been applied yet and the 
wff will subsequently yield readings in which q has wider 
scope than p. 
Second, some or all of the remaining terms are applied 
to the entire wff. The function apply-terms iteratively 
(through a tail recursion) chooses a complex term in the 
wff and applies it. Thus apply-terms acting upon the wff 
P( < ql x q(x) > , < qzY r2(Y) > ) will yield one of the 
five wffs 
P( < qlxr l(x) >,  < q2Yr2(Y) >)  
qlCX, rl(x), p(x, < q2Yr2(Y) > )) 
q2(Y, r2(Y), P( < ql x rl(x) > , y)) 
q2(y, r2(Y), ql(x, rl(x), p(x, y))) 
ql(x, rl(x), q2(v, r2(Y), p(x, y))) 
depending on how many quantifiers are applied and in 
what order. The choice of a complex term is restricted to 
a subset of the terms in the wff, the so-called applicable 
terms. The principal restriction on applicable terms is 
that they not be embedded in any other complex term in 
the wff. Section 4.1 discusses a further restriction. The 
function applicable-term returns an applicable term in a 
given wff. 
These two stages are manifested in the function pull 
which generates all partial or full scopings of a wff by 
invoking pull-opaque-args and apply-terms. Since ulti- 
mately only full scopings are desired, an additional argu- 
ment to pull and apply-terms controls whether partial 
scopings are to be returned. When this flag, completeL is 
true, apply-terms, and hence pull will return only 
expressions in which no more complex terms remain to 
be applied, for example, only the last two of the five 
readings above. 
Finally, the restrictions of the complex terms may 
themselves contain complex terms and must be scoped 
themselves. The apply function therefore recursively 
generates the scopings for the restriction by calling pull 
on that restriction, and a quantified wff is generated for 
each possible partial or complete scoping of the 
restriction. Schematically, in the simplest case, for the 
expression p( < ql x rl(x, < q2y r2fy) > ) and its complex 
term < ql -.. > ,4 apply generates the complete scoping 
ql(x, q2(Y, r2(Y), rl(x,y)), p(x)) 
(having called apply recursively on < q2 ... > ), and the 
partial scoping 
ql(x, rl(x , < q2Yr20,) > ), p(x)) 
A subsequent application of the remaining complex term 
will yield .the "wide scope" reading 
q2(.v, r2(Y), ql (x, rl (xy), P(X) ) 
The disallowed readings produced by the "all per- 
mutations" algorithm are never produced by this algo- 
rithm, because it is everywhere sensitive to the four-part 
quantifier structure of the target logical form. 
The difference between the nondeterministic and 
deterministic versions lies only in their implementation of
the choice of terms and returning of values. This is done 
either nondeterministically, or by iterating through and 
returning explicit sets of possibilities. A nondeterministic 
Prolog version and a deterministic COMMON LISP 
version of the algorithm are given in Appendices A and 
B. The full text of these versions (including auxiliary 
functions not listed here) is available from the authors. 
A variant of the COMMON LISP version is currently 
being used at SRI International to generate scopings in 
the KLAUS system. 
2.2 LANGUAGE CONSTRUCTS 
In the specifications below, the let construct implements 
local variable assignment. All assignments are done 
sequentially, not in parallel. The syntax is 
let (assignments) 
in (body) 
The entire expression returns what the body returns. 
Destructuring by pattern matching is allowed in the 
assignments; for example, 
let <quant var restrict> := term 
in (body) 
simultaneously binds quant, var, and restrict to the three 
corresponding components in term. The symbol " :="  is 
used for assignment, lambda is an anonymous-function- 
forming operator. Its syntax is 
lambda((variable)). 
(body) 
where (variable) is free in (body). We assume lexical 
scoping in lambda expressions. The statement "return 
value" returns a value from a function. The binary func- 
tion map (similar to LISP's mapcar) applies its second 
argument (a lambda expression) to each of the elements 
of its first argument (a list). It returns a corresponding 
list of the values of the individual applications. The func- 
tion integers(lower, upper) returns a list of the integers in 
50 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings 
the range lower to upper, inclusive and in order 
(corresponding to APL's iota). The function length(list) 
is obvious. The expression list!n! returns the nth element 
of the list list. The function subst(x,y, expr) substitutes x 
for all occurrences of y in expr. 
The unary function predicate(wff) returns the main 
predicate in a wff. The unary function arguments(wff) 
returns a list of the arguments in a wff. Applied to two 
arguments, wff is a binary function that takes a predicate 
name and a list of arguments, and returns the wff consist- 
ing of the application of the predicate to the arguments. 
Applied to four arguments, wff is a quaternary function 
that takes a quantifier name, a variable name, a 
restriction, and a body, and returns the quantified wff 
consisting of the binding of the variable by the quantifier 
in the restriction and body. The binary predicate 
opaque(predicate, n) returns true if and only if the predi- 
cate is opaque in its nth argument. It is naturally 
assumed that opaque argument positions are filled by wff 
expressions, not terms. Each of the unary predicates 
wff?, term?, and quantifier? returns true if and only if its 
argument is a wff, a complex term, or a quantifier opera- 
tor, respectively. 
2.3 THE NONDETERMINISTIC ALGORITHM 
In the nondeterministic version of the algorithm, there 
are three special language constructs. The unary predi- 
cate exists(expression) evaluates its argument nondeter- 
ministically to a value and returns true if and only if there 
exist one or more values for the expression. The binary 
operator "a 1\[ b" nondeterministically returns one of its 
arguments (a or b). The function term(form) nondeter- 
ministically returns a complex term in form. Finally, the 
function applicable-term(form) nondeterministically 
returns a complex term in form that can be applied to 
form. 
The nondeterministic version of the algorithm is as 
follows. The function gen(form) nondeterministically 
returns a valid full scoping of the formula form. 
function gen (form); 
return pull(form, true). 
The function pull(form, complete?) nondeterministically 
returns a valid'scoping of the formula form. If complete? 
is true, then only full scopings are returned; otherwise, 
partial scopings arc allowed as well. 
function pull(form, complete?); 
return apply-terms(pull-opaque-args(f orm ), 
complete?). 
The function pull-opaque-args(form), when applied to a 
wff, returns a wff generated from form but with argu- 
ments in opaque argument positions replaced by a valid 
scoping of the original value. Since the recursive call to 
pull has complete? set to false, the unchanged argument is 
a nondeterministic possibility, even for opaque argument 
positions. When applied to any other type of expression 
(i.e., a term of some sort), form is unchanged. 
function pull-opaque-args(f orm ); 
if not (wff?(form) ) 
then return form 
else 
let predicate := predicate(form); 
args := arguments(form) 
in return 
wff(predicate, 
map(integers(1,length(args)), 
lambda(arg-index). 
if opaque(predicate, arg-index) 
then pull(args\[arg-index\],false) 
else pull-opaque-args(args\[arg-index\]) ) ). 
The function apply-terms(form, complete?) chooses 
several terms in form nondeterministically and applies 
them to form. If complete? is true, then only full scopings 
are returned. 
function apply-terms(form, complete?); 
if not(exists(term(form))) 
then return form 
else 
let scoped-form := 
apply-terms(apply(applicable-term (fo ), 
form), 
complete?) 
in 
if complete? 
then return scoped-form 
else return scoped-form \[\[ form. 
Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 51 
Jerry R. Hobbs and Sluar! M. Shieber An Algorilhm for Generating Quantifier Scopings 
The function apply(term, form) returns a wff consisting 
of the given complex term term applied to a form form in 
which it occurs. In addition, the restriction of the 
complex term is recursively scoped. 
function apply(term,form); 
let <quant var restrict> := term 
return 
wff(quant, 
var, 
pull(restrict,false), 
subst ( var, term,form)). 
2.4 THE DETERMINISTIC ALGORITHM 
For the deterministic version of the algorithm, there are 
five special language constructs. The unary predicate 
empty(set) returns true if and only if set is empty. Paired 
braces "{ ... }" constitute a set-forming operator. The 
binary function union applies its second argument (a 
lambda expression) to each of the elements of its first 
argument (a set). It returns a corresponding set of the 
values of the individual applications. The binary infix 
operator U returns the union of its two arguments (both 
sets). The function cross-product takes a list of sets as its 
argument and returns the set of lists corresponding to 
each way of taking an element from each of the sets in 
order. For example, 
cross-product( \[{a,b},{c,d,e}\] ) = 
{ \[a,c\], \[a,d\], \[a,e\], \[b,c\], \[b,d\], \[b,e\] }. 
The function terms(form) returns the set of all complex 
terms in form. The function applicable-terms(form) 
returns the set of all complex terms in form that can be 
applied to form. 
The deterministic version of the algorithm is identical 
in structure to the nondeterministic version. Each func- 
tion operates in the same way as its nondeterministic 
counterpart, except hat they uniformly return sets rather 
than nondeterministically returning single values. 
The algorithm is as follows. The function gen(form) 
returns a set of all valid full scopings of the formula form. 
function gen (form); 
return pull(form, true). 
The function pull returns a set of all valid scopings of the 
formula form. If complete? is true, only full scopings are 
returned; otherwise, partial scopings are allowed as well. 
function pull(form, complete?); 
return union(pull-opaque-args(form), 
iambda(pulled-opaque ). 
apply-terms( pulled-opaque, 
complete?)). 
The function pull-opaque-args(form) returns a set of all 
wffs generated from form, but with arguments in opaque 
argument positions replaced by a valid scoping of the 
original value. Since the recursive call to pull has 
complete? set to false, the unchanged argument is a possi- 
bility even for opaque argument positions. When applied 
to any other type of expression (i.e., a term of some 
sort), the argument is unchanged. 
function pu ll-opaque-args (form) 
if not(wff?(form) ) 
then return {form} 
else 
let predicate := predicate(form); 
args := arguments(form) 
return 
union( cross-product( 
map( integers( 1, length ( args) , 
lambda ( arg-index ).
if opaque(predicate, arg-index) 
then pull(args\[arg-index\], false) 
else pull-opaque-args(args\[arg-index\]) ) ), 
lambda( args-possibility). 
{wff(predicate, args-possibility) } . 
The function apply-terms(form, complete?) returns a set of 
scopings of form constituting all of the ways of choosing 
several terms in form and applying them to form. If 
complete? is true, then only the full scopings are returned. 
52 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings 
(3) 
function apply-terms(form, complete?); 
if empty( terms(Jbrm ) )
then return \[form} 
else 
let scoped-forms := 
union(applicable-terms(form), 
lambda( term ). 
union(apply(term, form), 
lambda( applied-f orm ). 
apply-terms(applied-form, complete?))). 
in 
if complete? 
then return scoped-forms 
else return {form} U scoped-forms. 
The function apply(term, form) returns a set of all wffs 
consisting of the given complex term term applied to the 
form .form in which it occurs, with the restriction of the 
complex term recursively scoped in all possible ways. 
function apply(term,form); 
let (quant var restrict) := term 
in return 
(4) union(pull(restrict,false), 
lambda (pulled-restrict ). 
{wff(quant, 
var, 
pulled-restrict, 
subst ( var, term,form)) }). 
3 Two EXAMPLES 
Since the algorithm is not completely transparent, it may 
be useful to work through the deterministic version for a 
detailed example. 
(5) Some representative of every department in most 
companies aw a few samples. 
The predicate-argument structure of this sentence may 
be represented as follows: 
(6) 
see(<some r 
and(rep(r) ,  
of(r,<every d 
and(dept(d), 
in(d,<most c co(c )>) )>) )>,  
<a-few s samp(s)>) 
Suppose gen is called with expression (6) as form. Since 
this is the representation f the whole sentence, pull will 
be called with complete? equal to true. The call to pull- 
opaque-args will return the original wff unchanged since 
there are no opaque operators in the wff. We therefore 
call apply-terms on the wff. 
In apply-terms, the call to applicable-terms returns a list 
of all of the unnested complex terms. For (6), there will 
be two: 
(7) <some r
and(rep(r) ,  
of(r,<every d 
and(dept(d), 
in(d,<most c co(c )>) )>) )> 
(8) <a-few s samp(s)> 
Each of these complex terms will ultimately yield the 
wffs in which its variable is the more deeply nested of the 
two. 
The function apply is called for each of these complex 
terms, and inside apply there is a recursive call to pull on 
the restriction of the complex term. This generates all 
the possible scopings for the restriction. When apply is 
called with (6) as form and (7) as term, the result of 
seoping the restriction of (7) will be the following four 
wffs: 
(9) and(rep(r) ,  
of(r,<every d 
and(dept(d), 
in(d,<most c co(c )>) )>) )  
(10) every(d, and(dept(d), in(d, <most c co(c)>)),  
and(rep(r), of(r, d))) 
(11) most(e, co(c), every(d, and(dept(d), in(d,c)), 
and(rep(r), of(r,d)))) 
(12) every(d, most(e, co(c), and(dept(d), in(d,c))), 
and(rep(r), of(r, d))) 
Because this call to pull has complete? equal to false, the 
unprocessed restriction itself, wff (9), as well as the 
partially scoped wff (10), is returned along with the fully 
scoped forms of the restriction. Wff (9) will ultimately 
generate the two readings in which variables d and c 
outscope r. Wff (10) is also partial as it still contains a 
complex term. It will ultimately ield a reading in which 
r outscopes d but is outscoped by c; the complex term for 
c is still" available for an application that will give it wide 
Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 53 
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings 
scope. Wffs (11) and (12) will ultimately ield readings 
in which d and c are outscoped by r. 
Each of these wffs becomes the restriction in a quanti- 
fied wff constructed by apply. Thus, from restriction 
(10), apply will construct the quantified wff 
(13) some(r, every(d, and(dept(d), 
in(d, <most e co(c)>)), 
and(rep(r), of(r, d))), 
see(r, <a-few s samp(s)>)) 
In apply-terms, the tail recursion turns the remaining 
complex terms into quantifiers with wide scope. Thus, in 
(13) c and s will be given wider scope than r and d. For 
example, one of the readings generated from wff (13) 
will be 
most(c, co(c), 
a-few(s, samp(s), 
some(r, every(d, and(dept(d), in(d, c)), 
and(rep(r), of(r, d))), 
see(r, s)))) 
Sentence (5), by the way, has 14 different readings. 
As an example of the operation of the algorithm on a 
wff with opaque operators, we consider the sentence 
Everyone isn't here. 
This has the predicate-argument structure 
not(here(<every x person(x)>)) 
where not is an operator opaque in its only argument. 
The call to pull-opaque-args returns the two scopings 
not(here(<every x person(x)>)) 
not(every(x,person(x),here(x))) 
The call to apply-terms then turns the first of these into 
every(x,person(x),not(here(x))) 
Thus, the following two full scopings are generated: 
every(x,person(x),not(here(x))) 
not(every(x,person(x),here(x))) 
Note that because of the recursive call in pull-opaque-args 
these two readings will be generated even if this form is 
embedded within other transparent predicates. 
4 MODIFICATIONS AND EXTENSIONS 
4.1 RESTRICTING APPLICABLE TERMS 
The notion of applicable term used above was quite 
simple. A complex term was applicable to a wff if it was 
embedded in no other complex term within the wff. The 
restriction is motivated by the following consideration. 
Suppose the input wff is 
p( <q lxq(x ,  <qyyry(y )> )> ) 
If the embedded term were first applied, yielding 
q2 (Y, r2 (Y), P( < ql X r I (x~y) > )) 
the remaining complex term would include a free occur- 
fence of y so that when it is later applied, resulting in the 
formula 
ql (x, r I (xo,), qz (,Y, rz (Y), p(x))) 
the variable y occurs free in the restriction of q/? 
Thus, it is critical that a term never be applied to a 
form when a variable that is free in the term is bound 
outside of it in the form. The simple definition of appli- 
cability goes part of the way towards enforcing this 
requirement. 
Unfortunately, this simple definition of applicability is 
inadequate. If x had itself been free in the embedded 
complex term, as in the wff 
P( < ql x r I (x, < qz y rz (x, y) > ) >)  
the application of the outer term followed by the inner 
term would still leave an unbound variable, namely x. 
This is because the inner term, which uses x, has been 
applied outside the scope of the binder for x. Such struc- 
tures can occur, for instance, in sentences like the follow- 
ing, where an embedded noun phrase requires reference 
to its embedding noun phrase. 5
Every man that I know a child of has arrived. 
Every man with a picture of himself has arrived. 
In these two sentences the quantifier a cannot outscope 
every because the noun phrase beginning with a embeds a 
reference to every man. If a were to outscope very, then 
himself or the trace following child of would be outside 
the scope of every man. 
The definition of applicable term must be modified as 
follows. A term in a wff is applicable to the wff if and 
only if all variable occurrences that are free in the term 
are free in the wff as well. Our previous definition of 
applicability, that the term be unembedded in another 
term in the wff, is a simple consequence of this 
restriction. The versions of the algorithm given in 
Appendices A and B define the functions applicable-term 
and applicable-terms in this way. Given this definition, 
the algorithm can be shown never to generate unbound 
variables. (See Appendix C.) 
4.2 ADDING ORDERING tlEURISTICS 
A full discussion of heuristic rules for guiding generation 
of quantifier scopings is outside of the aims of this paper. 
However, certain ordering heuristics can be incorporated 
relatively easily into the algorithm merely by controlling 
the way in which nondeterministic choices are made. We 
discuss a few examples here, merely to give the flavor for 
how such heuristics might be added. 
For instance, suppose we want to favor the original 
left-to-right order in the sentence. The function applica- 
ble-terms hould return the complex terms in right-to-left 
order, since quantifiers are extracted from the inside out. 
The union in line (3) should return form after scoped- 
forms. 
if we want to give a noun phrase wide scope when it 
occurs as a prepositional phrase noun complement to a 
function word, e.g., every side of a triangle, then form 
should come before scoped-form in line (3) when pull has 
been called from line (4) in apply where the first argu- 
54 Computational Linguistics, Volume 13, Numbers i -2 ,  January-June 1987 
Jerry'R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings 
ment to apply is a complex term for a noun phrase satis- 
fying those conditions, e.g., the complex term for every 
side o f  a triangle. 
The modifications turn out to be quite complicated if
we wish to order quantifiers according to lexical heuris- 
tics, such as having each outscope some. Because of the 
recursive nature of the algorithm, there are limits to the 
amount of ordering that can be done in this manner. At 
the most, we can sometimes guarantee that the best scop- 
ing comes first. Of course, one can always associate a
score with each reading as it is being generated and sort 
the list afterwards. 
4.3 NONSTANDARD INPUT STRUCTURES 
The algorithm as presented will operate correctly only for 
input structures that are themselves well-formed. For 
instance, they must contain no unbound variables. 
Certain natural language phenomena, such as the 
so-called donkey sentences, exhibit structures that are 
ill-formed with respect o the assumptions made by this 
algorithm. For instance, the sentence 
Every man who owns a donkey beats it. 
has an ill-formed input structure because the pronoun has 
to reach inside the scope of an existential quantifier for 
its antecedent. Its predicate-argument structure might be 
something like 
beat(<every m and(man(m), 
own(m, <some d donkey(d)>))>,  
d) 
An alternative is to leave the pronoun unanalyzed, in 
which case the closest reading produced by the algorithm 
is 
every(m, and(man(m), 
some(d, and(donkey(d), own(m, d)))), 
the(x, it(x), beat(m, x))) 
In fact, this is not bad if we take it(x) to mean that x is 
nonhuman and that x is mentioned in the prior discourse 
in a position determined by whatever coreference resol- 
ution process is used. There is a problem if we take the 
quantifier the to mean that there is a unique such x and 
take the sentence to mean that a man who owns many 
donkeys will beat every donkey he owns. But we can get 
around this if, following the approach taken by Hobbs 
(1983), we take a donkey to be generic, take it to refer to 
the unique generic donkey that m owns, and assume that 
to beat a generic donkey is to beat all its instances. 
In any case, modifications to the algorithm would be 
needed to handle such anaphora phenomena in all their 
complexity. 
5 CONCLUSION 
We have presented an algorithm for generating exactly 
those quantifier scopings that are consistent with the 
logical structure of English. While this algorithm can 
sometimes result in a significant savings over the naive 
approach, it by no means solves the entire quantifier 
scoping problem, as we have already pointed out. There 
has already been much research on the problem of 
choosing the preferred reading among these allowable 
ones, but the methods that have been suggested need to 
be specified in an implementation-free fashion more 
precisely than they have been previously, and they need 
to be evaluated rigorously on large bodies of naturalistic 
data. More important, methods need to be developed for 
using pragmatic onsiderations and world knowledge -
particularly reasoning about quantities and dependencies 
among entities - to resolve quantifier scope ambiguities, 
and these methods need to be integrated smoothly with 
the other kinds of syntactic, semantic, and pragmatic 
processing required in the interpretation of natural 
language texts. 
ACKNOWLEDGMENTS 
We have profited from discussions about this work with 
Paul Martin and Fernando Pereira, and from the 
comments of the anonymous reviewers of the paper. 
This research was supported by NIH Grant LM03611 
from the National Library of Medicine, by Grant 
IST-8209346 from the National Science Foundation, and 
by a gift from the System Development Foundation. 
REFERENCES 
Barwisc, Jon and Coopcr, Robin 1981 Generalized Quantificrs and 
Natural Language. Linguistics attd Philosophy 4(2): 159-219. 
Cooper, Robin 1983 Quant~\[Tcation a d Syntactic Theory. Rcidcl, 
Dordrecht. 
Cushing, Stevcn 1976 Thc Formal Semantics of Quantification. Ph.D. 
dissertation. Univcrsity of California, Los Angclcs. 
Grosz, Barbara J.; Appclt, Douglas E.; Martin, Paul; Pcreira, Fcrnando 
C.N.; and Shinkle, Lorna 1985 The TEAM Natural-Language 
Interface System. Final Report, Project 4865. Artificial Intclligcnce 
Center, SRI International, Menlo Park, California. 
Hobbs, Jcrry R. 1983 An Improper Treatment of Quantification i
Ordinary English. In Proceedings 9\[" the 21st Annual Meeting ?~/" the 
Association for Computational Linguistics. Cambridge, Massachusetts: 
57-63. 
Keller, William 1986 Nested Cooper Storage. Paper presented at thc 
Workshop on Word Order and Parsing in Unification Grammars, 
Friedcnweiler, West Germany (7- I I April). 
Montaguc, Richard 1973 The Propcr Trcatmcnt of Quantification i
Ordinary English. In Thomason, R., Ed., Formal Philosopl?y. 
Selected Papers of Richard Montague. Yale University Press, Ncw 
Haven, Connecticut. 
Moore, Robert C. 1981 Problems in Logical Fornl. In Proceedings ?~/" 
the 19th Annual Meet#lg of the Association .\[br Computational Linguis- 
tics. Stanford, California: 117-124. 
Pcreira, Fernando C.N. 1983 Logic for Natural Language Analysis. 
Technical Note 275. Artificial Intelligence Center, SRI International, 
Menlo Park, California. 
Woods, William 1977 Semantics and Quantification in Natural 
Language Question Answering. Adwmces in Computers. Vohtme 17. 
Academic Press, New York: 1-87. 
Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 55 
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings 
APPENDIX A. PROLOG IMPLEMENTATION OF THE ALGORITHM 
The following is the core of a Prolog implementation f the nondeterministic algorithm which includes all but the lowest 
level of routines. The syntax is that of Edinburgh Prologs, e.g., DEC-20 Prolog. 
Prolog Implementat ion of Scope Generat ion A lgor i thm 
/   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
Representat ion  of wffs: 
A wff of the form 'p(argl, . . . ,argn)'  is represented as the Prolog term 
wff(p,\[arg1', .... argn'\]) where argi' is the encoding of the 
subexpress ion argi. 
A constant term is represented by the homonymous Prolog constant. 
A complex term is represented by the Prolog term 
term(quant,var , restr ict ' )  where restrict'  is the encoding of the wff 
that forms the restr ict ion of the quanti f ier .  
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  ? / 
Z gen(Form,ScopedForm) 
Z Form ==> a wff with in-place complex terms 
ScopedForm <== a full scoping of Form 
gen(Form, ScopedForm) -- 
pul l(Form, true, ScopedForm). 
Z pul l(Form, Complete?, ScopedForm) 
Z 
Form 
Complete? 
ScopedForm 
==> a wff with in-place complex terms 
==> true iff only full scopings are a l lowed 
<== a full or part ia l  scoping of Form 
Appl ies terms at various level of embedding in Form, inc luding 
apply ing to the entire Form, and to opaque argument posi t ions 
inside Form. 
pull(Form, Complete, ScopedForm) -- 
pu l l_opaque_args(Form, Pul ledOpaque),  
apply terms(Pul ledOpaque,  Complete, ScopedForm).  
Z pull opaque_args(Form, ScopedForm) 
% Form =:> a term or a wff with in-place complex terms 
Z ScopedForm <== Form with opaque argument posi t ions recurs ive ly  scoped 
Z Scopes arguments of the given Form recursively.  
pul l_opaque args(wff (Pred,Args) ,  wff(Pred, ScopedArgs)) :- !, 
pu l l _opaque args(Pred, I, Args, ScopedArgs).  
pul l_opaque_args(Term, Term). 
56 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 
Jerry R. tlobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings 
Z pul l_opaque_args(Pred,  ArgIndex, Args, ScopedArgs) 
Pred ==> the predicate of the wff whose args are being scoped 
ArgIndex ==> the index of the argument current ly being scoped 
Args :=> list of args from ArgIndex on 
ScopedArgs <:= Args with opaque argument posi t ions recurs ive ly  scoped 
Scopes a given argument if opaque; otherwise, scopes its 
subparts recursively. 
Z No more arguments. 
pull_opaque_args(_Pred,_ArgIndex,\[\],\[\]) -- ! . 
Z Current argument posit ion is opaque; scope it. 
pull  opaque_args(Pred,  ArgIndex, 
\[FirstArgJRestArgs\], 
\ [ScopedFirstArgJScopedRestArgs\])  -- 
opaque(Pred,ArgIndex) ,  !, 
pu l l (F i rs tArg, fa lse ,ScopedFi rs tArg) ,  
Next Index is ArgIndex+1, 
pul l_opaque args(Pred, NextIndex, RestArgs, ScopedRestArgs) .  
Z Current argument is not opaque; don't scope it. 
pull  opaque_args(Pred, ArgIndex, 
\[FirstArglRestArgs\], 
\ [ScopedFirstArglScopedRestArgs\])  -- 
pull  opaque args(F i rstArg,ScopedFirstArg) ,  
Next Index is ArgIndex+1, 
pull  opaque_args(Pred,  NextIndex, RestArgs, ScopedRestArgs) .  
Z apply terms(Form, Complete?,  ScopedForm) 
Z 
Z Form =:> a wff with in-place complex terms 
Z Complete? :=> true iff only full scopings are al lowed 
Z ScopedForm <:: a full or part ia l  scoping of Form 
Z 
Z Appl ies one or more terms to the Form alone (not to any embedded 
Z forms. 
apply terms(Form, _Complete, Form) -- 
not(term(Form,_Term)) ,  !. 
app ly terms(Form,  false, Form). 
apply terms(Form, Complete, ScopedForm) -- 
app l i cab le term(Form,  Term), 
apply(Term, Form, Appl iedForm),  
apply terms(Appl iedForm, Complete, ScopedForm). 
Z apply(Term,Form,NewForm) 
Z Term :=> a complex term 
Z Form =:> the wff to apply Term to 
Z NewForm <== Form with the quant i f ier  wrapped around it 
apply(term(Quant ,Var ,Restr ict ) ,  
Body, 
wff(Quant, \ [Var,Pul ledRestr ict ,OutBody\]))  -- 
pul l (Restr ict ,  false, Pul ledRestr ict) ,  
subst (Var , term(Quant ,Var ,Restr ic t ) ,Body,OutBody) .  
Z appl icable_term(Form, Term) 
Z Form ==> an express ion in the logical form language 
Z Term <=: a top- level  term in Form (that is, a term embedded in 
Z no other term) which is not free in any var iable bound 
Z along the path from Form to the Term. 
Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 57 
Jerry R. Hohbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings 
app l i cab le_ term(Form,  Term) -- 
app l i cab le_ term(Form,  Term, \[\]). 
Z app l i cab le  te rm(Form,Term,B lock ingVars )  
g 
Z 
g Form :=> an express ion  in the log ica l  form language 
Z Term <=: a top- leve l  term in Form (that is, a term embedded in 
Z no other  term) wh ich  is not free in any var iab le  bound 
Z a long the path  f rom Form to the Term. 
g B lock ingVars  : :> 
Z a l ist  of var iab les  bound a long the path  so far 
Z A term is an app l i cab le  top- leve l  term.. .  
app l i cab le  te rm(term(Q,V ,R) , te rm(Q,V ,R) ,  BVs) .- 
Z if it meets  the def in i t ion .  
not ( f ree  in(BVs, R)). 
Z An app l i cab le  term of the res t r i c t ion  or body of a quant i f ie r  is app l i cab le  
Z on ly  if the var iab le  bound by the quant i f ie r  is not free in the term. 
app l i cab le  te rm(wf f (Quant , \ [Var ,Rest r i c t ,Body\ ] ) ,Term,  BVs) -- 
quant i f ie r (Quant ) ,  !, 
(app l i cab le_ term(Rest r i c t ,Term, \ [Var lBVs \ ] ) ;  
app l i cab le  term(Body,Term, \ [Var lBVs \ ] ) ) .  
Z An app l i cab le  term of an argument  l ist  is an app l i cab le  term of the wff. 
app l i cab le_ term(wf f (  P red ,Args) ,Term,  BVs) -- 
app l i cab le  term(Args ,  Term, BVs).  
Z An app l i cab le  term of any argument  is an app l i cab le  term of the who le  
% list. 
app l i cab le  term(\[FIR\] ,Term, BVs) -- 
app l i cab le  te rm(F ,Term,BVs)  ; 
app l i cab le  te rm(R,Term,BVs) .  
Z Note the absence  of a rule look ing  for app l i cab le  terms ins ide of 
complex  terms. This  l imits  app l i cab le  terms to be top- leve l .  
APPENDIX B. COMMON LISP IMPLEMENTATION OF THE ALGORITHM 
The fol lowing is the core of a COMMON LISP implementat ion of the deterministic algorithm which includes all but the 
lowest level of routines. 
; ; ; ,~***~,~,~*****~,~*******~*****~***~**~*************~**~***~*~*~**e  
;;; 
;;; COMMON LISP Imp lementat ion  of Scope Generat ion  A lgor i thm 
;;; 
* *****************************************************************************  
;;; 
;;; Representat ion  of Wffs  
;;; 
;;; A wff  of the form 'p (arg l , . . . ,a rgn) '  is represented  as the 
;;; s -express ion  (p arg1' .. argn') where  argi' is the encod ing  of the 
;;; subexpress ion  argi.  
;;; 
;;; A constant  term is represented  by the homonymous  LISP atom. 
;;; 
;;; A complex  term is represented  by the s -express ion  ( :term quant  
;;; var restr ict ' )  where  restr ict '  is the encod ing  of the wff  that  forms 
;;; the res t r i c t ion  of the quant i f ie r .  
;;; 
58 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings 
;;; Implementation notes: 
;;; 
;;; The following simple utility functions are assumed: 
;;; 
;;; map-union -- implements the binary function UNION 
;;; cross-product -- implements the function CROSS-PRODUCT 
;;; opaque -- implements the binary function OPAQUE 
;;; integers -- implements the binary function INTEGERS 
;;; 
;;; The infix union is implemented with CL function UNION. 
;;; The binary prefix union is implemented under the name MAP-UNION 
;;; to avoid conf l i c t  with the CL function UNION. 
;;; The function APPLY is implemented under the name APPLY-Q to avoid 
;;; conflict with the CL function APPLY. 
;;; 
(defun gen (form) 
(pull. form t)) 
(defun pull (form complete?) 
(map-union (pull-opaque-args form) 
(function lambda (pulled-opaque) 
(apply-terms pulled-opaque complete?))))) 
(defun pull-opaque-args (form) 
(if (not (wff? form)) 
(list form) 
(let ((predicate (first form)) 
(args (rest form))) 
(map-union (cross-product 
(mapcar (function (lambda (arg-index) 
(if (opaque predicate arg-index) 
(pull (nth (- arg-index I) args) 
nil) 
(pull-opaque-args (nth (- arg-index I) 
args)))) 
(integers I (length args)))) 
(function (lambda (args-possibility) 
(list (cons predicate args-possibility))))))) 
(defun apply-terms (form complete?) 
(if (null (terms form)) 
(list form) 
(let ((scoped-forms 
(map-union 
(applicable-terms form) 
(function (lambda (term) 
(map-union 
(apply-q term form) 
(function (lambda (applied-form) 
(apply-terms applied-form 
complete?))))) 
(if complete? 
scoped-forms 
(adjoin form scoped-forms))))) 
))) 
(defun apply-q (term form) 
(let ((quant (second term)) 
(var (third term)) 
(restrict (fourth term))) 
(map-union (pull restrict nil) 
(function (lambda (pulled-restrict) 
(list 
(list quant var pulled-restrict 
(subst var term form)))))))) 
(defun applicable-terms (form) 
(applicable-termsl form ' ())) 
Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 59 
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings 
(.defun applicable-termsl (form blocking-vars) 
(cond (atom form) 
'()) 
(and (term? form) 
(not-free-in blocking-vars (fourth form )) 
(list form)) 
(term? form) 
'()) 
(and (wff? form) 
(quantifier? (first form))) 
(union (applicable-termsl (third form) 
(cons (second form) blocking-vars)) 
(applicable-termsl (fourth form) 
(cons (second form) blocking-vars)))) 
(t (mapcan (function (lambda (arg) 
(applicable-termsl arg blocking-vats))) 
(cdr form))))) 
APPENDIX C. PROOFS OF ALGORITHM PROPERTIES 
This appendix includes informal proofs of some impor- 
tant properties of the nondeterminisitc version of the 
presented algorithm. First, we present a proof of the 
termination of the algorithm. Several criteria of the 
partial correctness of the algorithm are also informally 
shown, especially, that the algorithm does not generate 
wffs with unbound variables. 
However, we do not prove correctness in the sense of 
showing that the algorithm is semantically sound, i.e., 
that it.yields wffs with interpretations consistent with the 
interpretation of the input expression, simply because we 
do not provide a semantics for the input language. (The 
output language, of course, has a standard logical seman- 
tics.) 
We do not attempt to prove completeness for the algo- 
rithm, as the concept of completeness is open to interpre- 
tation, depending as it does on just which scopings one 
deems possible, but we expect that the algorithm is 
complete in the sense that every permutation of quantifi- 
ers respecting the considerations in the introduction is 
generated. We also do not prove the nonredundancy of 
the nondeterminism in the algorithm, i.e., that the algo- 
rithm will not generate the same result along different 
nondeterministic paths, although we believe that the 
algorithm is nonredundant. 
C.l NOTATION 
We will use lower Greek letters (a, /3 . . . .  ) as variables 
ranging over expressions in the logical form language. 
We inductively define a metric p on expressions in the 
logical form language as follows: 
t 2 + p(r) if a is a complex term < q vr > 
n n 
O(a) ~ 1 + i_ZtO(ai) if a is a wfff(al ,  ... , a,) and_EtO(a i) > 0 
0 otherwise 
Informally, p is a measure of the embedding depth of the 
complex terms in an expression. 
c.2 TERMINATION 
We will give an informal proof of termination for the 
nondeterministic algorithm by induction on this metric p. 
But first, we present without proof three simple but 
useful properties of the metric. 
Lemmal  If a is a wff, then p(a) = 0 i f  and only if a 
contains no complex terms. 
Lemma 2 If a is a wff and/3 is a subexpression of a and 
p(a) > O, then p(/3) < p(a) 
Lemma 3 If a is a wff and/3 is a subexpression f a and 
p(a) = O, then p(/3) = O. 
We now prove the following theorem, and its corollary 
which gives the termination of the algorithm. We assume 
that calls to the auxiliary functions wff, term, wff?, term?, 
predicate, arguments, opaque, map, exists, not, applicable- 
term, subst, and so forth always terminate if the computa- 
tion of their arguments terminates. 
Theorem 1. For all expressions a, the following six 
conditions hold': 
Condition 1: pull-opaque-args(a) terminates with result/3 
such that p(/3) _< p(a), 
Condition 2: for all complex terms t in a, apply(t,a) termi- 
nates with result/3 such that p(/3) < p(a), 
Condition 3: apply-terms(a,true) terminates with result /3 
such that p(/3) = O, 
Condition 4: apply-terms(a f lse) terminates with result/3 
such that p(/3) _< p(a), 
Condition 5: pull(a,true) terminates with result /3 such 
that p(/3) = O, 
Condition 6: pull(a~false) terminates with result /3 such 
that p(/3) _< p(a). 
60 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 
Jerry R. Hobbs and Stuart M. Shieber An Algorilhm for Generating Quanlifier Scopings 
Proof." We first prove the base case, for p(a)  = 0. By 
Lemma 1, a must contain no complex terms. Three of 
the conditions are easily proved. 
Condition 2: Since, by Lemma 1, there are no complex 
terms in a, this condit ion holds vacuously. 
Condition 3: Again, the absence of complex terms in a 
causes the call to apply-terms to return with result a, 
and p(a) = 0, so the condit ion holds. 
Condit ion 4: Similarly, and p(a)  < p(a) trivially. 
Condit ions 1,5, and 6: These condit ions follow directly 
from Lemma 4 given below. 
Lemma 4 For  all expressions a such that p(a)  = 0, 
pull(a,x) and pull-opaque-args(a) terminate 
with result a. 
Proof sketch: The proof is by a simple induction on 
the length of the expression, and uses the base case for 
conditions 3 and 4 proved above. 
For the induction step for Theorem 1, we assume the 
induction hypotheses that the six condit ions hold for all a 
such that p(a)  < n and prove the condit ions for p(a)  = n, 
for n>0.  The condit ions are proved sequentially. In 
particular, earlier condit ions for the case p(a) = n are 
used in the proofs of later ones. (Since there is no use of 
later conditions in earlier ones, this does not introduce 
any circularity in the proof.) 
Condition 1: We must show that pull-opaque-args(a) 
terminates with result/3 such that 0(\[3) < o(a). If a is 
not a wff, then the condit ion holds vacuously, so we 
assume that a = f (a  I . . . . .  a~). By definition of p, 
k 
p(/3) ___ 1 + ~P(/3i)" 
i= 1 
(The inequality is necessary because p(/3) may be 
zero.) Now/3~ is either a~ or pull(a~false). In the first 
case, p(/3) < p(a~) trivially. In the second case, since 
a~ is a subexpression of a, by Lemma 2 we have that 
p(a~) < p(a)  and we can use the induction hypothesis 
to show the termination of the call to pull. Also by 
the induction hypothesis, p(fl,) < p(a~). 
Thus, we see that in either case, p(/3~) < p(a~). So 
k k 
p(fl) < 1 + Zp( f l i )  < 1 + Zp(a i )= p(a). 
i= I i= 1 
Condition 2: We must show that for all terms t in a, 
apply(t,a) terminates with result /3 such that p(/3) < 
p(a). Suppose t= <qvr>.  Then /3 = apply(<q v 
r>, a) = q(v, 3", 6) where 3' = pull(r, false) and 6 = 
subst(v, <q v r>, a). 
Now, let p(r) = m. By Lemma 2, m < n. So by the 
induction hypothesis, the computat ion of 3, terminates 
and p(3') < m. Also, the computat ion of 6 is assumed 
to terminate (as mentioned above) with 6 missing the 
complex term t that occurs in a (and possibly other 
complex terms embedded within t). So 
p(a) _< p(a) - -p ( t )  =n-  (2+p(r ) )  =n- -2 - -m.  
Finally, by definit ion of p we have p(fl) < 1 + p(3,) + 
p(6) < 1 +m+n-2-m=n-1  <n.  
We will use the two condit ions just proved in the 
proofs of the final four conditions. 
Cond#ion 3: We must show that apply-terms(a,true) 
terminates with result /3 such that 0(/3) = 0. By 
Lemma 1, we know that complex terms exist in a so 
the else clause is taken. Let t = applicable-term(a) 
and 3, = apply(t,a). By the second condit ion just 
proved above, the latter computat ion terminates with 
P(3,) _< p(a) - 1 < n. Now let e = apply-terms(3,, 
true). Again, by the induction hypothesis, this compu- 
tation terminates with p (?)  = 0. Since complete? = 
true, we return ? as/3, so p(/3) = 0 as required. 
Condition 4: We must show that apply-terms(a f lse) 
terminates with result /3 such that p(/3) < p(a).  By 
Lemma 1, we know that complex terms exist in a so 
the else clause is taken. Let t = applicable-term(a) 
and 3' = apply(t,a). By the second condit ion just 
proved above, this computat ion terminates with p(3') 
< p(a) - 1 < n. Now let ? = apply-terms(3'false). 
Again by the induction hypothesis, this computat ion 
terminates with p (e )  < p(3') < n. Since complete? = 
false, we return ? or a as /3. In either case, 0(/3) < 
p(a)  as required. 
We will use the four condit ions just proved in the 
proofs of the final two conditions. 
Condition 5: We must show that pull(a,true) terminates 
with result/3 such that p(/3) = 0. Let 3' = pull-opaque- 
args(a). By the first condit ion just proved above, we 
know this computat ion terminates and 0(3') < n. Now, 
let e = apply-terms(3",true). Again by the third condi- 
tion just proved above, this computat ion terminates 
with p (e )  = 0. Since complete? = true, we return ? 
as/3, so p(/3) = 0 as required. 
Condition 6: We must show that pull(a false) terminates 
with result fl such that p(/3) < p(a).  The argument is 
similar to that for condit ion 5. Let 3' = pull-opaque- 
args(a). By the first condit ion just proved above, we 
know this computat ion terminates and P(3,) < n. Now, 
let c = apply-terms(3", false). Again by the fourth 
condit ion just proved above, this computat ion termi- 
nates with p (?)  < p(3') _< n. Since complete? = false, 
we return either E or a as /3. In either case, p(/3) < 
p(a)  as rquired. 
This completes the proof of the six conditions, given 
the induction hypotheses, and thus completes the induc- 
tive proof of the theorem. 
Corollary 1 For  all wffs a, gen(a) terminates with result 
/3 such that/3 has no complex terms as subexpressions. 
Proof: This follows immediately from the fifth condi-  
tion in Theorem 1 and Lemma 1. 
Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 61 
Jerry R. Hobbs and SIuart M. Shieber An Algorithm for Generaling Quantifier Scopings 
C.3 CORRECTNESS 
We consider several criteria for correctness of the algo- 
rithm. Let U(a) = the set of variables that are unbound 
in a and V(a) = the set of variables that are vacuously 
quantif ied in a. 6 We show that if input expression a is 
well-formed, that is, has no unbound variables and no 
vacuous quantif iers (U(a)  = V(a) = ~), and if /3 = 
gen(a),  then 
Criterion 1:/3 has no complex terms; 
Criterion 2:/3 has no unbound variables (U(/3) = ~); 
Criterion 3:/3 has no vacuous quantif iers (V(/3) = ~); 
Criterion 4: for every complex term t in a, there is a 
quantif ier in /3 that binds the same variable as t and 
has the position held by t in a in its body; and 
Criterion 5: for every quantif ier q in /3, there is either a 
quantif ier in a or a complex term in a that binds the 
same variable. 
Proof of these five statements does not constitute a 
proof of correctness, but provides motivation for assum- 
ing the correctness of the algorithm. As unbound vari- 
ables in the output are the prime symptom of problems 
with previous algorithms, we take these criteria to be the 
most critical for indicating correctness. 
The first criterion follows directly from Corol lary 1. 
The second and third criteria are a consequence of the 
following theorem which we prove informally. 
Theorem 2 For  all expressions such that U(a)= 
u= {u I. . . . .  u,,,} and V(a)=v= {v I. . . . .  v~}, and 
for b E {true, false} and for/3 any of gen(a), pull(a, b), 
pull-opaque-args( a ), apply-terms(a, b ) , and 
apply(applicable-term(a), U(/3) = u and V(/3) = v. 
Proof: Again, the proof is by induction on O(a), but 
we will be less formal in demonstrat ing the wel l - founded- 
ness of the induction. The base case is trivial because, as 
shown in the proofs of Theorem 1 and Lemma 4, the 
functions all return their argument unchanged when p(a) 
= 0. For  the induction step, we will merely show that 
each function maintains the unbound variables and vacu- 
ous quantifiers, assuming that all the others do. The 
previous proof of termination provides the wel l - founded- 
ness of this proof. 
apply(applicable-term(a),a): We must show that if 
t = < qxr  > is an appl icable term in a and U(a) = u 
and V(a) = v then U(apply(t,a)) = u and V(apply(t,a)) 
= v as well. 
The unbound variables u in a can be divided into 
two (possibly overlapping) sets u~ and u, where u, 
consists of those variables in u that occur in r and U, 
consists of those variables in u that occur outside of t 
in a. Note that u = u, U u~. Now assume x occurs in r. 
Then U(r) = {x} O u~ O u 0 where u 0 is the set of vari- 
ables bound within a but outside of t and which occur 
free in r. But t is an appl icable term, and by the defi- 
nition of "appl icable term" Uo must be empty. So 
U(r) = {x} U ur. (If x does not occur in r, a similar 
argument shows that U(r) = Ur .) 
Let r t = pull(r, false) and s = subst(x,t,a). By the 
induction hypothesis, U( / )= {x} U ur. Since s does 
not include t (which binds x) but does include 
x, U(s) = {x} U u~. In forming the quantif ied wff 
/3 = q(x, r t, s), the unbound variables in /3 consist of 
those in r r and those in s except for x, that is 
u( /3 )  = \ [ ({x}  u u~) u ({x}  u ur)\]  - {x} = u~ u u~ = u.  
(If x does not occur in r, similar arguments how that 
U(r ' )=u r, U (s )= {x}Uu s, and U( /3)= \[({x} UU,) 
o u~\] - {x} = u, u Ur = U.) 
Vacuous quantif ied variables can be divided simi- 
larly into v~ (those bound vacuously in r) and v~ (those 
bound vacuously outside of t in a). Again, v = vr U v,. 
Trivially, V(r) = Vr. By induction, V(r') = Vr also. 
Since s does not include t, V(s) = v~. V(/3) = 
V(r) U V(s) = v unless the quantif ication of x in 13 is 
vacuous. Since x is guaranteed to occur in s (as it 
replaces t in s), the quantif ication is clearly not vacu- 
ous. So I/(/3) = v. 
apply-terms(a,b): This follows straightforwardly from the 
previous subproof  for apply and the induction hypoth-  
esis for apply-terms. 
pull-opaque-args(a): If a is not a wff, then the proof is 
trivial. Otherwise, there are two cases, depending on 
whether the predicate in a, p, is or is not a quantif ier. 
If p is not a quantif ier, then the result fol lows imme- 
diately from the induction hypothesis for pull and pull- 
opaque-args. 
If p is a quantif ier, then let a = p(x,r,s). The output 
/3 then is wff(p, pull-opaque-args(x), pull- 
opaque-args(r), pull-opaque-args(s)). The first call to 
pull-opaque-args merely returns x. Now by an argu- 
ment similar to that given in the subproof  for apply, 
the unbound variables in a can be exhaustively divided 
into Ur and U, depending on whether they occur in r 
and s. Depending on whether x occurs in r, 
U(r) = {x} U u, or U(r) = u, Similarly, U(s) = {x} U U, 
or U(s )= u~. Suppose the second and third calls to 
pul l -opaque-args return r ~ and s t respectively. By the 
induction hypotheses U(r t) = U(r) and U(J )  = U(s). 
If the quantif ication of x in a is not vacuous, then x 
occurs free in either r or s (and by induction in r r or s t) 
so U(/3) = {x} U ur U U~ - {x} = u. If the quanti f icat ion 
of x is vacuous, then U(r t )=u~ and U( J )=U,  and 
U(/3)  = u.  
Vacuous quantif ied variables can be divided into vr 
and v~ similarly. Suppose the quanti f icat ion of x is 
vacuous (i.e., x does not occur free in r or s). Then V 
V(a) = {x} U v, Uv,. By the induction hypothesis,  
V(r t) = V(r) = v~ and V(s t) = V(s) = v~. Also by 
induction, x does not occur free in r t or s t, Therefore,  
the quantif ication of x in /3 is also vacuous and 
V(/3) = {X} U V r U V s = V(a).  
If the quantif ication of x is not vacuous, then 
v -- vr O v~ and x occurs free in either r or s. By induca- 
62 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings 
tion, x .Occurs free in either r p or  s p so the quant i f ica-  
t ion of  x in/3 is also non-vacuous.  A lso by induct ion 
as before,  V(r ~) = Vr and V(J)  = v~, so 
V(fl) = V(r') U V(s') = v r U v s = V(a). 
pull(a,b): This fo l lows directly, using the prev ious ly  
proved induct ion steps for apply-terms and pull- 
opaque-args. 
gen(a): This fo l lows directly, using the previous ly  proved 
induct ion step for pull. 
This concludes the proof  of  the induct ion step and the 
theorem. 
The second and third criteria fo l low f rom the 
presumed wel l - fo rmedness  of  a and Theorem 2 which 
demonstrates  that gen maintains wel l - formedness.  
The fourth and f i fth criteria we argue informal ly  as 
fol lows: Since no complex  terms occur  in /3 (by Coro l -  
lary 1), we can assume that every  complex  term t in a 
was appl ied (i.e., the first a rgument  of  apply) at some 
t ime in the process ing of  a. But  if it was appl ied, then it 
must have been  an appl icable term occurr ing in the wff  it 
was appl ied to (as the only  call to apply is of this form).  
Then  the call to subst in apply will not  be vacuous,  the 
quant i f ier  will b ind the same var iable as t and will 
outscope the posit ion held by t in a. Thus the fourth 
cr i ter ion holds. A lso  note  that all quant i f iers  in /3 are 
e i ther  the result of  such an appl icat ion or were in a 
originally. Thus the f i fth cr i ter ion fo l lows immediate ly  as 
well. 
NOTES 
1. William Keller (1986) has also noted this problem with Cooper's 
method. His independent solution to the problem, stated in terms 
of "nested Cooper storage", resembles the one presented here. 
2. These heuristics should themselves be made available in a public 
forum. 
3. A nondeterministic version of the algorithm, formulated by both 
authors, was presented by Hobbs (1983). 
4. Note that this term is applicable according to the criterion discussed 
above, whereas the embedded term binding y is not. The fact that 
we still get both scopings even without the possibility of applying 
the embedded term first demonstrates that the restriction on appli- 
cable terms does not affect completeness of the algorithm. 
5. This problem was pointed out to us by Fernando Pereira. 
6. A variable v is vacuously quantified in an expression ~if and only if 
v is bound in a subexpression of a, a quantified wff of the form 
q(v, r, s) and v does not occur free in r or s. This definition implies 
that variables bound by complex terms are never vacuously quanti- 
fied. 
Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 63 
