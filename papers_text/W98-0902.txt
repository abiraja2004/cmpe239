Computing Declarative Prosodic Morphology 
Markus Walther 
Seminar ftir Al lgemeine Sprachwissenschaft 
Heinrich-Heine-Universit~it Dt sseldorf 
Universit~itsstr. 1, D-40225 Dtisseldorf, Germany 
wal ther@ling, uni -duesseldor  f. de 
Abstract 
This paper describes a computational, declarative 
approach to prosodic morphology that uses invio- 
lable constraints o denote small finite candidate sets 
which are filtered by a restrictive incremental opti- 
mization mechanism. The new approach is illustrated 
with an implemented fragment of Modern Hebrew 
verbs couched in MicroCUF, an expressive con- 
straint logic formalism. For generation and parsing 
of word forms, I propose anovel off-line technique to 
eliminate run-time optimization. It produces a finite- 
state oracle that efficiently restricts the constraint in- 
terpreter's search space. As a byproduct, unknown 
words can be analyzed without special mechanisms. 
Unlike pure finite-state transducer approaches, this 
hybrid setup allows for more expressivity in con- 
straints to specify e.g. token identity for reduplica- 
tion or arithmetic constraints for phonetics. 
1 Introduction 
Prosodic morphology (PM) circumscribes a number 
of phenomena r nging from 'nonconatenative' root- 
and-pattern morphology over infixation to various 
cases of reduplication, where the phonology strongly 
influences the shape of words by way of obedience 
to structural constraints defining wellformed morae, 
syllables, feet etc. These phenomena have been diffi- 
cult to handle in earlier ule-based treatments (Sproat 
1992, 159 ft.). Moreover, as early as Kisseberth 
(1970) authors have noted that derivational ccounts 
of PM are bound to miss important linguistic gen- 
eralizations that are best expressed via constraints. 
Kisseberth showed that verb stems in Tonkawa, a 
Coahuiltecan language, display a complex V/~ al- 
ternation pattern when various affixes are added (fig. 
1). This leads to more and more complicated vowel 
deletion rules as the fragment isenlarged. In contrast, 
a straightforward constraint that bans three consecu- 
tive consonants offers a unified account of the condi- 
tions under which vowels must surface. Later devel- 
'to cut' "to lick' 
picn-o? 
we-pcen-o? 
picna-n-o? 
netl-o? ( 3sg.obj.stem-3sg.subj. ) 
we-ntal-o? ( 3pl.obj.-stem-3sg.subj. ) 
netle-n-o? ( 3sg.obj.stem-prog.-3sg.subj. ) 
p(i)c(e)n(a) n(e)t(a)l(e) stems 
Figure 1: Tonkawa verb forms with V/~ effects 
opments have refined constraints such as ,CCC to re- 
fer to syllable structure instead: complex codas and 
onsets are disallowed. At least since Kahn (1976), 
Selkirk (1982), such segment-independent r ference 
to syllable structure has been standardly assumed in 
the generative literature. 
Astonishing as it may be, even the latest computa- 
tional models of PM phenomena apparently eschew 
the incorporation of real prosodic representations, 
syllabification and constraints. Kiraz (1996) uses 
multi-~tape two-level morphology to analyze some 
Arabic data, but - despite the suggestive title - must 
simulate prosodic operations uch as 'add a mora' 
by their extensionalized rule counterparts, which re- 
fer to C or V segments instead of moras. There is no 
on-line syllabification and the exclusive use of lexi- 
cally prespecified syllable-like symbols on a separate 
templatic pattern tape renders his approach vulnera- 
ble to postlexical resyllabification effects. Similarly, 
Beesley (1996) seems content in employing a great 
number of CV templates inhis large-scale finite-state 
model of Arabic morphology, which are intersected 
with lexical roots and then transformed tosurface re- 
alizations by various epenthesis, deletion and assim- 
ilation rules. Beesley states that further application 
of his approach to e.g. Hebrew is foreseen. On the 
downside, however, again there is no real prosody in 
his model; the relationship between template form 
and prosody is not captured. 
Optimality Theory (OT, Pnnce & Smolensky 
1993), as applied to PM (McCarthy & Prince 1993), 
does claim to capture this relationship, using a 
11 
ranked set of violable prosodic onstraints ogether 
with global violation minimization. However, to date 
there exist no sufficiently formalized analyses of 
nontrivial PM fragments that could be turned into 
testable computational models. The OT framework 
itself has been shown to be expressible with weighted 
finite-state automata, weighted intersection and best- 
path algorithms (Ellison 1994) if constraints and 
OT's GEN component - the function from under- 
lying forms to prosodified surface forms - are reg- 
ular sets. A recent proposal by Karttunen (1998) 
dispenses with the weights while still relying on 
the same regularity assumption. Published PM anal- 
yses, however, frequently make use of constraint 
? parametrizations from the ALIGN family, which re- 
quires greater than regular power (Ellison 1995). 
Further developments of OT such as correspondence 
theory - extensively used in much newer work on 
PM - have not received a formal analysis o far. Fi- 
nally, although OT postulates that constraints are uni- 
versal, this metaconstraint has been violated from the 
outset, e.g. in presenting Tagalog -um- as a language- 
specific parameter to ALIGN in Pnnce & Smolen- 
sky (1993). Due to the convincing presentation of 
a number of other forceful arguments against con- 
straint universality in Ellison (to appear), the case for 
language-specific constraints must clearly be seen as 
reopened, and - as a corollary - the case for con- 
straint inviolability as well. 
Declarative Phonology (DP, Bird 1995, Scobbie 
1991 ) is just such a constraint-based framework that 
dispenses with violability and requires amonostratal 
conception of phonological grammar, as compared 
to the multi-level approaches discussed above. Both 
abstract generalizations and concrete morphemes are 
expressed by constraints. DP requires analyses to 
be formally adequate, i.e. use a grammar descrip- 
tion language with formal syntax and semantics. As 
a consequence, Chomsky's crteda for a generative 
grammar which must be "perfectly explicit" and "not 
rely on the intelligence of the understanding reader" 
(Chomsky 1965, 4) are automatically fulfilled. DP 
thus appears to be a good starting point for a restric- 
tive, surface-true theory of PM that is explicitly com- 
putational. 
The rest of this paper eviews in informal terms the 
theory of Walther (1997) (section 2), showing in for- 
mal detail in section 3 how to implement a concrete 
analysis of Modern Hebrew verbs. Section 4 explains 
a novel approach to both generation and parsing of 
word forms under the new theory. The paper con- 
cludes in section 5. 
2 Declarative Prosodic Morphology 
Focussing on cases of 'nonconcatenative' root-and- 
pattern morphology, Declarative Prosodic Morphol- 
ogy (DPM) starts with an intuition that is opposite to 
what the traditional idea of templates or fixed phono- 
logical shapes (McCarthy 1979) suggests, namely 
that shape variance is actually quite common and 
should form the analytical basis for theoretical ac- 
counts of PM. Besides the Tonkawa case (fig.l), 
shape variance is also at work in Modern Hebrew 
(MH) inflected verb forms (Glinert 1989), see fig. 
2.1 Here we see a systematic V/O alternation of both 
past future 
l sg gamar-ti 
2sg.m gamar-ta 
2sg.f gamar-t 
3sg.m gamar 
3sg.f gamr-a 
lpl gamar-nu 
2pl gamar-tem 
3pl gamr-u 
?e-gmor 
ti-gmor 
ti-gmer-i 
ji-gmor 
ti-gmor 
ni-gmor 
ti-gmer-u 
ji-gmer-u 
Figure 2: Modern Hebrew xfg.m.r ~nish' (B1) 
stem vowels, depending on the affixation pattern. 
This results in three stem shapes CVCVC, CVCC and 
CCVC. Any analysis that simply stipulates shape se- 
lection on the basis of specific inflectional categories 
or phonological context (e.g. 3sg.f V 3pl or -V .-~ 
CVCCstem / B 1 past) misses the fact that the shapes, 
their alternating behaviour and their proper selec- 
tion are derivable. Derivational repairs by means of 
'doubly open syllable' syncope rules (/ga.ma.r-a./ 
/.gam.ra./) are similarly ad hoc. 
? A first step in developing an alternative DPM 
analysis of MH verbs is to explicitly recognize al- 
ternation of an element X with zero - informally 
written (X) - as a serious formal device besides 
its function as a piece of merely descriptive no- 
tation (cf. Hudson 1986 for an earlier application 
to Arabic). In contrast o nonmonotonic deletion 
or epenthesis, (X) is a surface-true declarative x- 
pression (Bird 1995, 93f.). The reader is reminded 
tRegular MH verbs are traditionally divided into seven ver- 
bal classes or binyanim, B I-B7. Except for B4 and B6, which 
regularly act as passive counterparts of B3 and B4, the semantic 
contribution of each class is no longer transparent i  the modem 
language. Also, in many cases the root (written ~/'C~ .C~.Cs) is 
restricted to an idiosyncratic subset of the binyanim. 
An a-templatic treatment of MH prosodic morphology was 
first proposed by Bat-El (1989, 40ff.) within an unformalized, 
non-surface-tree, non-constraint-based setting. 
12 
that DP sees grammar expressions as partial for- 
mal descriptions of sets of phonological objects. The 
former reside on a different ontological level from 
the latter, in contrast o traditional object-to-object 
transformations on the same level. Hence a prelim- 
inary grammar expression g(V1)m(V2)r for a He- 
brew stem (with abstract stem vowels) denotes the 
set {gmr, gVlmr, gmV2r, gVlmV2r). Note that the 
(X) property as attributed to segmental positions is 
distinctive - in contrast o stem vowels root seg- 
ments do not normally alternate with zero, and nei- 
ther do affix segments in an important asymmetry 
with stems. This point is reinforced by the exceptions 
that do exist: phonologically unpredictable C/~ al- 
ternation occurs in some MH stems, e.g. natan/lakax 
'he gave/took' vsfi-ten/ji-kax 'he will give/take'; by 
surface-true (n/l) encoding we can avoid diacritical 
solutions here. 
? Step two uses concatenation to combine indi- 
vidual descriptions of stems and affixes, besides con- 
necting segmental positions within these linguistic 
entities. Since, as we have just seen, a single de- 
scription can denote several objects of varying sur- 
face stnng length, concatenation (^) at the description 
level is actually powerful enough to describe 'non- 
concatenative' morphological phenomena. In DPM 
these do not receive independent ontological status 
(cf. Bird & Klein 1990 and Gafos 1995 for other for- 
mal and articulatory-phonological arguments leading 
to the same conclusion). A more detailed escription 
of the 3pl.fut. inflected form of x~g.m.r might here- 
fore be j^i^g'(V1)^m^(V2)r^u. In order to allow for 
paradigmatic 2 generalizations over independent enti- 
ties such as root and stem vowel pattern within con- 
catenated escriptions, a hierarchical lexicon con- 
ception based on multiple inheritance of named ab- 
stractions can be used (cf. Riehemann 1993). 
? Step three conjoins aword form description with 
declarative syllabification and syllable structure 
constraints in order to impose prosodic well- 
formedness conditions. For Modem Hebrew (and 
Tonkawa), the syllable canon is basically CV(C). 
Expressed in prosodic terms, complex codas and 
onsets are banned, while an onset must precede ach 
syllable nucleus. These syllable roles are established 
in the first place by syllabification constraints that 
exploit local sonority differences between successive 
segments (Walther 1993). Alltogether, the ensemble 
2See Walther (1997) for a discussion of various ways to de- 
rive rather than stipulate the syntagmatic pattern of alternating 
and non-alternating segmental positions within stems. 
of prosodic Constraints indeed succeeds in narrow- 
ing down the set for the 3sg.m past tense form 
to {*.9mr., *.9amr., *.9mar., !.9a.mar.} = 
/gamar/. For 3pl. future tense B1, how- 
ever, an unresolved ambiguity remains: in 
{.jig.me.ru.,.ji.gam.ru.}, only the first ele- 
ment is grammatical. 3 An important observation is
that in general there can be no purely phonological 
constraint o disambiguate this type of situation. 
The reason lies in the existence of minimal pairs 
with different category. In our case, homophonous 
/.ji.gam.ru./ is grammatical as 3pl. fut. B2 'they 
will be finished'. We will return to the analysis of 
such cases after proposing a specific disambiguation 
mechanism in the next step. 
? Step four eliminates the remaining ambiguity 
by invoking an Incremental Optimization Princi- 
ple (IOP): "For all (X) elements, prefer the zero al- 
temant as early as possible". "Early" corresponds to
traditional left-to-right directionality, but is meant o 
be understood w.r.t, the speech production time ar- 
row. "As possible" means that IOP application to 
a (X) position nevertheless realizes X if its omis- 
sion would lead to a constraint conflict. Hence, 
the IOP correctly rules out the second element 
of {.jig.me.ru.,*.ji.9ara.ru.}. This is because 
.ji.gam.ru. represents a missed chance to leave out 
/a/, the earlier one of the two stem vowels. The reader 
may verify that the IOP as it stands also accounts 
for the Tonkawa data of fig. I. Tonkawa lends even 
clearer support to IOP's left-to-right nature due to the 
larger number of V/O vowels involved. As a limit- 
ing case, the IOP predicts the possibility of vowel- 
less surface stems, e.g. formed by two root conso- 
nants combined with vowel-final prefix and suffix. 
This prediction is strikingly confirmed by MH forms 
like te-lx-i 'you (sg.f.) will go' ~/(h).l.x, ti-kn-u 
'you/they (pl.) will buy' ~/'k.n.O, ti-tn-i 'you (sg.f.) 
will give' ~/(n).t.n; similar cases exist in Tigdnya. 
There can be no meaningful prosodic characteriza- 
tion of isolated CC stem shapes; only a wordform- 
based theory like the present one may explain why 
these forms exist. 
Note that, conceptually, IOP is piggybacked on au- 
tonomous DP-style constraint interaction. It merely 
filters the small finite set of objects described by 
the conjunction of all constraints. From another an- 
gle, IOP can be seen as a single context-free sub- 
3Note that the prosodic view explains the pronounced influ- 
ence of (C)V affixes on the shape of the whole word: they pro- 
vide a nonalternating syllable nucleus which can host adjacent 
stem consonants. 
13 
stitute for the various syncope rules employed in 
former transformational analyses. The claim is that 
fixed-directionality-IOP is the only such mechanism 
needed to account for PM phenomena. 
A distinguishing feature of the IOP is its poten- 
tial for an economical procedural implementation 
in incremental production. If constraint contexts are 
sufficiently local, the pnnciple can locally decide 
over (X) nonrealizations and there will be very lim- 
ited backtracking through delayed etection of con- 
straint violation. Because the IOP stops after find- 
ing the first (X) realization pattern that violates no 
constraints, it has less formal power than global opti- 
mization which must always consider all candidates. 
Moreover, the IOP supports economic ommunica- 
tion, as it leads to shortest surface forms wherever 
possible. Finally, at least for root-and-pattern mor- 
phologies it can be argued to aid in speech per- 
ception as well. This is because the closed class of 
stem vowel patterns is less informative than open- 
class root segments. Since IOP-guided vowel omis- 
sion causes root segments to (statistically) appear 
at an earlier point in time from the acoustic onset 
of the word, the IOP hypothesis actively prunes the 
size of the cohort of competing lexical candidates. 
As a result, unambigous recognition will generally 
be achieved more quickly during continous lexical 
access. In sum, the IOP hypothesis not only pos- 
sesses overall psycholinguistic plausibility but actu- 
ally gives some processing advantage to shape vari- 
ance. If future research provides the necessary ex- 
perimental confirmation, we have yet another case of 
performance shaping competence. 
? Step five returns to the minimal pairs problem 
highlighted in step three: what to do with anti-IOP 
realizations such as that of/a/in/. j i .gam.ru./for B2
fut.? The answer is (prosodic) prespecification. A 
surface-true constraint demands that B2 future and 
infinitive as well as all of B3, B4 must have an onset 
role for the first stem element. Thus, the possibility 
of IOP eliminating the first stem vowel is blocked by 
the constraint inconsistency that arises for the first 
stem element: either syllabification licenses an in- 
compatible coda or first and second stem segment 
together form an illformed onset cluster. Note that if 
the constraint is lexicalized as part of the grammat- 
ical description of first stem position, it will have a 
maximally local context, referring to just the position 
itself. In general, DPM analyses pay much attention 
to proper attachment sites of constraints in order to 
maximize their locality. 
The MH verbal suffix -et (fem.sg.pres.) illustrates 
that sometimes another, segmental mode of prespec- 
ification is useful. This suffix is always preceded by 
a syllable ending in /el, although IOP application 
alone would e.g. prefer */gom.ret/over/go.me.ret/ 
'she finishes'. The effect is morpheme-specific since 
other -VC suffixes behave as expected here: gomr- 
im/ot 'they (masc./fem.) finish'. One solution is to let 
part of the suffix definition be a constraint statement 
which demands that the segment two positions to its 
left must be a front vowel. This move captures both 
the stability and the quality of this vowel at the same 
time. (Apophony constraints ensure that the second 
stem vowel is never/i/except in B5, which signifi- 
cantly has a different suffix -a in place of -et). Note 
that prespecifying the presuffixal segment to be in an 
onset position would not work. 
3 On implement ing  analyses 
In the following I show how to implement a toy frag- 
ment of MH verbs using the MicroCUF formalism, 
a typed, feature-based constraint-logic programming 
language suitable for natural language modelling. 
MicroCUF implements a subset of CUF (D6rre & 
Dorna 1993), inheriting its formal semantics. It was 
initially delevoped by the author to overcome ffi- 
ciency problems with CUF's original type system. 
Additionally, its simpler implemenation provides an 
open platform for experimental modifications, as 
needed e.g. for parsing and generation with DPM. 
After briefly introducing the essentials of MicroCUF 
first, the MH analysis is developed and explained. 
3.1 The MicroCUF constraint formalism 
This section assumes a basic knowledge of Prolog. 
Like in Prolog, MicroCUF variables tart with upper- 
case letters or _ , whereas relational symbols, fea- 
tures and simplex types start in lowercase; % marks 
a comment (fig. 3a). Relations like member are writ- 
ten in functional notation, with a notationally distin- 
guished result argument on the nghthand side of : = 
and the relation symbol plus its (optional) arguments 
on the lefthand side. Subgoals like member (Elem) 
Can occur anywhere as subterms. Instead of Prolog's 
fixed-arity first order terms, MicroCUF has typed 
feature terms as its basic data structures. As illus- 
trated in fig. 3b, subterms are explicitly conjoined 
with & or disjunctively combined with ;, while only 
type terms may be prefixed by the negation oper- 
ator ,-.,. Features like l e f t ,  cat  are separated 
from their righthand value terms by :. Terms may be 
tagged by conjunction with a variable (vl), allowing 
for the expression of structure sharing through mul- 
14 
tiple occurences of the same variable. Feature appro- 
priateness declarations ( : : ) ensure that both the term 
in which a feature occurs and its value are typed. For 
comparison, the result value of f s  appears in HPSG- 
style notation under fig. 3c. 
a. 
% MicroCUF 
member(Elem) := \[ElemI_\]. 
member(Elem) := \[_Imember(Elem)\]. 
%Prolog 
member(Elem, \[Eleml_\]). 
member(Elem, \[_IRest\]) :- member(Elem, Rest). 
b. 
fs:=cat: (~((b2;b3;b5)&past)&Vl)&left :cat:Vl .  
phonl ist : : \ [cat :categor ies\] .  
segmental positions to the left - a frequent situation 
in phonological contexts - we supplement i  with a 
new feature le f t  to yield bidirectional lists. For this 
doubly-linked list encoding to be wellbehaved, a step 
right followed by a step left is constrained to return to 
the same position Se l f  (3), thus yielding cyclic fea- 
ture structures. Next, the value of the feature cat at 
the current position is connected with its right neigh- 
bour (3-4). In the face of our recursively structured 
lists this makes morphological nd other global cate- 
gorial information locally accessible at each segmen- 
tal position. Finally, relations to incrementally clas- 
sify each segmental position as word-initial, medial 
or wordfinal and to impose prosodic constraints are 
added in (5-6). 
Basic concatenation is used in (10-12) to define 
X/O positions. 
C. 
fs 
plzotzlist \] 
eat ~ ~ ( (b2 v b3 v b5) ^  past ) 
left r phOnlist \] 
\[cat D\] 
Figure 3: MicroCUF vs Prolog and HPSG notation 
3.2 Modern Hebrew verbs in MicroCUF 
Below I present a concrete MicroCUF grammar 
in successive pieces. It encodes a toy fragment 
of MH verbs and represents a simplified excerpt 
from a much larger computational grammar. For 
lack of space, the type hierarchy - specifying syl- 
lable roles, segments, morphological categories and 
word-peripheral position - and the definition of 
syllabi fy (formalized in Walther 1995) have been 
omitted. 
Let us start the explanation with a basic 
concatenation relation which adds a position Se l f  
in front of some string of Segments (1-6). 
1 conc(Self, Segments) := 
2 Self & 
3 r ight: (Segments&left :Sel f&cat:Cat)  
4 cat:Cat & 
5 c lass i fy_pos i t ion_ in_word & 
6 constraints. 
7 
8 c lass i fy_pos i t ion_ in_word := 
9 r ight:self : ' - ini '  & left:self: ' -f in'.  
Here, the familiar recursive first-rest encoding of 
lists translates into se l f - r ight  features. This alone 
makes self and (arbitrarily long) right-context ref- 
erences possible. To support looking one or more 
i0 
ii 
12 
13 
14 
15 
16 
17 
x_0(_, Segments) := segments. 
x_0(X, Segments) := mark:marked & 
conc(X, Segments). 
obl(X, Segments) := mark:unmarked & 
conc(X, Segments). 
is(Segment) := self :seg:Segment. 
The first clause of x_0 (10) realizes the zero alternant 
by equating in its second argument the Segments to 
follow with the result argument; the first argument 
holding x is unused. It gets used in the second clause 
(11-12), however, where it is prefixed to the follow- 
ing Segments by ordinary concatenation. The value 
of an additional feature mark specifies that realiz- 
ing an X position is marked w.r.t, the IOP, whereas 
no such value is prescribed in the first clause. In- 
stead, the marking there will be supplied later by ad- 
jacent instances of either the second x_0 clause or 
ob l  (14-15). The latter is the version of concatena- 
tion used for specifying obligatory, i.e. nonalternat- 
ing positions, which consequently are specified as 
unmarked. Alltogether these means yield fully spec- 
ified strings w.r.t, markedness information. We will 
see below how this simplifies an implementation of
the IOP. 
As can be seen in the accessor elation i s  (17), 
phonological segments are actually embedded un- 
der a further feature seg. This treatment enables 
structure-sharing of segments independent of their 
syllable roles. 
The syllable shape constraint (18-25) shows first 
of all that syllable roles are modelled as O,pes under 
self. 
15 
18 shape := 
19 ( se l f : (nuc leus  & seg:vowel)  & 
20 le f t : se l f :onset  
21 ; se l f : ( -nuc leus)  & 
22 ( se l f :onset  & left :sel f :  (-onset) 
23 ; se l f : coda  & le f t : se l f : ( -coda)  
24 ) 
25 ). 
26 
27 const ra in ts  := sy l lab i fy  & shape. 
Lines (19-20) capture the fact that syllable nuclei 
in MH are always vowels and that every syllable 
nucleus is preceded by an onset. In (21-22) a non- 
nuclear position that is an onset may only license 
preceding non-onsets, thus disallowing complex on- 
sets; similarly for codas in (23). In (27) genetic 
sy l lab i fy  is intersected with shape, since seg- 
mental positions must be prosodified and conform 
to language-specific shape restrictions. 
The constraints under (28-30), included for com- 
pleteness, merely ensure proper termination of seg- 
mental strings at the word periphery. 
28 word 
29 end 
30 
:= se l f : ( '+ in i '  & prom:up  & onset).  
:= le f t : se l f : ( '+ f in '  & -onset) & 
se l f : ' - f in '  
Prosodic prespecification (31-36) faithfully models 
what was stated in prose in section 2. 
31 prosod ic_prespec i f i ca t ion  := 
32 (cat : ( (b2&( - (past ;p res ) ) ) ;b3 ;b4)  & 
33 se l f :onset  
34 ; 
35 cat : (~( (b2& ( - (past ;pres) ) ) ;b3;b4) )  
36 ). 
We proceed in (37-41) with a rudimentary definition 
of first (v l )  and second (v2) stem vowel which is 
sufficient for our toy fragment. 
37 vl := is(low) & cat : (past  & bl ;b7).  
38 vl := i s ( round & '-hi') & 
39 cat : (b l  & ~ past).  
40 v2 := is( low).  
41 v2 := i s ( f ront  & '-hi'). 
The larger grammar mentioned above contains a full 
binary decision tree for each vowel. Still, even here 
one can see the use of type formulae like round & 
' -h i '  to classify segments phonologically. 
Next come a number of exemplary inflectional af- 
fixes (42-79), again simplified. The zero affixes (42- 
45, 47-54) are phonologically just like the zero alter- 
nant in (10) in taking up no segmental space. 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
% init ia l  "0" prefix 
'#'(More) := More  & se l f : '+ in i '  & 
cat: ( -  fut & - in f in i t i ve  & 
( bl ; (~ pres & (b3 ; b4)) 
% f inal "0" suf f ix  
'#'(More) := More  & 
sel f : ' - in i '  & le f t : se l f : '+f in '  & 
( cat : (sg  & masc & th i rd  & past) & 
le f t : le f t : i s ( - f ront )  
; cat : (sg  & masc & th i rd  & pres) & 
le f t : le f t : i s ( f ront )  
). 
% overt prefix 
j i (More) := se l f : '+in i '  & 
ob l ( i s ( i ) ,ob l ( i s ( i ) ,  More)) & 
cat : ( fut  & th i rd  & ((sg&masc) 
(bl ; b2)). 
)). 
; pl) & 
The segmental content of all other affixes is spec- 
ified via possibly repeated instances of obl ,  since 
affixes are nonalternating. Apart from the respective 
categotial information, positional type information 
' + in i ' ,  ' + f in '  ensures that prefixes and suffixes 
are properly restricted to wordinitial and wordfinal 
position. Note that the glide-initialji- prefix specifies 
an initial/i/(58) which will be prosodified as onset  
by means of syllabify. This representational as- 
sumption is in line with other recent work in phono- 
logical theory which standardly analyzes glides as 
nonsyllabic high vowels. Hence, even in MH we 
have a case where segmental classes and prosodic 
rolesdon't align perfectly. 
To control second stem vowel apophony, some 
suffixes demand (53,73) or forbid (51) front vowels 
two positions to their left. 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
u(More) := ob l ( i s (u )&se l f : '+ f in ' ,More)& 
le f t : le f t : i s ( -  (vowel & -front)) & 
cat : (p l  & ( (past & third) 
; (fut & - first) )). 
a (More) :=ob l ( i s (a )&se l f : '+ f in ' ,More)& 
le f t : le f t : i s ( -  (vowel & -front)) & 
cat : ( (past  & th i rd  & sg & fem) 
; (pres & sg & fem & b5)).  
et(More) := 
ob l ( i s (e ) ,ob l ( i s ( t )&se l f : '+ f in ' ,More) )&  
le f t : le f t : i s ( f ront )  & 
cat:(pres & sg & fem & -b5). 
im(More) := 
ob l ( i s ( i ) ,ob l ( i s (m)&se l f : '+ f in ' ,More) )&  
le f t : le f t : i s ( -  (vowel & -front)) & 
cat:(pres & pl & masc). 
16 
Others posit the weaker demand vowel -+ front 
(62,67,78), thus not forbidding consonantal fillings 
of the position adressed by le f t  : l e f t .  
The stem definition (80-82) for a regular triliteral 
is parametrized for the three root segments and the 
inflectional Su f f ixes  to follow. 
80 stem(el, C2, C3, Suffixes) := 
81 obl(is(Cl),x O(vl,obl(is(C2), 
82 x_0(v2,obl(is(C3), Suffixes))))). 
83 
84 affixes(Stem, '#'(end)) := '#'(Stem). 
85 affixes(Stem, a(end)) := '#'(Stem). 
86 affixes(Stem, et(end)) := '#'(Stem). 
87 affixes(Stem, im(end)) := '#'(Stem). 
88 affixes(Stem, u(end)) := yi(Stem). 
89 
90 verbform(\[Cl & consonant,C2 & consonant, 
91 C3 & consonant\], Category) := 
92 root_letter_tree(\[Cl,C2,C3\]) & word & 
93 affixes( prosodic_prespecification & 
94 stem(Cl,C2,C3, Suffixes), 
95 Suffixes) & cat:Category. 
Given the informal description i  section 2, the suc- 
cession of obligatory root and altel"nating stem vowel 
positions now looks familiar. It should be obvi- 
ous how to devise analogous tem definitions for 
quadriliterals (e.g. mixfev) and cluster verbs (e.g. 
flirtet). 
A rather simple tabulation of a f f i xes  lists 
(a subset of) the allowable prefix-suffix cooccur- 
rences in the MH verbal paradigm (84-88) be- 
fore everything is put together in the defini- 
tion for verbform, parametrized for a list of 
root segments and Category  (90-95). Note how 
prosod ic_prespec i  f ca t ion  is intersected with 
stem in (93-94), exploiting the power of the descrip- 
tion level to restrict stem realizations without diacrit- 
ical marking of stem vs affix domains on the object 
level. The subgoal root_ le t te r_ t ree  (92) will be 
discussed below. 
When proving a goal like verb form(  \[g, m, r \ ] ,  
bl&third&pl&fut), the MicroCUF interpreter 
will enumerate he set of all candidate result feature 
structures, including one that describes the gram- 
matical surface string jigmeru. An implementation 
of the IOP, to be described next, must therefore 
complement the setup established sofar to exclude 
the suboptimal candidates. While the subtle inter- 
twining of zero alternant preference and constraint 
solving described above has its theoretical merits, a 
much simpler practical solution was devised. In a 
first step, the small finite set of all candidate solu- 
tions for a goal is collected, together with numerical 
'disharmony' values representing each candidate's 
degree of optimality. Disharmony is defined as the 
binary number that results from application of the 
mapping {unmarked ~ 012, marked  ~ 102} to 
the left-to-right markedness vector of a segmental 
string: e.g., jolioxgolal0moxroluol yields the dishar- 
mony value 010101100101012 = 552510 > 54771o = 
010101011001012 from joli01golmoleloroluol. Step 
two is a straightforward search for the candidate(s) 
with minimal disharmony. 
4 Parsing and generation 
The preceding paragraph described how to com- 
pute surface forms given roots and categories. How- 
ever, this generation procedure amounts to an ineffi- 
cient generate-and-minimize mechanism which must 
compute otherwise useless uboptimal candidates as 
a byproduct of optimization. More importantly, due 
to the nonmonotonicity of optimization it is not obvi- 
ous how to invert the procedure for efficient parsing 
in order to derive root and category given a surface 
form. 
A first solution which comes to mind is to im- 
plement parsing as analysis-by-synthesis. A goal 
like ParseSt r ing&verb form (Root, Category)  
is submitted to a first run of the MicroCUF con- 
straint solver, resulting in instantiations for Root 
and Category  iff a proof consistent with the 
grammar was found. With these instantiations, a 
second run of MicroCUF uses the full generate- 
and-minimize mechanism to compute optimal 
strings OptSt r ing l  . . . . .  OptStr ingN.  The parse 
is accepted iff ParseSt r ing&(OptSt r ing l ;  
. . .  ;OptSt r ingN)  is  consistent. Note that for this 
solution to be feasible it is essential that constraints 
are inviolable, hence their evaluation in the first run 
can disregard optimization. The main drawbacks of 
analysis-by-synthesis are that two runs are required 
and that the inefficiencies of generate-and-minimize 
are not avoided. 
The new solution recognizes the fact that bidi- 
rectional processing of DPM would be easy with- 
out optimization. We therefore seek to perform all 
optimization at compile time. The idea is this: ex- 
ploiting the finiteness of natural language paradigms 
we compute - using generate-and-minimize - each 
paradigm cell of e.g. the verbal paradigm of MH for 
a suitable root. However, while doing so we record 
the proof sequence of relational clause invocations 
employed in the derivation of each optimal form, us- 
ing the fact that each clause has a unique index in 
internal representation. Such proof sequences have 
17 
two noteworthy properties. By definition they first 
of all record just clause applications, therefore nat- 
urally abstracting over all non-relational parameter 
fillings of top-level goals. In particular, proving a 
goal like verb form ( \ [g ,  m, r \ ]  , b l  ; b2  ) normally 
looses the information associated with the root and 
category parameters in the proof sequence represen- 
tation (although these parameters could indirectly in- 
fluence the proof if relationally encoded choices in 
the grammar were dependent on it). Secondly, we 
can profitably view each proof sequence as a linear 
finite state automaton (FSAc~u). Since a paradigm 
is the union of all its cells, a complete abstract 
paradigm can therefore be represented by a unique 
? minimal deterministic FSAp=r~ which is computed 
as the union of all FSAcett followed by determiniza- 
tion and minimization. At runtime we just need to 
run FSAp~,.~ as afinite-state oracle in parallel with 
the MicroCUF constraint solver. This means that 
each proof step that uses a clause k must be sanc- 
tioned by a corresponding k-labelled FSA transition. 
With this technique we are now able to efficiently re- 
strict the search space to just the optimal proofs; the 
need for run-time optimization in DPM processing 
has been removed. However, a slight caveat is nec- 
essary: to apply the technique it must be possible to 
partition the data set into a finite number of equiv- 
alence classes. This condition is e.g. automatically 
fulfilled for all phenomena which exhibit a paradigm 
structure. 
What are the possible advantages of this hybrid 
FSA-guided constraint processing technique? First 
of all, it enables a particularly simple treatment of 
ttnkaowtl words for root-and-pattern morphologies, 
surely a necessity in the face of ever-incomplete 
lexicons. If the grammar is set up properly to ab- 
stract from segmental detail of the Root segments 
as much as possible, then these details are also ab- 
sent in the proof sequences. Hence a single FSApara 
merging these sequences in effect represents an ab- 
stract paradigm which can be used for a large number 
of concrete instantiations. We thus have a principled 
way of parsing words that contain roots not listed 
in the lexicon. However, we want the system not to 
overgenerate, mistakenly analyzing known roots as 
unknown. Rather, the system should return the se- 
mantics of known roots and also respect their verbal 
class affiliations as well as other idiosyncratic prop- 
erties. This is the purpose of the root_ le t te r_ t ree  
clauses in (96-123). 
96 
97 
98 
99 
i00 
I01 
102 
103 
104 
105 
106 
107 
108 
109 
ii0 
i i i  
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
root_ le t te r_ t ree( \ [g lRest \ ] )  := 
root_ le t te r_ t ree_g(Rest ) .  
root_ le t te r_ t ree( \ [ -g l _ \ ] )  := 
cat : sem: 'UNKNOWN' .  
root_ le t te r_ t ree  g ( \ [m\ [Rest \ ] )  := 
root_ le t te r_ t ree_gm(Rest ) .  
root_ le t te r_ t ree  g ( \ [d \ [Rest \ ] )  := 
root_ le t te r_ t ree_gd(Rest ) .  
root_ le t te r_ t ree  g ( \ [ -m&~dI_ \ ] )  := 
cat : sem: 'UNKNOWN' .  
root_ le t te r_ t ree  gm(\[r \ ] )  := 
cat: (bl & sem: 'F IN ISH '  
; b2 & sem: 'BE  F IN ISHED' ) .  
root_ le t te r_ t ree  gm( \ [ - r l _ \ ] )  := 
cat :sem: 'UNKNOWN' . 
root_ le t te r_ t ree_gd(  \[r\] ) := 
cat: ( bl  & sem: 'ENCLOSE '  
; b2 & sem: 'BE ENCLOSED'  
; b3 & sem: 'FENCE IN' 
; b4 & sem: 'BE FENCED IN' 
; b5 & sem: 'DEF INE '  
; b6 & sem: 'BE DEFINED'  
; b7 & sem: 'EXCEL' 
). 
root_ le t te r_ t ree_gd(  \[-rl_\] ) := 
cat :sem: 'UNKNOWN' . 
For each level in the letter tree a new terminal 
branch is added that covers the complement of all at- 
tested root segments at that level (99,106,112,123). 
This terminal branch is assigned an 'UNKNOWN' se- 
mantics, whereas known terminal branches record 
a proper semantics and categorial restrictions. Dur- 
ing off-line creation of the proof sequences we now 
simply let the system backtrack over all choices in 
the root_letter_tree by feeding it a totally un- 
derspecified Root parameter. The resulting FSApar= 
represents both the derivations of all known roots 
and of all possible unknown root types covered by 
the grammar. While this treatment results in a ho- 
mogenous grammar integrating lexical and gram- 
matical aspects, it considerably enlarges FSApara. It 
might herefore be worthwhile to separate l xical ac- 
cess from the grammar, unning a separate proof of 
root_ le t te r_ t ree  (Root )  to enforce root-specific 
restrictions after parsing with the abstract paradigm 
alone. It remains to be seen which approach is more 
promising w.r.t, overall space and time efficiency. 
A second advantage of separating FSA guidance 
from constraint processing, as compared to pure 
finite-state transducer approaches, i  that we are free 
to build sufficient expressivity into the constraint lan- 
guage. For example it seems that one needs token 
identity, i.e. structure sharing, in phonology to cover 
18 
instances of antigemination, assimilation, dissimila- 
tion and reduplication i  an insightful way. It is well- 
known that token identity is not finite-state repre- 
sentable and cumbersome toemulate in practice (cf. 
Antworth 1990, 157 on a FST attempt at reduplica- 
tion vs the DPM treatment of infixal reduplication 
in Tigrinya verbs described in Walther 1997, 238- 
247). Also, it would be fascinating to extend the 
constraint-based approach to phonetics. However, a 
pilot study reported in Walther & Krrger (1994) has 
found it necessary to use arithmetic onstraints to 
do so, again transcending finite-state power. Finally, 
to the extent hat sign-based approaches togrammar 
like HPSG are on the right track, the smooth integra- 
tion of phonology and morphology arguably is bet- 
ter achieved within a uniform formal basis such as 
MicroCUF which is expressive enough to cover the 
recursive aspects of syntax and semantics as well. 
In conclusion, some notes on the pilot implemen- 
tation. The MicroCUF system was modified to pro- 
duce two new incarnations of the MicroCUF inter- 
preter, one to record proof sequences, the other to 
perform FSA-guided proofs. FSApara was created 
with the help of finite-state ools from AT&T's freely 
availablefsm package (h t tp :  //www. research .  
ar t .  com /sw / too ls  / fsm/) . Ihavemeasured 
speedups of more than 102 for the generation of MH 
forms (< l second with the new technique), although 
parse times in the range of 1 . . .  4 seconds on a Pen- 
tium 200 MHz PC with 64 M_Byte indicate that the 
current prototype is still too slow by a factor of more 
than l02. However, there is ample room for future 
improvements. Besides drawing from the wealth of 
optimizations found in the logic programming liter- 
ature to generally accelerate MicroCUF (e.g., term 
encoding of feature structures, memoization) we can 
also analyze the internal structure of FSAvara to gain 
some specific advantages. This is due to the fact that 
each maximal linear sub-FSA of length k > i corre- 
sponds to a deterministic proof subsequence whose 
clauses should be partially executable at compile 
time, subsequently saving k - 1 proof steps at run- 
time. 
5 Conclusion 
This paper has described a computational, declara- 
tive approach to prosodic morphology which uses 
inviolable constraints formulated in a sufficiently ex- 
pressive formalism (here: MicroCUF) together with 
a restrictive incremental optimization component. 
The approach as been illustrated by implementing 
an a-templatic analysis of a fragment of Modern He- 
brew verbs. The full grammar behind the illustrative 
fragment covers additional detail such as antigem- 
ination effects (noded-im, *nod d-im 'they (masc.) 
wander'), spirantization, B7 sibilant metathesis, etc. 
Also, the formalization of X/~ presented here is 
actually a special case of the more powerful no- 
tion of resequencing, whose application to Tigrinya 
vowel coalescence and metathesis was demonstrated 
in Walther (1997). 
Despite the initial emphasis on incremental op- 
timization, a compilation technique was later pro- 
posed to remove the need for run-time optimiza- 
tion and guarantee fully bidirectional processing of 
prosodic morphology. Although the general idea of 
using a finite-state oracle to guide a parser has 
been previously proposed for context-free grammars 
(Johnson 1996), both the details of our implemen- 
tation of the idea and its specific application to 
prosodic morphology are believed to be novel. It was 
emphasized how the proposed technique aided in a 
simple treatment of unknown words. Note that un- 
known words are not normally integrated into finite- 
state transducer models of prosodic morphology, al- 
though the necessary extensions appear to be pos- 
sible (K. Beesley, p.c.). Finally, the fact that a hy- 
brid setup rather than a pure finite-state approach 
was chosen has been motivated inter alia by refer- 
ence to additional phenomena such as antigemina- 
tion and reduplication that require the richer notion 
of token identity. Future research will especially fo- 
cus on detailed analyses of reduplication phenomena 
to secure the relevance of the present approach to 
prosodic morphology at large. 
References 
Antworth, E. (1990). PC-KIMMO: A Two-Level Pro- 
cessor for Morphological Analysis. Dallas: SIL. 
Bat-El, O. (1989). Phonology and Word Structure in 
Modern Hebrew. Ph.D. thesis, UCLA. 
Beesley, K. R. (1996). Arabic Finite-State Morpholog- 
ical Analysis and Generation. In: Proceedings of 
COLING-96, vol. I, 89-94. 
Bird, S. (1995). ComputationalPhonology. Cambridge 
University Press. 
Bird, S. & E. Klein (1990). Phonological events. Jour- 
nal of Linguistics 26, 33-56. 
Chomsky, N. (1965). Aspects of the Theory of Syntax. 
Cambridge, MA: MIT Press. 
Drrre, J. & M. Dorna (1993). CUF - A Formalism for 
Linguistic Knowledge Representation. I : J. Drrre 
(Ed.), Computational Aspects of Constraint-Based 
Linguistic Description. IMS, Universit/it Stuttgart. 
19 
Deliverable R1.2.A, DYANA-2 - ESPRIT Basic 
Research Project 6852. 
Ellison, T. M. (1994). Phonological Derivation in Op- 
timality Theory. In: Proceedings of COLING '94, 
vol. II, 1007-1013. (ROA-75, CMP-LG 9504021). 
Ellison, T. M. (1995). OT, Finite-State Representations 
and Procedurality. In: Proceedings of the Confer- 
ence on Formal Grammar, Barcelona. 
Eilison, T. M. (to appear). The Universal Constraint 
Set: Convention, ot Fact. In: J. Dekkers, E van der 
Leeuw & J. van de Weijer (Ed.), Conceptual Stud- 
ies in Optimality Theory. Oxford University Press. 
Gafos, A. (1995). On the Proper Characterization of 
'Nonconcatenative' Languages. Ms., Department 
of Cognitive Science, The Johns Hopkins Univer- 
sity, Baltimore. (ROA-106). 
Glinert, L. (1989). The grammar of Modern Hebrew. 
Cambridge University Press. 
Hudson, G. (1986). Arabic root and pattern morphol- 
ogy without iers. Journal of Linguistics 22, 85- 
122. 
Johnson, M. (1996). Left Corner Transforms and Fi- 
nite State Approximations. Tech report ML'Iq'-026, 
Rank Xerox Research Centre, Grenoble. 
Kahn, D. (1976). Syllable-Based Generalizations in 
English Phonology. Bloomington: Indiana Univer- 
sity Linguistics Club. (= MIT Ph.D. dissertation). 
Karttunen, L. (1998). The Proper Treatment of Opti- 
mality in Computational Phonology. In: Proceed- 
ings of FSMNLP'98. International Workshop on 
Finite-State Methods in Natural Language Pro- 
cessing, Bilkent University, Ankara, 1-12. 
Kiraz, G. A. (1996). Computing Prosodic Morphology. 
In: Proceedings of COLING '96, vol. II, 664.-669. 
Kisseberth, C. (1970). On the functional unity of 
phonological rules. Linguistic Inquio' 1, 291-306. 
McCarthy, J. (1979). Formal Problems in Semitic 
Phonology and Morphology. Ph.D. thesis, MIT. 
McCarthy, J. & A. Prince (1993). Prosodic Morphol- 
ogy I: Constraint Interaction and Satisfaction. Tech 
report RuCCS-TR-3, Rutgers University Center 
for Cognitive Science. 
Prince, A. & P. Smolensky (1993). Optimality The- 
ory. Constraint Interaction in Generative Gram- 
mar. Tech report RuCCS-TR-2, Rutgers University 
Center for Cognitive Science. 
Riehemann, S. (1993). Word Formation in Lexical 
Type Hierarchies: A Case Study of bar-Adjectives 
in German. Master's thesis, Universit~it Tiibingen. 
(also: SfS-Report-02-93, Seminar f'tir Sprachwis- 
senschaft, Universit~it Tiibingen). 
Scobbie, J. M. (1991). Towards Declarative Phonol- 
ogy. In: S. Bird (Ed.), Declarative Perspectives on 
Phonology, vol. 7 of Edinburgh Working Papers in 
Cognitive Science, 1-26. Centre for Cognitive Sci- 
ence, University of Edinburgh. 
20 
Selkirk, E. (1982). The syllable. In: H. van der Hulst 
& N. Smith (Ed.), The structure of phonological 
representations, vol. II, 337-383. Dordrecht: Foris. 
Sproat, R. (1992). Morphology and Computation. 
Cambridge, Mass.: MIT Press. 
Walther, M. (1993). Declarative Syllabification with 
Applications to German. In: T. M. Ellison & J. M. 
Scobbie (Ed.), ComputationalPhonology, vol. 8 of 
Edinburgh Working Papers in Cognitive Science, 
55-79. Centre for Cognitive Science, University of 
Edinburgh. 
Walther, M. (1995). A Strictly Lexicalized Approach to 
Phonology. In: J. Kilbury & R. Wiese (Ed.), Pro- 
ceedings of DGfS/CL'95, 108-113. Diisseldorf: 
Deutsche Gesellschaft f'tir Sprachwissenschaft, 
Sektion Computerlinguistik. 
Walther, M. (1997). Deklarative prosodische Mor- 
phologie - constraintbasierte Analysen und Com- 
putermodelle zum Finnischen und Tigrinya. Ph.D. 
thesis, Philosophische Fakultfit der Heinrich- 
Heine-Universit~it D .isseldorf. 
Walther, M. & B. Kr6ger (1994). Phonologie- 
Phonetik-Kopplung in einem constraintbasierten 
gesturalen Modell. In: H. Trost (Ed.), Tagungs- 
band KONVENS '94, Nummer 6 in Infor- 
matik Xpress, 387-396. Wien: Osterreichische 
Gesellschaft fiir Artificial Intelligence. 
