Human Language Technologies: The 2009 Annual Conference of the North American Chapter of the ACL, pages 65?73,
Boulder, Colorado, June 2009. c?2009 Association for Computational Linguistics
Improved Reconstruction of Protolanguage Word Forms
Alexandre Bouchard-Co?te?? Thomas L. Griffiths? Dan Klein?
?Computer Science Division ?Department of Psychology
University of California at Berkeley
Berkeley, CA 94720
Abstract
We present an unsupervised approach to re-
constructing ancient word forms. The present
work addresses three limitations of previous
work. First, previous work focused on faith-
fulness features, which model changes be-
tween successive languages. We add marked-
ness features, which model well-formedness
within each language. Second, we introduce
universal features, which support generaliza-
tions across languages. Finally, we increase
the number of languages to which these meth-
ods can be applied by an order of magni-
tude by using improved inference methods.
Experiments on the reconstruction of Proto-
Oceanic, Proto-Malayo-Javanic, and Classical
Latin show substantial reductions in error rate,
giving the best results to date.
1 Introduction
A central problem in diachronic linguistics is the re-
construction of ancient languages from their modern
descendants (Campbell, 1998). Here, we consider
the problem of reconstructing phonological forms,
given a known linguistic phylogeny and known cog-
nate groups. For example, Figure 1 (a) shows a col-
lection of word forms in several Oceanic languages,
all meaning to cry. The ancestral form in this case
has been presumed to be /taNis/ in Blust (1993). We
are interested in models which take as input many
such word tuples, each representing a cognate group,
along with a language tree, and induce word forms
for hidden ancestral languages.
The traditional approach to this problem has been
the comparative method, in which reconstructions
are done manually using assumptions about the rel-
ative probability of different kinds of sound change
(Hock, 1986). There has been work attempting to
automate part (Durham and Rogers, 1969; Eastlack,
1977; Lowe and Mazaudon, 1994; Covington, 1998;
Kondrak, 2002) or all of the process (Oakes, 2000;
Bouchard-Co?te? et al, 2008). However, previous au-
tomated methods have been unable to leverage three
important ideas a linguist would employ. We ad-
dress these omissions here, resulting in a more pow-
erful method for automatically reconstructing an-
cient protolanguages.
First, linguists triangulate reconstructions from
many languages, while past work has been lim-
ited to small numbers of languages. For example,
Oakes (2000) used four languages to reconstruct
Proto-Malayo-Javanic (PMJ) and Bouchard-Co?te? et
al. (2008) used two languages to reconstruct Clas-
sical Latin (La). We revisit these small datasets
and show that our method significantly outperforms
these previous systems. However, we also show that
our method can be applied to a much larger data
set (Greenhill et al, 2008), reconstructing Proto-
Oceanic (POc) from 64 modern languages. In ad-
dition, performance improves with more languages,
which was not the case for previous methods.
Second, linguists exploit knowledge of phonolog-
ical universals. For example, small changes in vowel
height or consonant place are more likely than large
changes, and much more likely than change to ar-
bitrarily different phonemes. In a statistical system,
one could imagine either manually encoding or auto-
matically inferring such preferences. We show that
both strategies are effective.
Finally, linguists consider not only how languages
change, but also how they are internally consistent.
Past models described how sounds do (or, more of-
ten, do not) change between nodes in the tree. To
borrow broad terminology from the Optimality The-
ory literature (Prince and Smolensky, 1993), such
models incorporated faithfulness features, captur-
ing the ways in which successive forms remained
similar to one another. However, each language
has certain regular phonotactic patterns which con-
65
strain these changes. We encode such patterns us-
ing markedness features, characterizing the internal
phonotactic structure of each language. Faithfulness
and markedness play roles analogous to the channel
and language models of a noisy-channel system. We
show that markedness features improve reconstruc-
tion, and can be used efficiently.
2 Related work
Our focus in this section is on describing the prop-
erties of the two previous systems for reconstruct-
ing ancient word forms to which we compare our
method. Citations for other related work, such as
similar approaches to using faithfulness and marked-
ness features, appear in the body of the paper.
In Oakes (2000), the word forms in a given pro-
tolanguage are reconstructed using a Viterbi multi-
alignment between a small number of its descendant
languages. The alignment is computed using hand-
set parameters. Deterministic rules characterizing
changes between pairs of observed languages are ex-
tracted from the alignment when their frequency is
higher than a threshold, and a proto-phoneme inven-
tory is built using linguistically motivated rules and
parsimony. A reconstruction of each observed word
is first proposed independently for each language. If
at least two reconstructions agree, a majority vote
is taken, otherwise no reconstruction is proposed.
This approach has several limitations. First, it is not
tractable for larger trees, since the time complexity
of their multi-alignment algorithm grows exponen-
tially in the number of languages. Second, deter-
ministic rules, while elegant in theory, are not robust
to noise: even in experiments with only four daugh-
ter languages, a large fraction of the words could not
be reconstructed.
In Bouchard-Co?te? et al (2008), a stochastic model
of sound change is used and reconstructions are in-
ferred by performing probabilistic inference over an
evolutionary tree expressing the relationships be-
tween languages. The model does not support gener-
alizations across languages, and has no way to cap-
ture phonotactic regularities within languages. As a
consequence, the resulting method does not scale to
large phylogenies. The work we present here ad-
dresses both of these issues, with a richer model
and faster inference allowing improved reconstruc-
tion and increased scale.
3 Model
We start this section by introducing some notation.
Let ? be a tree of languages, such as the examples
in Figure 3 (c-e). In such a tree, the modern lan-
guages, whose word forms will be observed, are the
leaves of ? . All internal nodes, particularly the root,
are languages whose word forms are not observed.
Let L denote all languages, modern and otherwise.
All word forms are assumed to be strings ?? in the
International Phonological Alphabet (IPA).1
We assume that word forms evolve along the
branches of the tree ? . However, it is not the case
that each cognate set exists in each modern lan-
guage. Formally, we assume there to be a known
list of C cognate sets. For each c ? {1, . . . , C}
let L(c) denote the subset of modern languages that
have a word form in the c-th cognate set. For each
set c ? {1, . . . , C} and each language ` ? L(c), we
denote the modern word form by wc`. For cognate
set c, only the minimal subtree ?(c) containing L(c)
and the root is relevant to the reconstruction infer-
ence problem for that set.
From a high-level perspective, the generative pro-
cess is quite simple. Let c be the index of the cur-
rent cognate set, with topology ?(c). First, a word
is generated for the root of ?(c) using an (initially
unknown) root language model (distribution over
strings). The other nodes of the tree are drawn incre-
mentally as follows: for each edge ` ? `? in ?(c) use
a branch-specific distribution over changes in strings
to generate the word at node `?.
In the remainder of this section, we clarify the ex-
act form of the conditional distributions over string
changes, the distribution over strings at the root, and
the parameterization of this process.
3.1 Markedness and Faithfulness
In Optimality Theory (OT) (Prince and Smolensky,
1993), two types of constraints influence the selec-
tion of a realized output given an input form: faith-
fulness andmarkedness constraints. Faithfulness en-
1The choice of a phonemic representation is motivated by
the fact that most of the data available comes in this form. Dia-
critics are available in a smaller number of languages and may
vary across dialects, so we discarded them in this work.
66
t a
a
?
n g
i
i
s
#
#
#
#
a
?
n
g
/angi/
/a?i/
/ta?i/
/angi/
/a?i/
/ta?i/
?
S
?
I
x
1
x
2
x
3
x
7
y
1
y
2
y
3
y
7
x
4
y
4
y
5
y
6
x
5
x
6
?
n
g
1[Insert]
1[Subst]
1[(n g)@Kw]
1[??g@Kw]
1[??g]
1[(n)@Kw]
1[(g)@Kw]
Language Word form
Proto Oceanic /taNis/
Lau /aNi/
Kwara?ae /angi/
Taiof /taNis/
Table 1: A cognate set from the Austronesian dataset. All
word forms mean to cry.
constrain these changes. We encode such patterns
using markedness features, characterizing the inter-
nal phonotactic structure of each language. Faith-
fulness and marked ess play roles analogous to the
channel and language models of a noisy-channel
system. We show that markedness features greatly
improve reconstruction quality, and we show how to
work with them efficiently.
2 Related Work
Our focus in this section is on describing the prop-
erties of the two previous systems for reconstruct-
ing ancient word forms to which we compare our
method. Citations for other related work, such as
similar approaches to using faithfulness and marked-
ness features, appear in the body of the paper.
In Oakes (2000), the word forms in a given proto-
language are reconstructed using a Viterbi multi-
alignment between a small number of its descendant
languages. The alignment is computed using hand-
set parameters. Deterministic rules characterizing
changes between pairs of observed languages are ex-
tracted from the alignment when their frequency is
higher than a threshold, and a proto-phoneme inven-
tory is built using linguistically motivated rules and
parsimony. A reconstruction of each observed word
is first proposed independently for each language. If
at least two reconstructions agree, a majority vote
is taken, otherwise no reconstruction is proposed.
This approach has several limitations. First, it is
not tractable for larger trees since the complexity of
the multi-alignment algorithm grows exponentially
in the number of languages. Second, determinis-
tic rules, while elegant in theory, are not robust to
noise: even in experiments with only four daughter
languages, a large fraction of the words could not be
reconstructed.
In Bouchard-Co?te? et al (2008), a stochastic model
of sound change is used and reconstructions are in-
ferred by performing probabilistic inference over an
evolutionary tree expressing the relationships be-
tween languages. Use of approximate inference and
stochastic rules addresses some of the limitations of
(Oakes, 2000), but the resulting method is computa-
tionally demanding and consequently does not scale
to large phylogenies. The high computational cost
of probabilistic inference also limits the features that
can be included in the model (omitting global fea-
tures supporting generalizations across languages,
and markedness features within languages). The
work we present here addresses both of these issues,
with faster inference and a richer model allowing in-
creased scale and improved reconstruction.
3 Model
We start this section by introducing some notation.
Let ? be a tree of languages, such as the examples in
Figure 4 (c-e). In such a tree, the modern languages,
whose word forms will be observed, are the leaves
"1 . . . "m. All internal nodes, particularly the root,
are languages " whose word forms are not observed.
Let L denote all languages, modern and otherwise.
All word forms are assumed to be strings ?? in the
International Phonological Alphabet (IPA).1
As a first approximation, we assume that word
forms evolve along the branches of the tree ? . How-
ever, it is not the case that each cognate set exists
in each modern langugage. Formally, we assume
there to be a known list of C cognate sets. For each
c ? {1, . . . , C} let L(c) denote the subset of mod-
ern languages that have a word form in the c-th cog-
nate set. For each set c ? {1, . . . , C} and each lan-
guage " ? L(c), we denote the modern word form
by wc!. For cognate set c, only the minimal subtree
?(c) containing L(c) and the root is relevant to the
reconstruction inference problem for that set.
From a high-level perspective, the generative pro-
cess is quite simple. Let c be the index of the cur-
rent cognate set, with topology ?(c). First, a word
is generated for the root of ?(c) using an (initially
unknown) root language model (distribution over
strings). The other nodes of the tree are drawn in-
crementally as follows: for each edge " ? "? in ?(c)
1The choice of a phonemic representation is motivated by
the fact that most of the data available comes in this form. Dia-
critics are available in a smaller number of languages and may
vary across dialects, so we discarted them in this work.
(a) (b)
(f)
(c)
(d)(e)
..
?
Figure 1: (a) A cognate set from the Austronesian dataset.
All word orms mean to cry. (b-d) The mutation model
used in this paper. (b) The mutation of POc /taNis/ to
Kw. /angi/. (c) Graphical model depicting the dependen-
cie among variables in one step of the mutation Markov
chain. (d) Active features for one step in this process.
(e-f) Comparison of two inference procedures on trees:
Single sequence resampling (e) draws one sequence at a
time, conditio ed on its parent and children, while ances-
try resampling (f) draws an aligned slice from all words
simultaneously. In large trees, the latter is ore efficien
than the former.
courages similarity between the input and output
while markedness favors well-formed output.
Viewed from this perspective, previous comput -
tional approaches to reconstruction are based almost
xclusively n faithf lnes , ex r ssed thr ug a mu-
tation model. Only the words in the language at the
root of the tree, if any, are explicitly encouraged to
be w ll-formed. In ontrast, we incorporate con-
straints on markedness for each language with both
general and branc -specific constraints on faithful-
ness. This is done using a lexicalized stochastic
string transducer (Varadarajan et al, 2008).
We now make precise the conditional distribu-
tions over pairs of evolving strings, referring to Fig-
ure 1 (b-d). Consider a language `? evolving to `
for cognate set c. Assume we have a word form
x = wcl? . The generative process for producing
y = wcl works as follows. First, we consider
x to be composed of characters x1x2 . . . xn, with
the first and last being a special boundary symbol
x1 = # ? ? which is never deleted, mutated, or
created. The process generates y = y1y2 . . . yn in
n chunks yi ? ??, i ? {1, . . . , n}, one for each xi.
The yi?s may be a single character, multiple charac-
ters, or even empty. In the example shown, all three
of these cases occur.
T generat yi, we define a mutation Markov
chain that incrementally adds zero or more charac-
ters to an initially empty yi. First, we decide whether
the current phoneme in the top word t = xi will be
deleted, in which case yi =  as in the example of
/s/ being deleted. If t is not deleted, we chose a sin-
gle substitution character in the bottom word. This
is the case both when /a/ is unchanged and when /N/
substitutes to /n/. We writeS = ??{?} for this set
of outcomes, where ? is the special outcome indi-
cating deletion. Importantly, the probabilities of this
multinomial can depend on both the previous char-
acter gen rated so far (i.e. the rightmost character
p of yi?1) and the current character in the previous
generation string (t). As we will see shortly, this al-
lows modelling markedness and faithfulness at every
branch, jointly. This multinomial decision acts as
the initial distribution of the mutation Markov chain.
We consider insertions only if a deletion was not
selected in the first step. Here, we draw from a
multinomial overS , where this time the special out-
come ? corresponds to stopping insertions, and the
other elements ofS correspond to symbols that are
appende to yi. In this case, the conditioning envi-
ronment is t = xi and the current rightmost symbol
p in yi. Insertions continue until ? is selected. In
the example, w follow the substitution of /N/ to /n/
with an insertion of /g/, followed by a decision to
stop that yi. We will use ?S,t,p,` and ?I,t,p,` to denote
the probabilities ver the substitution and insertion
decisions in the current branch `? ? `.
A similar process generates the word at the root
` of a tree, treating this word as a single string
y1 generated from a dummy ancestor t = x1. In
this case, only the insertion probabilities matter, and
we separately parameterize these probabilities with
?R,t,p,`. There is no actual dependence on t at the
root, but this formulation allows us to unify the pa-
rameterization, with each ??,t,p,` ? R|?|+1 where
? ? {R,S, I}.
3.2 Parameterization
Instead of directly estimating the transition proba-
bilities of the mutation Markov chain (as the param-
eters of a collection of multinomial distributions) we
67
express them as the output of a log-linear model. We
used the following feature templates:
OPERATION identifies whether an operation in the
mutation Markov chain is an insertion, a deletion,
a substitution, a self-substitution (i.e. of the form
x ? y, x = y), or the end of an insertion event.
Examples in Figure 1 (d): 1[Subst] and 1[Insert].
MARKEDNESS consists of language-specific n-
gram indicator functions for all symbols in ?. Only
unigram and bigram features are used for computa-
tional reasons, but we show in Section 5 that this
already captures important constraints. Examples in
Figure 1 (d): the bigram indicator 1[(n g)@Kw] (Kw
stands for Kwara?ae, a language of the Solomon
Islands), the unigram indicators 1[(n)@Kw] and
1[(g)@Kw].
FAITHFULNESS consists of indicators for muta-
tion events of the form 1[x ? y], where x ? ?,
y ? S . Examples: 1[N ? n], 1[N ? n@Kw].
Feature templates similar to these can be found
for instance in Dreyer et al (2008) and Chen (2003),
in the context of string-to-string transduction. Note
also the connection with stochastic OT (Goldwater
and Johnson, 2003; Wilson, 2006), where a log-
linear model mediates markedness and faithfulness
of the production of an output form from an under-
lying input form.
3.3 Parameter sharing
Data sparsity is a significant challenge in protolan-
guage reconstruction. While the experiments we
present here use an order of magnitude more lan-
guages than previous computational approaches, the
increase in observed data also brings with it addi-
tional unknowns in the form of intermediate pro-
tolanguages. Since there is one set of parameters
for each language, adding more data is not sufficient
for increasing the quality of the reconstruction: we
show in Section 5.2 that adding extra languages can
actually hurt reconstruction using previous methods.
It is therefore important to share parameters across
different branches in the tree in order to benefit from
having observations from more languages.
As an example of useful parameter sharing, con-
sider the faithfulness features 1[/p/ ? /b/] and
1[/p/ ? /r/], which are indicator functions for the
appearance of two substitutions for /p/. We would
like the model to learn that the former event (a sim-
ple voicing change) should be preferred over the lat-
ter. In Bouchard-Co?te? et al (2008), this has to be
learned for each branch in the tree. The difficulty is
that not all branches will have enough information
to learn this preference, meaning that we need to de-
fine the model in such a way that it can generalize
across languages.
We used the following technique to address this
problem: we augment the sufficient statistics of
Bouchard-Co?te? et al (2008) to include the current
language (or language at the bottom of the current
branch) and use a single, global weight vector in-
stead of a set of branch-specific weights. Gener-
alization across branches is then achieved by using
features that ignore `, while branch-specific features
depend on `.
For instance, in Figure 1 (d), 1[N ? n] is
an example of a universal (global) feature shared
across all branches while 1[N ? n@Kw] is branch-
specific. Similarly, all of the features in OPERA-
TION, MARKEDNESS and FAITHFULNESS have uni-
versal and branch-specific versions.
3.4 Objective function
Concretely, the transition probabilities of the muta-
tion and root generation are given by:
??,t,p,`(?) = exp{??, f(?, t, p, `, ?)?}Z(?, t, p, `, ?) ? ?(?, t, ?),
where ? ? S , f : {S, I,R}?????L?S ? Rk
is the sufficient statistics or feature function, ??, ??
denotes inner product and ? ? Rk is a weight vector.
Here, k is the dimensionality of the feature space of
the log-linear model. In the terminology of exponen-
tial families, Z and ? are the normalization function
and reference measure respectively:
Z(?, t, p, `, ?) = ?
???S
exp{??, f(?, t, p, `, ??)?}
?(?, t, ?) =
?
???
???
0 if ? = S, t = #, ? 6= #
0 if ? = R, ? = ?
0 if ? 6= R, ? = #
1 o.w.
Here, ? is used to handle boundary conditions.
We will also need the following notation: let
P?(?),P?(?|?) denote the root and branch probabil-ity models described in Section 3.1 (with transition
probabilities given by the above log-linear model),
I(c), the set of internal (non-leaf) nodes in ?(c),
pa(`), the parent of language `, r(c), the root of ?(c)
68
and W (c) = (??)|I(c)|. We can summarize our ob-
jective function as follows:
CX
c=1
log
X
~w?W (c)
P?(wc,r(c))
Y
`?I(c)
P?(wc,`|wc,pa(`)) ? ||?||
2
2
2?2
The second term is a standard L2 regularization
penalty (we used ?2 = 1).
4 Learning algorithm
Learning is done using a Monte Carlo variant of the
Expectation-Maximization (EM) algorithm (Demp-
ster et al, 1977). The M step is convex and com-
puted using L-BFGS (Liu et al, 1989); but the E
step is intractable (Lunter et al, 2003), so we used
a Markov chain Monte Carlo (MCMC) approxima-
tion (Tierney, 1994). At E step t = 1, 2, . . . , we
simulated the chain for O(t) iterations; this regime
is necessary for convergence (Jank, 2005).
In the E step, the inference problem is to com-
pute an expectation under the posterior over strings
in a protolanguage given observed word forms at the
leaves of the tree. The typical approach in biology
or historical linguistics (Holmes and Bruno, 2001;
Bouchard-Co?te? et al, 2008) is to use Gibbs sam-
pling, where the entire string at a single node in the
tree is sampled, conditioned on its parent and chil-
dren. This sampling domain is shown in Figure 1 (e),
where the middle word is completely resampled but
adjacent words are fixed. We will call this method
Single Sequence Resampling (SSR). While concep-
tually simple, this approach suffers from problems
in large trees (Holmes and Bruno, 2001). Con-
sequently, we use a different MCMC procedure,
called Ancestry Resampling (AR) that alleviates
the mixing problems (Figure 1 (f)). This method
was originally introduced for biological applications
(Bouchard-Co?te? et al, 2009), but commonalities be-
tween the biological and linguistic cases make it
possible to use it in our model.
Concretely, the problem with SSR arises when the
tree under consideration is large or unbalanced. In
this case, it can take a long time for information
from the observed languages to propagate to the root
of the tree. Indeed, samples at the root will ini-
tially be independent of the observations. AR ad-
dresses this problem by resampling one thin vertical
slice of all sequences at a time, called an ancestry.
For the precise definition, see Bouchard-Co?te? et al
(2009). Slices condition on observed data, avoiding
the problems mentioned above, and can propagate
information rapidly across the tree.
5 Experiments
We performed a comprehensive set of experiments
to test the new method for reconstruction outlined
above. In Section 5.1, we analyze in isolation the
effects of varying the set of features, the number of
observed languages, the topology, and the number
of iterations of EM. In Section 5.2 we compare per-
formance to an oracle and to three other systems.
Evaluation of all methods was done by computing
the Levenshtein distance (Levenshtein, 1966) be-
tween the reconstruction produced by each method
and the reconstruction produced by linguists. We
averaged this distance across reconstructed words to
report a single number for each method. We show
in Table 2 the average word length in each corpus;
note that the Latin average is much larger, giving
an explanation to the higher errors in the Romance
dataset. The statistical significance of all perfor-
mance differences are assessed using a paired t-test
with significance level of 0.05.
5.1 Evaluating system performance
We used the Austronesian Basic Vocabulary
Database (Greenhill et al, 2008) as the basis for
a series of experiments used to evaluate the per-
formance of our system and the factors relevant to
its success. The database includes partial cognacy
judgments and IPA transcriptions, as well as a few
reconstructed protolanguages. A reconstruction of
Proto-Oceanic (POc) originally developed by Blust
(1993) using the comparative method was the basis
for evaluation.
We used the cognate information provided in
the database, automatically constructing a global
tree2 and set of subtrees from the cognate set in-
dicator matrix M(`, c) = 1[` ? L(c)], c ?
{1, . . . , C}, ` ? L. For constructing the global tree,
we used the implementation of neighbor joining in
the Phylip package (Felsenstein, 1989). We used
a distance based on cognates overlap, dc(`1, `2) =?C
c=1 M(`1, c)M(`2, c). We bootstrapped 1000
2The dataset included a tree, but it was out of date as of
November 2008 (Greenhill et al, 2008).
69
NggelaBugotuTapeAvavaNeveeiNamanNeseSantaAnaNahavaqNatiKwaraaeSol
LauKwameraToloMarshalles
PuloAnnaChuukeseAK
SaipanCaro
Puluwatese
WoleaianPuloAnnan
Carolinian
WoleaiChuukeseNaunaPaameseSou
AnutaVaeakauTau
TakuuTokelauTonganSamoanIfiraMeleM
TikopiaTuvaluNiueFutunaEast
UveaEastRennellese
EmaeKapingamar
SikaianaNukuoroLuangiuaHawaiianMarquesan
TahitianthRurutuanMaoriTuamotuMangareva
Rarotongan
PenrhynRapanuiEas
PukapukaMwotlapMotaFijianBauNamakirNgunaArakiSouth
SaaRagaPeteraraMa
ItEsPtSndJvMadMal POc LaPMJ
Figure 3: Phylogenetic trees for three language families.Clockwise, from the top left: Romance, Austronesian andProto-Malayo-Javanic.
formance of our system and the factors relevant toits success. The database contained, as of Novem-ber 2008, 124,468 lexical items from 587 languagesmostly from the Austronesian language family. Thedatabase includes partial cognacy judgments andIPA transcriptions, as well as a few reconstructedproto-languages. A reconstruction of Proto Oceanic(POc) originally developed by (Blust, 1993) usingthe comparative method was the basis for evaluation.We used the cognate information provided in thedatabase, automatically constructing a global tree2and set of subtrees from the cognate set indicatormatrix M(!, c) = 1[! ? L(c)], c ? {1, . . . , C}, ! ?
L. For constructing the global tree, we used theimplementation of neighbor joining in the Phylippackage (Felsenstein, 1989). The distance ma-trix used the Hamming distance of cognate indi-cators, dc(!1, !2) = ?Cc=1 M(!1, c)M(!2, c). Webootstrapped 1000 samples and formed an accurate(90%) consensus tree. The tree obtained is not bi-nary, but the AR inference algorithm scales linearlyin the branching factor of the tree (in contrast, SSRscales exponentially (Lunter et al, 2003)).The first claim we verified experimentally is thathaving more observed languages aids reconstructionof proto-languages. To test this hypothesis we addedobserved modern languages in increasing order ofdistance dc to the target reconstruction of POc sothat the languages that are most useful for POc re-construction are added first. This prevents the ef-fects of adding a close language after several distant
2The dataset included a tree, but as of November 2008, itwas generated automatically and ?has [not] been updated in awhile.?
0 10 20 30 40 50 60 701.4
1.6
1.8
2
2.2
2.4
2.6
Number of modern languages
Error
Figure 4: Mean distance to the target reconstruction ofproto Oceanic as a function of the number of modern lan-guages used by the inference procedure.
ones being confused with an improvement producedby increasing the number of languages.The results are reported in Figure 4. They con-firm that large-scale inference is desirable for auto-matic proto-language reconstruction: going from 2-to-4, 4-to-8, 8-to-16, 16-to-32 languages all signifi-cantly helped reconstruction. There was still an av-erage edit distance improvement of 0.05 from 32 to64 languages, altough this was not statistically sig-nificant.We then conducted a number of experiments in-tended to assess the robustness of the system, and toidentify the contribution made by different factors itincorporates. First, we ran the system with 20 dif-ferent random seeds and assessed the stability of thesolution found. In each cases, learning was stableand helded performances. See Figure 5.Next, we found that all of the following ablationssignificantly hurts reconstruction: using a flat treein which all languages are equidistant from the re-constructed root and from each other instead of theconsensus tree, dropping the markedness features,disabling sharing across branches and dropping thefaithfulness features. The results of these experi-ments are shown in Table 2.For comparison, we also included in the sametable the performance of a semi-supervised systemtrained by K-fold validation. The system was ran
K time, with disjoint 1 ? K?1 of the POc. wordsgiven to the system (as observations in the graph-
Condition Edit dist.Unsupervised full system 1.87-FAITHFULNESS 2.02-MARKEDNESS 2.18-Sharing 1.99-Topology 2.06Semi-supervised system 1.75
Table 2: Effects of ablation of various aspects of ourunsupervised system on mean edit distance to protoOceanic. -Sharing corresponds to the subset of the fea-tures in OPERATION, FAITHFULNESS and MARKEDNESSthat condition on the current language, -Topolo y corre-sponds to using a flat topology where the only edges inthe tree connect modern languages to proto Oc anic. Thesemi-supervised system i described in text. All dif-ferences (compared to the unsupervised full system) arestatistically significant.
ical model) fo each run. It is semi-supervised inthe sense that gold reconstruction for many internalnodes are not avail bl (such as th common ances-tor of Kw. nd Lau in Fi re 6).3
Figure 6 shows the results of a concrete run over32 languages, zooming in to a pair of the Solomoniclanguages and the cognate set from Table 1. In theexample shown, the reconstruction is as good as theoracle, though off by one character (the final /s/ isnot resent in any of the 32 inputs and thereforeis not reconstructed). The diagrams show, for boththe global and the local features, the expectationsof each substitution superimposed on an IPA soundch rt, as well as a list of the top changes. Darkerlines indicate higher counts. T is run did not usen tural class constraints, but it can be seen that lin-guistically plausibl substitutions are learned. Theglobal features prefer a range of voic ng changes,manner changes, adjace t vowel motion, and so on,including mu ations like /s/ to /h/ which are commonbut poorly repre ented in a naive attribute-based nat-ural class scheme. On the other hand, the features l -cal to the lang ag Kwara?a (Kw.) pick out the sub-set of these change which are active in that branch,such as /s/?/t/ fortition.
3We also tried a fully supervised system where a flat topol-ogy is used so that all of these latent internal nodes are avoided;but it did not perform as well.
0 2 4 6 8 10 12 14 16 18 201.8
2
2.2
2.4
2.6
2.8
3
3.2
3.4
3.6
EM Iteration
Error
Figure 5: Mean distance to the target reconstruction ofPOc as a function of the EM iteration.
5.2 Comparisons against other methods
The first two competing methods, PRAGUE and
BCLKG, are described in Oakes (2000) andBouchard-Co?te? et al (2008) respectively and sum-marized them in Section 1. Neither approach scaleswell to large datasets. In the first case, the bottleneckis the complexity of computing multi-alignmentswithout guide trees and the vanishing probabilitythat independent reconstructions agree. In the sec-ond case, the problem comes from slow mixing ofthe inference algorithm and the unregularized pro-liferation of parameters. For this reason, we built athird baseline that scales well in large datasets.This third baseline, CENTROID, computes thecentroid of the observed word forms in Leven-shtein distance. Let L(x, y) denote the Lev-enshtein distance between word forms x and
y. Ideally, we would like the baseline toreturn argminx????y?O L(x, y), where O ={y1, . . . , y|O|} is the set of observed word forms.Note that the optimum is not changed if we restrictthe minimization to be taken on x ? ?(O)? suchthat m ? |x| ? M where m = mini |yi|,M =maxi |yi| and?(O) is the set of characters occurringin O. Even with this restriction, this optimizationis intractable. As an approximation, we consideredonly strings built by at most k contiguous substringstaken from the word forms in O. If k = 1, then itis equivalent to taking the min over x ? O. At theother end of the spectrum, if k = M , it is exact.This scheme is exponential in k, but since words arerelatively short, we found that k = 2 often finds the
E
r
r
o
r
N. of m d rn lang. EM iteration
100 20300 60
1.4
1.8
2.2
2.6
1.8
2.4
3
3.6
Figure 2: Left: Mean distance to the target reconstruction
of POc as a function of the number of modern languages
used by the inference procedure. Right: Mean distance
and confidenc intervals as a function of th EM it ration,
averag d over 20 random seeds an ran on 4 languages.
samples nd forme a accurate (90%) consen us
tre . The tree obtained is o binary, but the AR
infer ce algorithm scales lin arly in the branching
factor of the tree (in contrast, SSR scale exp nen-
tially (Lunter et al, 2003)).
T e first laim we ver fied experimentally is that
having more observed languages aids reconstruction
of protolanguages. To t t this hypothesis we added
observed mod rn l nguage in increasing order of
distance dc to the target reconstruction of POc so
that the languages that are most useful for POc re-
construction are added first. This prevents the ef-
fects of adding a close language after several distant
ones being confused with an improvement produced
by increasing the number of languages.
The results are reported in Figure 2 (a). They con-
firm that large-scale inference is desirable for au-
tomatic protolanguage reconstruction: reconstruc-
tion improved statistically significantly with each in-
crease except from 32 to 64 languages, where the
average edit distance improvement was 0.05.
We then conducted a number of experiments in-
tended to assess the robustness of the system, and to
identify the contribution made by different factors it
incorporates. First, we ran the system with 20 dif-
ferent random seeds to assess the stability of the so-
lutions found. In each case, learning was stable and
accuracy improved during training. See Figure 2 (b).
Next, we found that all of the following ablations
significantly hurt reconstruction: using a flat tree (in
which all languages are equidistant from the recon-
structed root and from each other) instead of the con-
sensus tree, dropping the markedness features, drop-
Condition Edit dist.
Unsupervised full system 1.87
-FAITHFULNESS 2.02
-MARKEDNESS 2.18
-Sharing 1.99
-Topology 2.06
Semi-supervised system 1.75
Table 1: Effects of ablation of various aspects of our
unsupervised system on mean edit distance to POc.
-Sharing corresponds to the restriction to the subset of the
features in OPERATION, FAITHFULNESS and MARKED-
NESS that are branch-specific, -Topology corresponds to
using a flat topology where the only edges in the tree con-
nect modern languages to POc. The semi-supervised sys-
tem is described in the text. All differences (compared to
the unsupervised full system) are statistically significant.
ping the faithfulness features, and disabling sharing
across branches. The results of these experiments
are shown in Table 1.
For comparison, we also included in the same
table the performance of a semi-supervised system
trained by K-fold validation. The system was ran
K = 5 times, with 1?K?1 of the POc words given
to the system as observations in the graphical model
for each run. It is semi-supervised in the sense that
gold reconstruction for many internal nodes are not
available in the dataset (for example the common an-
cestor of Kwara?ae (Kw.) and Lau in Figure 3 (b)),
so they are still not filled.3
Figure 3 (b) shows the results of a concrete run
over 32 languages, zooming in to a pair of the
Solomonic languages and the cognate set from Fig-
ure 1 (a). In the example shown, the reconstruc-
tion is as good as the ORACLE (described in Sec-
tion 5.2), though off by one character (the final /s/
is not present in any of the 32 inputs and therefore
is not reconstructed). In (a), diagrams show, for
both the global and the local (Kwara?ae) features,
the expectations of each substitution superimposed
on an IPA sound chart, as well as a list of the top
changes. Darker lines indicate higher counts. This
run did not use natural class constraints, but it can
3We also tried a fully supervised system where a flat topol-
ogy is used so that all of these latent internal nodes are avoided;
but it did not perform as well?this is consistent with the
-Topology experiment of Table 1.
70
be seen that linguistically plausible substitutions are
learned. The global features prefer a range of voic-
ing changes, manner changes, adjacent vowel mo-
tion, and so on, including mutations like /s/ to /h/
which are common but poorly represented in a naive
attribute-based natural class scheme. On the other
hand, the features local to the language Kwara?ae
pick out the subset of these changes which are ac-
tive in that branch, such as /s/?/t/ fortition.
5.2 Comparisons against other methods
The first two competing methods, PRAGUE and
BCLKG, are described in Oakes (2000) and
Bouchard-Co?te? et al (2008) respectively and sum-
marized in Section 1. Neither approach scales well
to large datasets. In the first case, the bottleneck is
the complexity of computing multi-alignments with-
out guide trees and the vanishing probability that in-
dependent reconstructions agree. In the second case,
the problem comes from the unregularized prolifera-
tion of parameters and slow mixing of the inference
algorithm. For this reason, we built a third baseline
that scales well in large datasets.
This third baseline, CENTROID, computes the
centroid of the observed word forms in Leven-
shtein distance. Let L(x, y) denote the Lev-
enshtein distance between word forms x and
y. Ideally, we would like the baseline to
return argminx???
?
y?O L(x, y), where O =
{y1, . . . , y|O|} is the set of observed word forms.
Note that the optimum is not changed if we restrict
the minimization to be taken on x ? ?(O)? such
that m ? |x| ? M where m = mini |yi|,M =
maxi |yi| and ?(O) is the set of characters occurring
in O. Even with this restriction, this optimization
is intractable. As an approximation, we considered
only strings built by at most k contiguous substrings
taken from the word forms in O. If k = 1, then it
is equivalent to taking the min over x ? O. At the
other end of the spectrum, if k = M , it is exact.
This scheme is exponential in k, but since words are
relatively short, we found that k = 2 often finds the
same solution as higher values of k. The difference
was in all the cases not statistically significant, so we
report the approximation k = 2 in what follows.
We also compared against an oracle, denoted OR-
ACLE, which returns argminy?OL(y, x?), where x?
is the target reconstruction. We will denote it by OR-
Comparison CENTROID PRAGUE BCLKG
Protolanguage POc PMJ La
Heldout (prop.) 243 (1.0) 79 (1.0) 293 (0.5)
Modern languages 70 4 2
Cognate sets 1321 179 583
Observed words 10783 470 1463
Mean word length 4.5 5.0 7.4
Table 2: Experimental setup: number of held-out proto-
word from (absolute and relative), of modern languages,
cognate sets and total observed words. The split for
BCLKG is the same as in Bouchard-Co?te? et al (2008).
ACLE. This is superior to picking a single closest
language to be used for all word forms, but it is pos-
sible for systems to perform better than the oracle
since it has to return one of the observed word forms.
We performed the comparison against Oakes
(2000) and Bouchard-Co?te? et al (2008) on the same
dataset and experimental conditions as those used in
the respective papers (see Table 2). Note that the
setup of Bouchard-Co?te? et al (2008) provides super-
vision (half of the Latin word forms are provided);
all of the other comparisons are performed in a com-
pletely unsupervised manner.
The PMJ dataset was compiled by Nothofer
(1975), who also reconstructed the corresponding
protolanguage. Since PRAGUE is not guaranteed to
return a reconstruction for each cognate set, only 55
word forms could be directly compared to our sys-
tem. We restricted comparison to this subset of the
data. This favors PRAGUE since the system only pro-
poses a reconstruction when it is certain. Still, our
system outperformed PRAGUE, with an average dis-
tance of 1.60 compared to 2.02 for PRAGUE. The
difference is marginally significant, p = 0.06, partly
due to the small number of word forms involved.
We also exceeded the performance of BCLKG on
the Romance dataset. Our system?s reconstruction
had an edit distance of 3.02 to the truth against 3.10
for BCLKG. However, this difference was not signifi-
cant (p = 0.15). We think this is because of the high
level of noise in the data (the Romance dataset is the
only dataset we consider that was automatically con-
structed rather than curated by linguists). A second
factor contributing to this small difference may be
that the the experimental setup of BCLKG used very
few languages, while the performance of our system
improves markedly with more languages.
71
Nggela
Bugotu
TapeAvava
Neveei
Naman
NeseSantaAna
Nahavaq
NatiKwaraaeSol
LauKwamera
ToloMarshalles
PuloAnna
ChuukeseAK
SaipanCaro
Puluwatese
Woleaian
PuloAnnan
Carolinian
Woleai
Chuukese
Nauna
PaameseSou
AnutaVaeakauTau
Takuu
Tokelau
Tongan
Samoan
IfiraMeleM
Tikopia
Tuvalu
NiueFutunaEast
UveaEast
Rennellese
EmaeKapingamar
Sikaiana
Nukuoro
Luangiua
Hawaiian
Marquesan
Tahitianth
Rurutuan
Maori
Tuamotu
Mangareva
Rarotongan
Penrhyn
RapanuiEas
Pukapuka
Mwotlap
MotaFijianBau
Namakir
Nguna
ArakiSouth
SaaRagaPeteraraMa
ItEsPtSndJvMadMal POc LaPMJ
/a?i/ (Lau)/angi/ (Kw.)
/a?i/
/ta?i/ (POc)
....
Universal
a ?? el ?? rs ?? hk ?? gr ?? l
Kwa
N ?? ng ?? ks ?? te ?? io ?? a
1
Universal
a ?? el ?? rs ?? hk ?? gr ?? l
Kwa
N ?? ng ?? ks ?? te io a
1
? ??
??
?
?
?
? ? ??
?
?
?
???
?
? ?
? ??
?
?
??
?
?
?
?
f
gdb c
n
?
m
j
k
hv
t
s
r
qp ?
z
?
? x
? ??
??
?
?
?
? ? ??
?
?
?
???
?
? ?
? ??
?
?
??
?
?
?
?
f
gdb c
n
?
m
j
k
hv
t
s
r
qp ?
z
?
? x
(a) (b) (c) (d) (e)
Figure 3: (a) A visualization of two learned faithfulness parameters: on the top, from the universal features, on
the bottom, for one particular branch. Each pair of phonemes have a link with grayscale value proportional to the
expectation of a transition between them. The five strongest links are also included at the right. (b) A sample taken
from our POc experiments (see text). (c-e) Phylogenetic trees for three language families: Proto-Malayo-Javanic,
Austronesian and Romance.
We conducted another experiment to verify this
by running both systems in larger trees. Because the
Romance dataset had only three modern languages
transcribed in IPA, we used the Austronesian dataset
to perform the test. The results were all significant in
this setup: while our method went from an edit dis-
tance of 2.01 to 1.79 in the 4-to-8 languages exper-
iment described in Section 5.1, BCLKG went from
3.30 to 3.38. This suggests that more languages can
actually hurt systems that do not support parameter
sharing.
Since we have shown evidence that PRAGUE and
BCLKG do not scale well to large datasets, we
also compared against ORACLE and CENTROID in a
large-scale setting. Specifically, we compare to the
experimental setup on 64 modern languages used to
reconstruct POc described before. Encouragingly,
while the system?s average distance (1.49) does not
attain that of the ORACLE (1.13), we significantly
outperform the CENTROID baseline (1.79).
5.3 Incorporating prior linguistic knowledge
The model also supports the addition of prior lin-
guistic knowledge. This takes the form of feature
templates with more internal structure. We per-
formed experiments with an additional feature tem-
plate:
STRUCT-FAITHFULNESS is a structured version of
FAITHFULNESS, replacing x and y with their natu-
ral classes N?(x) and N?(y) where ? indexes types
of classes, ranging over {manner, place, phonation,
isOral, isCentral, height, backness, roundedness}.
This feature set is reminiscent of the featurized rep-
resentation of Kondrak (2000).
We compared the performance of the system with
and without STRUCT-FAITHFULNESS to check if the
algorithm can recover the structure of natural classes
in an unsupervised fashion. We found that with
2 or 4 observed languages, FAITHFULNESS under-
performed STRUCT-FAITHFULNESS, but for larger
trees, the difference was not significant. FAITH-
FULNESS even slightly outperformed its structured
cousin with 16 observed languages.
6 Conclusion
By enriching our model to include important fea-
tures like markedness, and by scaling up to much
larger data sets than were previously possible, we
obtained substantial improvements in reconstruc-
tion quality, giving the best results on past data
sets. While many more complex phenomena are
still unmodeled, from reduplication to borrowing to
chained sound shifts, the current approach signifi-
cantly increases the power, accuracy, and efficiency
of automatic reconstruction.
Acknowledgments
We would like to thank Anna Rafferty and our re-
viewers for their comments. This work was sup-
ported by a NSERC fellowship to the first author and
NSF grant number BCS-0631518 to the second au-
thor.
72
References
R. Blust. 1993. Central and central-Eastern Malayo-
Polynesian. Oceanic Linguistics, 32:241?293.
A. Bouchard-Co?te?, P. Liang, D. Klein, and T. L. Griffiths.
2008. A probabilistic approach to language change. In
Advances in Neural Information Processing Systems
20.
A. Bouchard-Co?te?, M. I. Jordan, and D. Klein. 2009.
Efficient inference in phylogenetic InDel trees. In Ad-
vances in Neural Information Processing Systems 21.
L. Campbell. 1998. Historical Linguistics. The MIT
Press.
S. F. Chen. 2003. Conditional and joint models for
grapheme-to-phoneme conversion. In Proceedings of
Eurospeech.
M. A. Covington. 1998. Alignment of multiple lan-
guages for historical comparison. In Proceedings of
ACL 1998.
A. P. Dempster, N. M. Laird, and D. B. Rubin. 1977.
Maximum likelihood from incomplete data via the EM
algorithm. Journal of the Royal Statistical Society. Se-
ries B (Methodological), 39(1):1?38.
M. Dreyer, J. R. Smith, and J. Eisner. 2008. Latent-
variable modeling of string transductions with finite-
state methods. In Proceedings of EMNLP 2008.
S. P. Durham and D. E. Rogers. 1969. An application
of computer programming to the reconstruction of a
proto-language. In Proceedings of the 1969 confer-
ence on Computational linguistics.
C. L. Eastlack. 1977. Iberochange: A program to
simulate systematic sound change in Ibero-Romance.
Computers and the Humanities.
J. Felsenstein. 1989. PHYLIP - PHYLogeny Inference
Package (Version 3.2). Cladistics, 5:164?166.
S. Goldwater and M. Johnson. 2003. Learning OT
constraint rankings using a maximum entropy model.
Proceedings of the Workshop on Variation within Op-
timality Theory.
S. J. Greenhill, R. Blust, and R. D. Gray. 2008. The
Austronesian basic vocabulary database: From bioin-
formatics to lexomics. Evolutionary Bioinformatics,
4:271?283.
H. H. Hock. 1986. Principles of Historical Linguistics.
Walter de Gruyter.
I. Holmes and W. J. Bruno. 2001. Evolutionary HMM:
a Bayesian approach to multiple alignment. Bioinfor-
matics, 17:803?820.
W. Jank. 2005. Stochastic variants of EM: Monte Carlo,
quasi-Monte Carlo and more. In Proceedings of the
American Statistical Association.
G. Kondrak. 2000. A new algorithm for the alignment of
phonetic sequences. In Proceedings of NAACL 2000.
G. Kondrak. 2002. Algorithms for Language Recon-
struction. Ph.D. thesis, University of Toronto.
V. I. Levenshtein. 1966. Binary codes capable of correct-
ing deletions, insertions and reversals. Soviet Physics
Doklady, 10, February.
D. C. Liu, J. Nocedal, and C. Dong. 1989. On the limited
memory BFGS method for large scale optimization.
Mathematical Programming, 45:503?528.
J. B. Lowe and M. Mazaudon. 1994. The reconstruction
engine: a computer implementation of the comparative
method. Comput. Linguist., 20(3):381?417.
G. A. Lunter, I. Miklo?s, Y. S. Song, and J. Hein. 2003.
An efficient algorithm for statistical multiple align-
ment on arbitrary phylogenetic trees. Journal of Com-
putational Biology, 10:869?889.
B. Nothofer. 1975. The reconstruction of Proto-Malayo-
Javanic. M. Nijhoff.
M. P. Oakes. 2000. Computer estimation of vocabu-
lary in a protolanguage from word lists in four daugh-
ter languages. Journal of Quantitative Linguistics,
7(3):233?244.
A. Prince and P. Smolensky. 1993. Optimality theory:
Constraint interaction in generative grammar. Techni-
cal Report 2, Rutgers University Center for Cognitive
Science.
L. Tierney. 1994. Markov chains for exploring posterior
distributions. The Annals of Statistics, 22(4):1701?
1728.
A. Varadarajan, R. K. Bradley, and I. H. Holmes. 2008.
Tools for simulating evolution of aligned genomic re-
gions with integrated parameter estimation. Genome
Biology, 9:R147.
C. Wilson. 2006. Learning phonology with substantive
bias: An experimental and computational study of ve-
lar palatalization. Cognitive Science, 30.5:945?982.
73
