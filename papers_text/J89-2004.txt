Technical Correspondence On the Logic of Category Definitions 
ON THE LOGIC OF CATEGORY DEFINITIONS 
In their paper on category structures, Gazdar et al 
(1988) define a constraint language L c for categories and 
a logic A c of admissible category structures. ~ The 
intuitive idea is that for a constraint $ expressed in L c, 
~b is a nontrivial constraint if and only if A c 14 th; and it 
is a satisfiable constraint if and only if Ac 14 -nth. From a 
practical point of view it is therefore important to know 
whether A c is decidable and even better that the deci- 
sion can be given in a time bounded by a recursive 
function on the length of ~b. However, the remarks made 
in their paper only suffice to show that the modal 
fragment of Ac 2 contains S4.Grz = K(l-lp --> p, C\]p --* 
DDp, \[~(D(p --* Dp) --* p) --~ p), which does not show 
that this fragment is decidable. In this note, I will 
establish both that the modal fragment of A c and A c 
itself are decidable, and I will prove it in that order. As 
a result, I will also axiomatize Ac. Thus I show first that 
the modal reduct of Ac, which I call AM, is decidable. 
This paper will be rather hardgoing for anyone not 
acquainted with modal logic. We advise the reader to 
have Gazdar et al (1988) at hand while reading this 
paper, or better still, to read it once through before- 
hand. For the modal logics we refer the reader to Boolos 
(1979), Harel (1984), and Segerberg (1971), but in prin- 
ciple any introduction to modal logic will provide 
enough background to be able to understand the gist of 
the arguments. 
Without going into too many details of the construc- 
tion, I will show that there is an easy way to give a proof 
that in fact shows that A M = S4.Grz using the structure 
of the models those logics admit. Intuitively, categories 
correspond to Kripke models. For let a be a category. 
Then a defines a set of categories W, which is obtained 
by successively applying type 13 features to a. An 
accessibility relation <1 is defined via ot <1/3 ifff la) =/3 
for some type 1 feature f. This accessibility relation is 
irreflexive, intransitive, finite, and defines a tree-struc- 
ture on W. Most importantly, it is cycle free. Thus, if we 
look at the reflexive and transitive closure <\]+ of <1, it is 
again finite and has no non-trivial cycles. It therefore is 
an S4.Grz structure (see, e.g., Boolos 1979). Con- 
versely, an S4.Grz structure <W, <\]+> which is a tree 
can be represented as a category. If we then take a 
model <W, <1 +, val> based on that frame, where 
val: X--~ 2 w maps a finite set of propositional variables 
into 2 w, we can code this model by adding a type 0 
featurefp for each p ~ X that takes values Y or ?. Thus 
the resulting category t~ not only codes the successor 
function by means of type I features, but also the 
valuation val. W is in one-to-one correspondence ~b with 
the set F of categories generated by a. We then make 
the following definitions: 
Let/3 be in F: 
i./3 ~ fp : T i f f  ~/3) E val(p) iff ~/3) ~ p 
ii. \[3 ~ fp : ? iff qb(/3) ~ val(p) iff ~/3) ~ -p  
It is easy to see that for any modal formula P with 
variables in X, the corresponding translation ~" induced 
by p *-~ fp : T satisfies/3 ~ "t(P) iff q~(/3) ~ P. The logic 
of <W,<\]+> therefore coincides with the logic of all 
categories that differ from ot only in the assignment of 
type 0 features. To conclude, the logic of categories as 
defined in Gazdar et al (1988) coincides with the logic 
of all finite, reflexive, transitive trees. It is easily seen 
that the finite, reflexive, transitive trees generate the 
class of finite models for S4.Grz. Thus the logic of 
categories is the logic of the finite models of S4.Grz 
which, since S4.Grz has the finite model property, is 
identical to S4.Grz (end ofproojO. 
A few remarks are in order: 
I. I used a purely semantical argument, which in this 
case is the most direct way, because it is fairly 
easy to see why we get just the models we get, 
though there is some footwork to be done. 
2. Alternatively I could have built a canonical model 
out of a category structure X, whose worlds are 
the categories that X admits and whose accessibil- 
ity relation is as defined above for categories. The 
proof is essentially the same. 
3. The idea of encoding frames and valuations into a 
single structure has also been explored in Fagin 
(1985). 
4. In Rautenberg (1983) a simple tableau calculus for 
S4.Grz is given which shows that S4.Grz consis- 
tency is effectively decidable, and that the deci- 
sion procedure is primitive recursive. Further- 
more, the size of a tableau is bounded by a 
function of the number o~P) of subformulas of P, 
or, more precisely, the theoremhood of P can be 
decided with a tableau of length -< 27+60(P). Given 
the proof, the same holds for A M , since the 
translation procedure reduces the size of a for- 
mula. So we have the same bound for A c. 
5. In Gazdar et al (1988) another logic is mentioned 
which arises from restricting the number of type 1 
features to 1. The resulting logic is equal to 
S4.3.Grz = S4.Grz(<>p/X ~q. ~ .~(p/X Oq) X/ 
O(q/X O p) X/ O(p /X q)), the logic of all finite 
linear orders, as can be seen in the same way. 
Since finitely generated S4.3.Grz models are fi- 
nite, this logic is decidable as well. 
I will now proceed to the full case. Before I embark on 
the proof, let me remark on a few things. First, although 
each particular category structure contains only a finite 
number of features and values, L c contains infinitely 
many of them. As regards the type 0 features, this 
causes no problem, since we t reat f  : a as a proposition 
and we allow ourselves infinitely many of those. How- 
ever, type 1 features will create some problems that are 
not very serious but have to be dealt with carefully. 
Second, as we defined a translation of L c into modal 
logic, we will now define a translation of L c into 
elementary propositional dynamic logic (EPDL) so that 
every type 1 feature has a program associated with it 
Computational Linguistics, Volume 15, Number 2, June 1989 0362-613X/89/010111-113-$03.00 111 
Technical Correspondence On the Logic of Category Definitions 
whose interpretation is an accessibility relation between 
categories. This translation is harmless and allows us to 
forget about type 0 features altogether. 
i. , ( f  : a) = P<f:a> where f i s  of type 0 
ii. "t~,. : ~b) = <7,.> ~b where f; is of type 1 
iii. \ [~b = \[a\]~b 
a is a program that by definition contains all other 
programs; that is, if two categories are related by 3"~, 
they are also related by a. However, although the 
intuition is that a is the reflexive and transitive closure 
of all the y;'s, this fact is not expressible in EPDL nor in 
L c because it requires a formula of infinite length. But, 
as it turns out, this is a harmless deficiency of our 
language. The translation of A c into EPDL will be 
called _. 
I will now give a full axiomatization of '_ =. As we saw 
earlier, the axioms governing the behaviour of \[a\] are 
exactly the axioms for S4.Grz, since \[a\] is the old 71. 
Similar reasoning will reveal that the \[3'~\] behave alike, 
and the corresponding logic is the logic otherwise 
known as K.AIt~, which stands for "only one alterna- 
tive". The accessibility relation for K.AI h allows a 
world to have at most one successor. Although it has 
more models, K.AIh is the logic of all irreflexive, linear 
and finite frames, which shows that it is the logic we are 
looking for. If we take all this together with the obser- 
vation that a includes 3"i, we get the following axioms 
for -=: 
Grz~ -= F\[a\](\[a\](~b ~ \[a\]~b)~ ~b)~ ~b 
Alto. v -= \[-<3,i > (~b /~ ~1) ~ (<3,/>(\])./\.<3,/>1\]t), i ~ to 
Mix -= F<3,/> tk ~ <a> th 
Note that -= is not finitely axiomatizable and so A c isn't 
either. Note also that if it weren't for the axiom(s) called 
Mix, life would be very easy for us now. Since the 
axioms for the various programs are independent, he 
finite model property for each of those programs indi- 
vidually would yield the finite model property for the 
whole logic by simple induction on the number of 
programs. Thus let us call the logic without Mix ,-e. 
Also, since we have a tableau calculus for S4.Grz and a 
tableau calculus for K.AIh, we have a calculus for -=e 
as well, simply by putting all tableau rules together. The 
tableau rule for 3'; would look as follows: from F; <yi > 
4~ step to F?; ~b, where F ? := {q~ I <3';> ~0 ~ F or \[3'~\]~0 
F}. I shall spare the reader an exact specification of 
the tableau rules and refer him to Rautenberg (1983) 
again. Note that the length of the tableaus for K.AIh is 
bounded by the size of ~b so that the actual size of the 
tableau is at most 2 ~?~'), where n is the length of ~b and 
o(th) the number of subformulas of ~b. This bound could 
be sharpened somewhat but we ignore this point. What 
I want to show is how the fact that -=e can be shown to 
have all those properties can be made to explain why -= 
must have those properties, too. What the reader should 
understand at this point is that tableaus are a way of 
systematically constructing a model for a formula (if it is 
consistent) and showing inconsistency by exhausting all 
possible choices, of which there are only finitely many. 
What I do now is boost up a model construction 
procedure for =e  to a model construction procedure for 
-=. This is done as follows: Suppose we want to con- 
struct a E-model for $. Since we do not know how to do 
this we construct a -=e-model instead. However, this 
model might be deficient by not respecting Mix. There- 
fore we add a finite set ~b # of instances of Mix which will 
ensure that Mix is respected for subformulas of ~b. The 
=e model can then safely be turned into an -= model. 
Let me therefore define the modal degree d of a 
formula. 
d(~b) = 0, if & is a propositional variable or constant 
d(-n&) = d(~b) 
d(ck /X ~) = max(d(qa),d($)) 
d(\[a\]&) = d(~b) + 1 
d(\[ 3'i\] q~) = d(~b) + 1 
Furthermore, let sf(&) be the set of subformulas of ~b. 
Then define 
~" = U  3"i \[ 7i occurs in 4, > Ua 
C +~ = ~';.C 
(~# = {\[?(~b)\](<3'i> ,)(-"~ <O~> X) I X ~ SAt\]))} 
Then we say that an _= tableau for & is simply an =e 
tableau for ~b;$ #. Let us see how &# makes everything 
right for us. The failure of -=e is to allow models for 
<7i  > 1\]1 /~ \[t~\]--'l~/. For suppose we build a simple =e 
tableau tbr 4, and we encounter a line F; <3";> q,A \[a\]-n4,. 
In the next step we get F; <7;> q,;\[a\]TqJ and then F?;qJ. 
But if we added ~b #, then F would necessarily contain a 
formula yielding <3,;> qJ---~ <a> qJ, which would close 
this branch of the tableau. Thus an =e tableau for ~b;~b # 
results in a model <W, <3, val> in which, though a is an 
independent program, for every subformula qJ of ~b, if 
s,val ~<3,;> ~0, then also s,val ~<a> q~. Thus it is 
easy to see that if we now reinterpret the a relation "~ 
as the reflexive, transitive closure of a and the 3'g, we get 
an -= model < W, <3, val> for ~b, which obviously is of 
the same size. Thus, if _e  has the finite model property, 
-= has the finite model property, and if the decision 
procedure for _e  is bounded a priori by a function on 
the length of ~b, the same holds for _=. Obviously, the 
bound is much higher than for -=o because of the 4, #, 
but this is the price we have to pay (end ofproojO. 
Given the above proof we can now change the 
tableau calculus for -= by redefining the rule for 3"i to the 
following: from F; <7/> ~b infer F?; FD;~b where F ? := 
{qJ \[ <y~> qJ E F or \[3';\]q, E F} and F D := {\[a\]~ \[ \[a\]~ 
F} O {~0 \[ \[a\]qJ ~ F}. The proof method I used for 
proving decidability for -= (Ac) from the decidability of 
=e  is explained in full detail in Kracht (1988). The same 
method applies to the case when we only allow a single 
type I feature, since it only requires the base logic--in 
112 Computational Linguistics, Volume 15, Number 2, June 1989 
Technical Correspondence On the Logic of Category Definitions 
this case S4.3.Grzuto have the finite model property. 
The resulting logic -=.3 can be (finitely) axiomatized as 
follows: 
Grz~ -=.3 F \[a\](\[a\](4>--, \[a\]4>)--~ 4>)~ 4> 
.3,~ ,=.3 F (<a> 4>.A.<a>O)--~ 
<a>( 4>A <a> O)V <a>( OA <a> 4>> 
V <a> (4> A ~) 
AItLv ,=.3 F <y~> 4>A <y~> @ ~ <y~> (4> A ~) 
Mix -=.3 F <y l> 4>---~ <a> 4> 
The model construction requires ome care since we do 
not have an unlimited resort of extra features, but it can 
be done in the same spirit. This shows decidability for 
,=.3 and hence for the corresponding logic mentioned in 
the paper. An alternative formulation of -=.3 could be 
given with the help of propositional dynamic logic using 
the star operator *. We would then simply have an 
axiom <y~'> 4> ~ <a> 4> that says nothing else, but 
that a is the reflexive and transitive closure of TI. This 
trick would also work if we restrict _ to any finite 
number of features. But the star does not gain us much 
for -= itself since we still could not express the fact that 
a is the reflexive and transitive closure of the yi's 
because we have infinitely many of them. 
Marcus Kracht H 
Mathemat isches  Inst itut 
FU  Berl in 
1000 Berl in 33, Germany 
ACKNOWLEDGMENTS 
This paper was written while I was at the Centre for Cognitive Science 
in Edinburgh. I wish to thank Jaap van der Does for encouraging me 
to write this proof down and for proofreading it. I also wish to thank 
G. Gazdar for remarks on an earlier version of the paper and an 
anonymous referee for further suggestions. 
REFERENCES 
Boolos, G. 1979 The Unprovability of Consistency. Cambridge Uni- 
versity Press, Cambridge, England. 
Fagin, R. and Vardi, M. 1985 An Internal Semantics for Modal 
Logics: Preliminary Report, CSLI-Report No. 85-25. 
Gazdar, G.; Pullum, G.; Carpenter, R.; Klein, E.H.; Hukari, T.E.; 
and Levine, R.D. 1988 Category Structures, Computational Lin- 
guistics 14.1: 1-19. 
Harel, D. 1984 Dynamic Logic. in Gabbay, D. and Guenthner, F. 
(eds.) Handbook of Philosophical Logic. Reidel, Dordecht, Hol- 
land. 
Kracht, M. 1988 Splittings and the Finite Model Property (forth- 
coming). 
Rautenberg, W. 1983 Modal Tableau Calculi and Interpolation, in 
Journal of Philosophical Logic 12: 403-423. 
Segerberg, K. 1971 An Essay in Classical Modal Logic. Uppsala. 
NOTES 
1. Unfortunately, they do not distinguish between the language Lc 
and the logic, which defines a subset of that language, namely the 
set of its theorems. We make this distinction here by calling the 
logic as well as the set of theorems it defines A c. 
2. We define a logic as a set of rules, which are pairs A&b, where A 
is the set of premises of that rule and ~b its consequence. Modus 
Ponens thus takes the form ~b,~b ~ ~/~. Rules are closed under 
substitution. Axioms are rules because we can take A = 0. The 
modal fragment of A c is then simply the subpart of rules that only 
involve modal formulas, i.e. no type 1 features. 
3. Remember that type 1 features take propositions as values, 
whereas type 0 features only take atoms. 
Computational Linguistics, Volume 15, Number 2, June 1989 
m 
113 
