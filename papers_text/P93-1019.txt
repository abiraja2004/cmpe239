FEATURE-BASED ALLOMORPHY*  
Hans-U l r i ch  Kr ieger  Hannes  P i rker  
German Research Center  for 
Artif icial Intel l igence (DFK I )  
Stuh lsatzenhausweg 3 
W-66 Saarbr/ icken 11, Germany 
{krieger,pirker} @dfki.uni-sb.de 
John Nerbonne 
Alfa Informat ica,  P .O.Box  716 
Oude Ki jk in 't J a ts t raat  41 
Ri jksunivers i te i t  Groningen 
NL 9700 AS Groningen,  Hol land 
nerbonne@let . rug.n l  
Abst rac t  
Morphotactics and allomorphy are usually 
modeled in different components, leading to in- 
terface problems. To describe both uniformly, 
we define finite automata (FA) for allomorphy in 
the same feature description language used for 
morphotactics. Nonphonologically conditioned 
allomorphy is problematic in FA models but 
submits readily to treatment in a uniform for- 
malism. 
1 Background and  Goa ls  
ALLOMORPHY or MORPHOPHONEMICS describes 
the variation we find among the different forms 
of a morpheme. For instance, the German sec- 
ond person singular present ending -st has three 
different allomorphs, -st, -est, -t, determined by 
the stem it combines with: 
'say' 'pray' 'mix' 
(1) lsg pres ind 
2sg pres ind 
3sg pres ind 
sag+e 
sag+st 
sag+t 
bet + e 
bet+ est 
bet-/-et 
mix+e 
mix+t 
mix+t 
MORPHOTACTICS describes the arrangement of 
morphs in words, including, e.g., the properties 
of -st that it is a suffix (and thus follows the 
stem it combines with), and that it combines 
with verbs. While allomorphy is normally de- 
scribed in finite automata (FA), morphotactics 
is generally described in syntax-oriented models, 
e.g., CFGs or feature-based grammars. 
The present paper describes both allomor- 
phy and morphotactics in a feature-based lan- 
guage like that of Head-Driven Phrase Struc- 
ture Grammar (HPSG) (Pollard and Sag 1987). 
*This work was supported by research grant ITW 
9002 0 from the German Bundesministerium ffir 
Forschung und Technologie to the DFKI DISCO 
project. We are grateful to an anonymous ACL re- 
viewer for helpful comments. 
The technical kernel of the paper is a feature- 
based definition of FA. 1 While it is unsurprising 
that the languages defined by FA may also be 
defined by feature description languages (FDL), 
our reduction goes beyond this, showing how the 
FA themselves may be defined. The significance 
of specifying the FA and not merely the lan- 
guage it generates i that it allows us to use FA 
technology in processing allomorphy, even while 
keeping the interface to other grammar compo- 
nents maximally transparent (i.e., there is NO 
interface--all inguistic information is specified 
via FDL). 
Our motivation for exploring this application 
of typed feature logic is the opportunity it pro- 
vides for integrating in a single descriptive for- 
malism not only (i) allomorphic and morpho- 
tactic information but also (ii) coneatenative 
and non-concatenative allomorphy. The latter 
is particularly useful when concatenative and 
non-concatenative allomorphy coexists in a sin- 
gle language, as it does, e.g., in German. 
2 F in i te  Automata  as  Typed 
Feature  S t ructures  
An FA A is defined by a 5-tuple (Q, E, 5, q0, F), 
where Q is a finite set of STATES, ~ a finite IN- 
PUT ALPHABET, (~ : Q x ~ ---y Q is the TRAN- 
SITION FUNCTION, q0 E Q the INITIAL STATE, 
and F _C Q the set of FINAL STATES. 2 For 
reasons of simplicity and space, we only refer 
to the simplest form of FA, viz., DETERMIN-  
ISTIC finite automata without e-moves which 
consume exactly one input symbol at a time. 
This is of course not a restriction w.r.t, ex- 
pressivity: given an arbitrary automaton, we 
can always construct a deterministic, equiva- 
I See Krieger 1993b for the details and several 
extensions. 
2We assume a familiarity with automata theory 
(e.g., Hopcroft and Ullman 1979). 
140 
lent one which recognizes the same language 
(see Hopcroft and Ullman 1979). Fortunately, 
our approach is also capable of representing and 
processing directly non-deterministic FA with e- 
moves and allows for edges which are multiple- 
symbol consumers. 
Specifying an automaton in our approach 
means introducing for every state q E Q a possi- 
bly recursive feature type with the same name as 
q. We will call such a type a CONFIGURATION. 
Exactly the attributes EDGE, NEXT, and INPUT 
are appropriate for a configuration, where EDGE 
encodes disjunctively the outgoing edges of q, 
NEXT the successor states of q, and INPUT the 
symbols which remain on the input list when 
reaching q.S Note that a configuration does not 
model just a state of the automaton, but an en- 
tire description at a point in computation. 
\[ EDGE input-symb \] 
(2) proto-confi9 _= | NEXT config | 
/ INPUT list(input-symb)J 
We now define two natural subtypes of proto- 
con fig. The first one represents the non-final 
states Q \ F.  Because we assume that exactly 
one input symbol is consumed every time an 
edge is taken, we are allowed to separate the 
input list into the first element and the rest list 
in order to structure-share the first element with 
EDGE (the consumed input symbol) and to pass 
the rest list one level deeper to the next state. 
(3) non-final-conflg =_ 
proto-config "\] 
EDGE \ [ \ ]  / 
NEXTIINPUT \ [ \ ]  / 
INPUT ( \[-i-\]. \ [ \ ]  )J
The other subtype encodes the final states of 
F which possess no outgoing edges and therefore 
no successor states. To cope with this fact, we 
introduce a special subtype of T, called under, 
which is incompatible with every other type. In 
addition, successfully reaching a final state with 
no outgoing edge implies that the input list is 
empty. 
(4) final-config = 
proto- config \] 
EDGE undef l 
NEXT undef l 
INP  ( ) J 
aNote that EDGE is not restricted in bearing only 
atomic symbols, but can also be labeled with com- 
plex ones, i.e., with a possibly underspecified fea- 
ture structure (for instance in the case of 2-1evel 
morphology--see below). 
A 
Figure 1: A finite automaton A recognizing the 
language ?(A) = (a + b)*c. 
Of course, there will be final states with out- 
going edges, but such states are subtypes of the 
following DISJUNCTIVE type specification: 
(5) config =_ non-final-con.fig V J~inal-config 
To make the idea more concrete, let us study 
a very small example, viz., the FA A (see Fig- 
ure 1). A consists of the two states X and Y, 
from which we define the types X and Y, where 
Y (7) is only an instantiation of final-config. 
In order to depict the states perspicuously, we 
shall make use of DISTRIBUTED DISJUNCTIONS. 
DSrre and Eisele 1989 and Backofen et al 1990 
introduce distributed disjunctions because they 
(normally) allow more efficient processing of dis- 
junctions, sometimes obviating the need to ex- 
pand to disjunctive normal form. They add no 
expressive power to a feature formalism (assum- 
ing it has disjunction), but abbreviate some oth- 
erwise prolix disjunctions: 
{$1 a V 
PATH2 $1 ~ V fl} = 
PATH3 . . ,  \] {\[PA ,a \] \[P,THlb \]} 
PATH2 o~ V PATH2 fl 
PATH3 \[ . . .  \] PATH3 \[ . . .  \] 
The two disjunctions in the feature structure 
on the left bear the same name '$1', indicat- 
ing that they are a single alternation. The 
sets of disjuncts named covary, taken in order. 
This may be seen in the right-hand side of the 
equivalence. 4 
We employ distributed isjunctions below (6) 
to capture the covariation between edges and 
4Two of the advantages of distributed disjunc- 
tions may be seen in the artificial example above. 
First, co-varying but nonidentical elements can be 
identified as such, even if they occur remotely from 
one another in structure, and second, features truc- 
tures are abbreviated. The amount of abbreviation 
depends on the number of distributed isjunctions, 
the lengths of the paths PATH1 and PATH2, and--in 
at least some competing formalisms--on the size of 
the remaining structure (cf. PATH3 \[.. . \] above). 
141 
their successor states: if a is taken, we must 
take the type X (and vice versa), if b is used, 
use again type X, but if c is chosen, choose the 
type Y. 
(6) 
"non-final-config \] 
X- -  EDGE $1{aVbVc} 
NEXT $1{X V X V Y} 
(7) Y - \[ final-config \] 
Whether an FA A ACCEPTS the input or not 
is equivalent in our approach to the question of 
FEATURE TERM CONSISTENCY: if we wish to 
know whether w (a list of input symbols) will 
be recognized by A, we must EXPAND the type 
which is associated with the initial state q0 of A 
and say that its INPUT is w. Using the terminol- 
ogy of Carpenter 1992: (8) must be a TOTALLY 
WELL-TYPED feature structure. 
\[q? \] 
(8) INPUT W 
Coming back to our example (see Figure 1), 
we might ask whether abc belongs to /2(A). 
We can decide this question, by expanding the 
type X with \[INPUT (a,b,c)\].  This will lead 
us to the following consistent feature structure 
which moreover epresents, for free, the com- 
plete recognition history of abc, i.e., all its solu- 
tions in the FA. 
/ / EDGE \ [ \ ]  c
(9) \]NEXT \[NEXT IEYGE under 
| | NEXT \]NEXT under 
I | \[INPUT \ [ \ ]  ( > 
/ | INPUT r-~ ( ~\ ] .~\ ]  ) 
/ LINPUT~ < \ [~ '~ 
LINPUT < 5q" 
Note that this special form of type expansion 
will always terminate, either with a unification 
failure (A does not accept w) or with a fully 
expanded feature structure, representing a suc- 
cessful recognition. This idea leads us to the 
following ACCEPTANCE CRITERION: 
(10) 
w ? ?(A) ?=~ 
(NEXT)" \[{NP  ()  
where f ? F 
Notice too that the acceptance criterion does not 
need to be checked explicitly--it's only a logi- 
cal specification of the conditions under which 
a word is accepted by an FA. Rather the effects 
of (10) are encoded in the type specifications of 
the states (subtypes of final-config, etc.). 
Now that we have demonstrated the feature- 
based encoding of automata, we can abbrevi- 
ate them, using regular expressions as "feature 
templates" to stand for the initial states of the 
automaton derived from them as above. 5 For 
example, we might write a feature specification 
\[NORPHIFORN (a + b)*c\] to designate words of 
the form accepted by our example automaton. 
As a nice by-product of our encoding tech- 
nique, we can show that unification, disjunction, 
and negation in the underlying feature logic di- 
rectly correspond to the intersection, union, and 
complementation f FA. Note that this state- 
ment can be easily proved when assuming aclas- 
sical set-theoretical semantics for feature struc- 
tures (e.g., Smolka 1988). To give the flavor of 
how this is accomplished, consider the two reg- 
ular expressions 1 : ab*c and/22 -- a*bc. We 
model them via six types, one for each state of 
the automata. The initial state of/21 is A, that 
of/22 is X. The intersection of?1 and/22 is given 
by the unification of A and X. Unifying A and 
X leads to the following structure: 
(11) 
: |EDGE a 
\[NEXT BJ \[NEXT $1 {XV Y}J \[NEXT B A 
Now, testing whether w belongs to /21 N/22 is 
equivalent to the satisfiability (consistency) of 
(12) A A X A \[INPUT w\], 
where type expansion yields a decision proce- 
dure. The same argumentation holds for the 
union and complementation f FA. It has to be 
noted that the intersection and complementa- 
tion of FA via unification do not work in general 
5'Template' is a mild abuse of terminology since 
we intend not only to designate the type correspond- 
ing to the initial state of automaton, but also to 
suggest what other types are accessible. 
142 
for FA with e-moves (Ritchie et al 1992, 33-35). 
This restriction is due to the fact, that the in- 
tersected FA must run "in sync" (Sproat 1992, 
139-140). 
The following closure properties are demon- 
strated fairly directly. 
Let A1 = (Qt,Et,61,qo, Ft) and As = 
(Os, ~2, ~S, q~), Fs). 
* A l f7As  ~ qoAq~o 
? A tUAs  ~ qoVqto 
? A1 ~ -~qo 
In addition, a weak form of functional uncer- 
tainty (Kaplan and Maxwell 1988), represented 
through recursive type specifications, is appro- 
priate for the expression also concatenation a d 
Kleene closure of FA. Krieger 1993b provides 
proofs using auxiliary definitions and apparatus 
we lack space for here. 
3 A l lomorphy  
The focus of this section lies in the illustration 
of the proposal above and in the demonstration 
of some benefits that can be drawn from the in- 
tegration of allomorphy and morphotactics; we 
eschew here the discussion of alternative the- 
ories and concentrate on inflectional morphol- 
ogy. We describe inflection using a word-and- 
paradigm (WP) specification of morphotactics 
(Matthews 1972) and a two-level treatment of 
allomorphy (Koskenniemi 1983). We also indi- 
cate some potential advantages ofmixed models 
of allomorphy--finite state and other. 6
3.1 WP Morphotact l cs  in FDL 
Several WORD-GRAMMARS use FDL morphotac- 
tics (Trost 1991, Krieger and Nerbonne 1992 on 
derivation); alternative models are also avail- 
able. Krieger and Nerbonne 1992 propose an 
FDL-based WP treatment of inflection. The 
basic idea is to characterize all the elements 
of a paradigm as alternative specifications of 
abstract lexemes. Technically, this is realized 
through the specification of large disjunctions 
which unify with lexeme specifications. The 
SThe choice of two-level allomorphy is justified 
both by the simplicity of two-level descriptions and 
by their status as a "lingua franca" among compu- 
tational morphologists. Two-level analyses in FDLs 
may also prove advantageous if they simplify the po- 
tential compilation into a hybrid two-level approach 
of the kind described in Trost 1991. 
three elements of the paradigm in (1) would be 
described by the distributed isjunction in (13). 
(13) weak-paradigm - 
word 
FORH ,pp,nd(U,r ) 
STEN~ NORPH I ENDING,s1 
SyNILOCIHEADIAGR \ [N  UH 
PER 
This treatment provides 
face to syntactic/semantic 
helps realize the goal of 
linguistic knowledge in a 
(Pollard and Sag 1987). 
(+,e) V } 
( +,s,t> v 
(-I-,t) 
sg 
, {lv:v3} 
a seamless inter- 
information, and 
representing ALL 
single formalism 
Nevertheless, the model lacks a treatment 
of allomorphy. The various allomorphs of -st 
in (1) are not distinguished in the FDL, and 
Krieger and Nerbonne 1992 foresaw an interface 
to an external module for allomorphy. It would 
be possible--but scientifically poor--to distin- 
guish all of the variants at the level of mor- 
photactics, providing a brute-force solution and 
multiplying paradigms greatly. 7 The character- 
ization in Section 2 above allows us to formu- 
late WITHIN FDL the missing allomorphy com- 
ponent. 
3.2 Two-Level Al lomorphy  
Two-level morphology has become popular be- 
cause it is a declarative, bidirectional and 
efficient means of treating allomorphy (see 
Sproat 1992 for a comprehensive introduction). 
In general, two-level descriptions provide con- 
straints on correspondences between underly- 
ing (lexical) and surface levels. We shall use 
it to state constraints between morphemic units 
and their allomorphic realizations. Because two- 
level automata characterize relations between 
two levels, they are often referred to (and often 
realized as) transducers. The individual rules 
then represent constraints on the relation being 
transduced. 
The different forms of the suffix in 2nd person 
singular in (1) are predictable given the phono- 
logical shape of the stem, and the alternations 
can be described by the following (simplified) 
two-level rules (we have abstracted away from 
inessential restrictions here, e.g., that (strong) 
verbs with i/e-umlaut do not show epenthesis): 
rTzoukermann and Libermann 1990 show that 
multiplying paradigms need not degrade perfor- 
mance, however. 
143 
(14) 
e-epenthesis in the bet- case 
+:e  . {d,t}_{s,t} 
s-deletion in the mix- case 
s:O ?:~ {s,z,z,  ch}+:O t 
The colon ':' indicates a correspondence be- 
tween lexical and surface levels. Thus the 
first rule states that a lexical morph bound- 
ary + must correspond to a surface e if it oc- 
curs after d or t and before s or t. The sec- 
ond specifies when lexical s is deleted (corre- 
sponds to surface 0). Two-level rules of this 
sort are then normally compiled into transduc- 
ers (Dalrymple t al. 1987, p.35-45). 
3.3 FDL Specif ication of  Two-Level 
Morpho logy  
Two-level descriptions of allomorphy can be 
specified in FDLs straightforwardly if we model 
not transducers, but rather two-level accep- 
tors (of strings of symbol pairs), following 
Ritchie et al 1992. We therefore employ FA 
over an alphabet consisting of pairs of symbols 
rather than single symbols,  
The encoding of these FA in our approach 
requires only replacing the alphabet of atomic 
symbols with an alphabet of feature structures, 
each of which bears the attributes LEX and SURF. 
A pair of segments appearing as values of these 
features tand in the lexical-surface correspon- 
dence relation denoted by ':' in standard two- 
level formalisms. The values of the attributes 
STEM and ENDING in (13) are then not lists of 
symbols but rather lists of (underspecified) fea- 
ture structures. Note that the italicized t etc. 
found in the sequences under MORPHIENDING (13) 
denote types defined by equations such as (16) 
or (17). (To make formulas shorter we abbrevi- 
ate 'alphabet' etymologically as 'aft'.) 
(15) a\]~ = 
\[LEX $1{"a"V . . " s "V"s"V '+"V"+"}  \] 
SURF $d"a"  V . "s"  V 0 V "e" v 0} 
(16) t = ^ \[LZX "t"\] = \] LEX "t" 
SURF "t" 
(17) + =-- (~  A \[LEX "+"\] : LEX "+" 
SURF "e" v 0 
aSince our formalisation of FA cannot allow e- 
transitions without losing important properties, we 
are in fact forced to this position. 
It is the role of the collection of FA to re- 
strict underspecifled lexical representations to
those obeying allomorphic onstraints. This is 
the substance of the allomorphy constraint (18), 
which, together with the Acceptance Criterion 
(10), guarantees that the input obeys the con- 
straints of the associated (initial states of the) 
FA. 
NORPH\]FORM \[~\] 
(18) allomorphy =_ INPUT \ [ \ ]  
Rules of the sort found in (14) can be directly 
compiled into FA acceptors over strings of sym- 
bol pairs (Ritchie et al 1992, p.19). Making use 
of the regular expression otation as templates 
(introduced in Section 2 above), (19-21) display 
a compilation of the first rule in (14). Here the 
composite rule is split up into three different 
constraints. The first indicates that epenthesis 
is obligatory in the environment specified and 
the latter two that each half of the environment 
specification is necessary. 9 
(19) epenth-1 =_ 
Nallomorphy \] 
0RPH \[FORM (11"* {t,d} +:0 {s,t} 7r*)\]J 
(20) epenth-2 =_ 
allomorphy 
(21) epenth.3 =_ 
allomorphy 
+ o 
3.4 Limits of Pure FA Morphology 
Finite-state morphology has been criticized (i) 
for the strict finite-stateness of its handling 
of morphotactics (Sproat 1992, 43-66); (ii) for 
making little or no use of the notion of inflec- 
tional paradigms and inheritance relations be- 
tween morphological c asses (Cahill 1990); and 
(iii) for its strict separation of phonology from 
morphology--i.e., standard two-level rules can 
only be sensitive to phonological contexts (in- 
cluding word and morpheme boundaries), and 
apply to all forms where these contexts hold. 
In fact, allomorphic variation is often "fos- 
silized", having outlived its original phonological 
motivation. Therefore some allomorphic rules 
97r* denotes the Kleene closure over alphabet 11" 
and A the complement of A with respect o ~r. 
144 
are restricted in nonphonological ways, apply- 
ing only to certain word classes, so that some 
stems admit idiosyncratic exceptions with re- 
spect o the applicability of rules (see Bear 1988, 
Emele 1988, Trost 1991)? 
To overcome the first difficulty, a number 
of researchers have suggested augmenting FA 
with "word grammars", expressed in terms of 
feature formalisms like PATR II (Bear 1986) 
or HPSG (Trost 1990). Our proposal follows 
theirs, improving only on the degree to which 
morphotactics may be integrated with allomor- 
phy. See Krieger and Nerbonne 1992 for pro- 
posals for treating morphotactics in typed fea- 
ture systems. 
We illustrate how the FDL approach over- 
comes the last two difficulties in a concrete 
case of nonphonologically motivated allomor- 
phy. German epenthesizes schwa (< e >) at 
morph boundaries, but in a way which is sensi- 
tive to morphological environments, and which 
thus behaves differently in adjectives and verbs? 
The data in (22) demonstrates some of these dif- 
ferences, comparing epenthesis inphonologically 
very similar forms? 
free, adj super frei+st freiest 
(22) free, v 2s pres be+frei+st befreist 
woo, v 2s pres frei+st freist 
While the rule stated in (14) (and reformu- 
lated in (19)-(21)) treats the verbal epenthesis 
correctly, it is not appropriate for adjectives, for 
it does not allow epenthesis to take place after 
vowels. We thus have to state different rules for 
different morphological categories. 
The original two-level formalism could only 
solve this problem by introducing arbitrary dia- 
critic markers? The most general solution is due 
to Trost 1991, who associated two-level rules 
with arbitrary filters in form of feature struc- 
tures. These feature structures are unified with 
the underlying morphs in order to check the con- 
text restrictions, and thus serve as an interface 
to information provided in the feature-based lex- 
icon. But Trost's two-level rules are a com- 
pletely different data structure from the feature 
structures decorating transitions in FA. 
We attack the problem head on by restrict- 
ing allomorphic onstraints to specific classes 
of lexical entries, making use of the inheritance 
techniques available in structured lexicons? The 
cases of epenthesis in (22) is handled by defining 
not only the rule in (19-21) for the verbal cases, 
but also a second, quite similar ule for the more 
liberal epenthesis n adjectives) ? This frees the 
1?In fact, the rules could be specified so that the 
T 
? . ? 
allomorphy 
epenth-1 epenth-2 epenth-3 word 
Adj Verb ... 
Figure 2: Nonphonological  Condit ioning of 
allomorphy is achieved by requiring that only 
some word classes obey the relevant constraints? 
Adjectives inherit from two of the epenthesis 
constraints in the text, and verbs (without i/e 
umlaut) satisfy all three. This very natural 
means of restricting allomorphic variation to se- 
lected, nonphonologically motivated classes is 
only made available through the expression of 
allomorphy in type hierarchy of the FDL. (The 
types denote the initial states of FA, as ex- 
plained in Section 2.) 
rule from operating on a strictly phonological 
basis, making it subject o lexical conditioning? 
This is illustrated in Figure 2. 
But note that this example demonstrates not 
only how feature-based allomorphy can over- 
come the strictly phonological base of two-level 
morphology (criticism (iii) above), but it also 
makes use of the inheritance structure in mod- 
ern lexicons as well. 
4 Conc lus ions  
In this section we examine our proposal vis-b.-vis 
others, suggest future directions, and provide a 
summary. 
4.1 Comparison to other  Work 
Computational morphology is a large and ac- 
tive field, as recent textbooks (Sproat 1992 
and Ritchieet al 1992) testify? This im- 
pedes the identification of particularly im- 
portant predecessors, among whom nonethe- 
less three stand out. First, Trost 1991's 
use of two-level morphology in combination 
verbal rule inherited from the more general adjecti- 
val rule, but pursuing this here would take us some- 
what afield. 
145 
with feature-based filters was an important 
impetus. Second, researchers at Edinburgh 
(Calder 1988, Bird 1992) first suggested using 
FDLs in phonological and morphological de- 
scription, and Bird 1992 suggests describing FA 
in FDL (without showing how they might be so 
characterized, however--in particular, providing 
no FDL definition of what it means for an FA 
to accept a string). 
Third, Cahill 1990 posed the critical question, 
viz., how is one to link the work in lexical inher- 
itance (on morphotactics) with that in finite- 
state morphology (on allomorphy). This ear- 
lier work retained a separation of formalisms 
for allomorphy (MOLUSC) and morphotactics 
(DATR). Cahill 1993 goes on to experiment with 
assuming all of the allomorphic specification i to 
the lexicon, in just the spirit proposed here. 11 
Our work differs from this later work (i) in that 
we use FDL while she uses DATR, which are 
similar but not identical (cf. Nerbonne 1992); 
and (ii) in that we have been concerned with 
showing how the standard model of allomorphy 
(FA) may be assumed into the inheritance hier- 
archy of the lexicon, while Cahill has introduced 
syllable-based models. 
4.2 Future  Work 
At present only the minimal examples in 
Section 2 above have actually been imple- 
mented, and we are interested in attempting 
more. Second, a compilation into genuine fi- 
nite state models could be useful. Third, 
we are concerned that, in restricting ourselves 
thus far to acceptors over two-level alpha- 
bets, we may incur parsing problems, which a 
more direct approach through finite-state trans- 
ducers can avoid (Sproat 1992, p.143). See 
Ritchie et al 1992, 19-33 for an approach to 
parsing using finite-state acceptors, however. 
4.3 Summary 
This paper proposes a treatment of allomor- 
phy formulated and processable in typed feature 
logic. There are several reasons for developing 
this approach to morphology. First, we prefer 
the GENERALITY of a system in which linguis- 
tic knowledge of all sorts may be expressed--at 
least as long as we do not sacrifice processing 
efficiency. This is an overarching goal of HPSG 
(Pollard and Sag 1987)--in which syntax and 
semantics i  described in a feature formalism, 
and in which strides toward descriptions ofmor- 
photactics (Krieger 1993a, Riehemann 1993, 
lICf. Reinhard and Gibbon 1991 for another sort 
of DATR-based allomorphy 
Gerdemann 1993) and phonology (Bird 1992) 
have been taken. This work is the first to show 
how allomorphy may be described here. The 
proposal here would allow one to describe seg- 
ments using features, as well, but we have not 
explored this opportunity for reasons of space. 
Second, the uniform formalism allows the ex- 
act and more transparent specification of depen- 
dencies which span modules of otherwise dif- 
ferent formalisms. Obviously interesting cases 
for the extension of feature-based descriptions 
to other areas are those involving stress and 
intonation--where phonological properties can 
determine the meaning (via focus) and even syn- 
tactic well-formedness (e.g., of deviant word or- 
ders). Similarly, allomorphic variants covary in 
the style register they belong to: the German 
dative singular in -e, dera Kinde, belongs to a 
formal register. 
Third, and more specifically, the feature- 
based treatment of allomorphy overcomes the 
bifurcation of morphology into lexical aspects-- 
which have mostly been treated in lexical in- 
heritance schemes--and phonological spects-- 
which are normally treated in finite-state mor- 
phology. This division has long been recognized 
as problematic. One symptom of the problem 
is seen in the treatment of nonphonologically 
conditioned allomorphy, such as German um- 
laut, which (Trost 1990) correctly criticizes as 
ad hoc in finite-state morphology because the 
latter deals only in phonological (or graphemic) 
categories. We illustrated the benefits of the 
uniform formalism above where we showed how 
a similar nonphonologically motivated alterna- 
tion (German schwa epenthesis) is treated in 
a feature-based description, which may deal in 
several levels of linguistic description simultane- 
ously. 
References 
Backofen, R., L. Euler, and G. G6rz. 1990. Towards 
the Integration of Functions, Relations and Types 
in an AI Programming Language. In Proc. of 
GWAI-90. Berlin. Springer. 
Bear, J. 1986. A Morphological Recognizer with 
Syntactic and Phonological Rules. In Proc. of 
COLING, 272-276. 
Bear, J. 1988. Morphology with Two-Level Rules 
and Negative Rule Features. In Proc. of COLING, 
28-31. 
Bird, S. 1992. Finite-State Phonology in HPSG. In 
Proc. of COLING, 74-80. 
Cahill, L. J. 1990. Syllable-Based Morphology. In 
Proc. of COLING, 48-53. 
Cahill, L. J. 1993. Morphonology in the Lexicon. In 
Proc. of the 7th European A CL, 87-96. 
146 
Calder, J. 1988. Paradigmatic Morphology. In Proc. 
of the 5th European A CL. 
Carpenter, B. 1992. The Logic of Typed Feature 
Structures. No. 32Tracts in Theoretical Com- 
puter Science. Cambridge: Cambridge University 
Press. 
Dalrymple, M., R. Ka- 
plan, L. Karttunen, K. Koskenniemi, S. Shaio, 
and M. Wescoat. 1987. Tools for Morphological 
Analysis. Technical Report CSLI-1987-108, CSLI, 
Stanford University. 
DSrre, J., and A. Eisele. 1989. Determining Consis- 
tency of Feature Terms with Distributed Disjunc- 
tions. In Proc. of GWAI-89 (15th German Work- 
shop on AI), ed. D. Metzing, 270-279. Berlin. 
Springer-Verlag. 
Emele, M. 1988. Uberlegungen zu einer Two-Level 
Morphologie fiir das Deutsche. In Proc. der 
4. Osterreichischen Artificiai-lntelligence- Tagung 
und des WWWS, ed. H. Trost, 156-163. Berlin: 
Springer. Informatik-Fachberichte 176. 
Gerdemann, D. 1993. Complement Inheritance as 
Subcategorization Inheritance. In German Gram- 
mar in HPSG, ed. J. Nerbonne, K. Netter, and 
C. Ponard. Stanford: CSLI. 
Hopcroft, J. E., and J. D. Ullman. 1979. In- 
troduction to Automata Theory, Languages, and 
Computation. Reading, Massachusetts: Addison- 
Wesley. 
Kaplan, R., and J. Maxwell. 1988. An Algorithm for 
Functional Uncertainty. In Proc. of Coling 1988, 
303-305. Budapest. 
Koskenniemi, K. 1983. Two-Level Model for Mor- 
phological Analysis. In Proc. of IJCAI, 683-685. 
Krieger, H.-U. 1993a. Derivation Without Lexi- 
cad Rules. In Constraint Propagation, Linguis- 
tic Description and Computation, ed. R. Johnson, 
M. Rosner, and C. Rupp. Academic Press. 
Krieger, H.-U. 1993b. Representing and Pro- 
cessing Finite Automata Within Typed Fea- 
ture Formalisms. Technical report, Deutsches 
Forschungsinstitut fiir Kiinstfiche Intelligenz, 
Saarbriicken, Germany. 
Krieger, H.-U., and J. Nerbonne. 1992. Feature- 
Based Inheritance Networks for Computational 
Lexicons. In Default Inheritance within 
Unification-Based Approaches to the Lexicon, ed. 
T. Briscoe, A. Copestake, and V. de Paiva. Cam- 
bridge: Cambridge University Press. Also DFKI 
Research Report RR-91-31. 
Matthews, P. 1972. Inflectional Morphology: A The- 
oretical Study Based on Aspects of Latin Verb 
Conjugation. Cambridge, England: Cambridge 
University Press. 
Nerboune, J. 1992. Feature-Based Lexicons-- 
An Example and a Comparison to DATR. In 
Beitriige des ASL-Lexikon- Workshops, Wandlitz 
(bei Berlin), ed. D. Reimann, 36-49. also DFKI 
RR-92-04. 
Pollard, C., and I. Sag. 1987. Information-Based 
Syntax and Semantics, Vol.L Stanford: CSLI. 
Reinhard, S., and D. Gibbon. 1991. Prosodic In- 
heritance and Morphological Generalizations. In 
Proc. of the 6th European ACL, 131-137. 
Riehemarm, S. 1993. Word Formation in Lexical 
Type Hierarchies. A Case Study of bar-Adjectives 
in German. Master's thesis, Eberhard-Karls- 
Universit~it Tiibingen, Seminar f/Jr Sprachwis- 
senschaft. 
Ritchie, G. D., G. J. Russell, A. W. Black, and S. G. 
Pulman. 1992. Computational Morphology: Prac- 
tical Mechanisms for the English Lexicon. Cam- 
bridge: MIT Press. 
Smolka, G. 1988. A Feature Logic with Subsorts. 
Technical Report 33, WT LILOG-IBM Germany. 
Sproat, R. 1992. Morphology and Computation. 
Cambridge: MIT Press. 
Trost, H. 1990. The Application of Two-Level Mor- 
phology to Non-concatenative G rman Morphol- 
ogy. In Proc. of COLING, 371-376. 
Trost, H. 1991. X2MORF: A Morphological Com- 
ponent Based on Augmented Two-Level Mor- 
phology. Technical Report RR-91-04, DFKI, 
Saarbrficken, Germany. 
Tzoukermann, E., and M. Libermann. 1990. A 
Finite-State Morphological Processor for Spanish. 
In Proc. of COLING, Vol. 3. 
147 
