TRANSLAT ING ENGLISH INTO LOGICAL  FORM'  
Stanley J. Rosenscbein 
Stuart M, Shieber 
ABSTRACT 
A scheme for syntax-directed translation that mirrors com- 
positional model-theoretic semantics i discussed. The scheme is the 
basis for an English translation system called PArR and was used to 
specify a semantically interesting fragment of English, including such 
constructs as tense, aspect, modals, and various iexically controlled verb 
complement s ructures. PATR was embedded in a question-answering 
system that replied appropriately to questions requiring the computa- 
tion of logical entailments. 
I INTRODUCTION 
When contemporary linguists and philosophers speak 
of "semantics," they usually mean m0del-theoretic semantics-- 
mathematical devices for associating truth conditions with Sentences. 
Computational linguists, on the other hand, often use the term 
"semantics" to denote a phase of processing in which a data structure 
(e.g., a formula or network) is constructed to represent the meaning 
of a sentence and serve as input to later phases of processing. {A bet- 
ter name for this process might be "translation" or "traneduction.") 
Whether one takes "semantics" tobe about model theory or translation, 
the fact remains that natural languages are marked by a wealth of com- 
plex constructions--such as tense, aspect, moods, plurals, modality, ad- 
verbials, degree terms, and sententiai complemonts--that make seman- 
tic specification a complex and challenging endeavor. 
Computer scientists faced with the problem of managing 
software complexity have developed strict design disciplines in their 
programming methodologies. One might speculate that a similar re- 
quirement for manageability has led linguists (since Montague, at least) 
to follow a discipline of strict compositiouality in semantic specification, 
even though model*theoretic semantics per me does not demand it. 
Compositionaiity requires that the meaning of a pbrase be a function 
of the meanings of its immediate constituents, a property that allows 
the grammar writer to correlate syntax and semantics on a rule-by-rule 
basis and keep the specification modular. Clearly, the natural analogue 
to compositionality in the case of translation is syntax-directed trans- 
lation; it is this analogy that we seek to exploit. 
We describe a syntax-directed translation scheme that bears 
a close resemblance to model-theoretic approaches and achieves a level 
of perspicuity suitable for the development of large and complex gram- 
mars by using a declarative format for specifying rammar rules. In our 
formalism, translation types are associated with the phrasal categories 
of English in much the way that logical-denotation types are associated 
Artificial Intelligence Center 
SRI International 
333 Raveoswood Avenue 
Menlo Park, CA 94025 
with phrasal categories in model-theoretic semantics. The translation 
'types are classes of data objects rather than abstract denotations, yet 
they play much the same role in the translation process that denotation 
types play in formal semantics. 
In addition to this parallel between logical types and trans- 
lation types, we have intentionally designed the language in which 
translation rules are stated to emphasize parallels between the syntax- 
directed translation and corresponding model-theoretic interpretation 
rules found in, say, the GPSG literature \[Gazdar, forthcoming\]. In 
the GPSG approach, each syntax rule has an associated semantic rule 
(typically involving functional application) that specifies how to com- 
pose the meaning of a phrase from the meanings of its constituents. 
In an analogous fashion, we provide for the translation of a phrase 
to be synthesized from the translations of its immediate constituents 
according to a local rule, typically involving symbol/c application and 
~-conversiou. 
It should be noted in passing that doing translation rather 
than model theoretic interpretation ffers the temptation to abuse the 
formalism by having the "meaning" (translation) of a phrase depend 
on syntactic properties of the translations of its constituents--for in- 
stance, on the order of conjuncts in a logical expression. There are 
several points to be made in this regard. First, without severe a priori 
restrictions on what kinds of objects can be translations (coupled with 
the associated strong theoretical claims that such restrictions would 
embody) it seems impossible to prevent such abuses. Second, as in the 
case of programming languages, it is reasonable to mmume that there 
would emerge a set of stylistic practices that would govern the actual 
form of grammars for reasons of manageability and esthetics. Third, it 
is still an open question whether the model*theoretic program of strong 
compositiouality will actually succeed. Indeed, whether it succeeds or 
not is of little concern to the computational linguist, whose systems, in 
any event, have no direct way of using the sort of abstract model being 
proposed and whose systems must, iu general, be based on deduction 
(and hence translation). 
The rest of the paper discusses our work in more detail. 
Section II presents the grammar formalism and describes PATR, an 
implemented parsing and translation system that can accept a gram- 
mar in our formalism and uses it to process entences. Examples of 
the system's operation, including its application in a simple deductive 
question-answering system, are found in Section HI. Finally, Section 
IV describes further extensions of the formalism and the parsing sys- 
tem. Three appendices are included: the first contains ample gram- 
mar rules; the second contains meaning postulates (axioms) used by 
the question-answering system; the third presents a sample dialogue 
session. 
"This research wns supported by the Defense Advanced Research Projects Agency 
under Contract N000SO-SO-C.-0575 with the Naval Electronic Systems Conunand. 
The views and conclusions contained in this document are those of the authors and 
should not be interpreted nsrepresentative of the ol~cial policies, either expres~.d 
or implied, of the Defense Ad~eanced Research Projects Agency or the United States 
Government. 
i l  A GRAMMAR FORMALISM 
A General Characterization 
Our grammar formalism is beet characterized asn specialized 
type of augmented context-free grammar? That is, we take a grammar 
to be a set of context-fres rules that define a language and associate 
structural descriptions (parse trees) for each sentence in that language 
in the usual way. Nodes in the parse tree are assumed to have a set of 
features which may assume binary values (True or False), and there is 
a distinguished attribute--the "translation'--whoee values range over 
a potentially infinite set of objects, i.e., the translations of English 
phrases. 
Viewed more abstractly, we regard translation as a binary 
relation between word sequences and logical formulas. The use of 
a relation is intended to incorporate the fact that many word se- 
quences have several logical forms, while some have none at all. 
Furthermore, we view this relation as being composed (in the mathe- 
matical sense) of four simpler elations corresponding to the conceptual 
phases of analysis: (1) LEX (lexical analysis), (2) PARSE (parsing), (3) 
ANNOTATE (assignment of attribute values, syntactic filtering), and 
(4) TRANSLATE (translation proper, i.e., synthesis of logical form). 
The domains and ranges of these relations are as follows: 
Word Sequences -LEX-* 
Morpheme Sequences -PARSE-*  
Phrase Structure Trees -ANNOTATE-* 
Annotated Trees -TRANSLATE-* 
Logical Form 
The relational composition of these four relations is the full translation 
relation associating word sequences with logical forms. The subphases 
too are viewed as relations to reflect the inherent nondeterminism of 
each stage of the process. For example, the sentence =a hat by every 
designer sent from Paris was felt" is easily seen to be nondeterminis- 
tic in LEX ('felt'), PARSE (poetnominal modifier attachment), and 
TRANSLATE (quantifier scoping). 
It should be emphasized that the correspondence b tween 
processing phases and these conceptual phases is loose. The goal of 
the separation is to make specification of the process perspicous and to 
allow simple, clean implementations. An actual system could achieve 
the net effect of the various stages in many ways, and numerous op- 
timizatious could be envisioned that would have the effect of folding 
back later phases to increase fficiency. 
B The Relations LEX, PARSE, and ANNOTATE 
We now describe a characteristic form of specification ap- 
RULES: 
constant corn,' - (~ e (X Q CX x CP CQ x))))) 
S--* NPVP 
Truss: VP' \[NP'\] 
VP -* T~qSEV 
Aano: \[-~Transitivo(V) \] 
Tr,=,: { couP' \ [~ ' \ ]  t~'\] } 
lEXICON: 
I f  -* John 
Aano: \[Proper(W) \] 
Truss: { John } 
TENSE -* &put 
Trash: { (X x CpastX)) } 
V-*go 
Anon: \[ -~Trasnitivn(V) \] 
Trnn: { C~ x Can x)) } 
Figure 1: Sample specification of augmented phrase structure 
grammar 
propriate to each phase and illustrate how the word sequence "John 
went" is analyzed by stages as standing in tbe translation relation 
to "(past (go john))" according to the (trivial) grammar presented in 
Figure 1. 
Lexieal analysis is specified by giving a kernel relation between 
individual words and morpheme sequences I (or equivalently, a mapping 
from words to sets of morpheme sequences), for example: 
John -* (john) :
vent -* (kput  go) : 
persuaded -+ (kput persuade) o 
(kppl persuadn) : 
The kernel relation is extended in a standard fashion to the 
full LEX relation. For example, "went" is mapped onto the single 
morpheme sequence (&past go), and "John" is mapped to (john). Thus, 
by extension, "John went" is transformed to (John &post go) by the 
lexical analysis phase. 
Parsing is specified in the usual manner by a context-free 
grammar. Utilizing the eontext,-free rules presented in the sample 
system specification shown in Figure 1, (John 8cpast go) is transformed 
into the parse tree 
(S (NP john) 
C~ (r~rsE tput)  
Cvso))) 
Every node in the parse tree has a set of associated features. 
The purpo6e of ANNOTATE is to relate the bate parse tree to one 
that has been enhanced with attribute values, filtering out three that 
do not satisfy stated syntactic restrictions. These restrictions are given 
as Boolean expressions associated with the context-free rules; a tree is 
properly annotated only if all the Boolean expressions corresponding 
to the rules used in the analysis are simultaneously true. Again, using 
the rules of Figure 1, 
lof course, more sophisticated spprotehe~ to morpholoslesl sualysls would seek 
to analyze the LEX relgtion more fully. See, for example, ~Kartunnen, lgS2J gad 
\[Ksplan, 19811. 
(s (SP john) 
(W ( ~  aput)  
(V go)) ) 
is transformed into 
(S (NP: Proper 
john) 
(W : "~ Trandlive 
( ~  ~aet)  
(V: -Transitive 
go))) 
C The Relation TRANSLATE 
Logical-form synthesis rules are specified as augments to the 
context-free grammar. There is a language whose expressions denote 
translations ( yntactic formulas); an expression from this language is 
attached to each context-free rule and serves to define the composite 
translation at a node in terms of the translations of its immediate 
constituents. In the sample sentence, TENSE' and V' {the translations 
of TENSE and V respectively) would denote the ),-expressions specified 
in their respective translation rules. VP' {the translation of the VP) 
is defined to be the value of (SAP (SAP COMP' TENSE') V'), where 
COMF' is a constant k-expression and SAP is the symbolic-application 
operator. This works out to be (k X \[past (go X))). Finally, the symbolic 
application of VP' to N'P' yields (past (go John)). (For convenience we 
shall henceforth use square brackets for SAP and designate (SAP a ~) 
by a\[~\].) 
Before describing the symbolic-application perator in more 
detail, it is necessary to explain the exact nature of the data objects 
serving as translations. At one level, it is convenient to think of 
the translations as X-expressions, ince X-expressions are a convenient 
notation for specifying how fragments of a translation are substituted 
into their appropriate operator-operand positions in the formula being 
assembled-especially when the composition rules follow the syntactic 
structure as encoded in the parse tree. There are several phenomena, 
however, that require the storage of more information at a node than 
can be represented in a bare k-expression. Two of the most conspicuous 
phenonema of this type are quantifier scoping and unbounded epen- 
dencies ("gaps"). 
Our approach to quantifier scoping has been to take a version 
of Cooper's storage technique, originally proposed in the context of 
model-tbeoretic semantics, \[Cooper, forthcoming\[ and adapt it to the 
needs of translation. For the time being, let us take translations to 
be ordered pairs whose first component (the head) is an expression 
in the target language, characteristically a k-expression. The second 
component of the pair is an object called storage, astructured collection 
of sentential operators that can be applied to a sentence matrix in such a 
way as to introduce a quantifier and "capture" a free variable occurring 
in that sentence matrix. 2
For example, the translation of "a happy man" might be < 
m , (X S (some m (and (man m)(happy m)) S)) >.s Here the head is m 
(simply a free variable), and storage consists of the X-expression (k S 
2in the sample grammar presented in Appendix A, the storage.formlng operation 
is notated mk.mbd. 
3Followlng \[Moore, lO80~, aquantified expression is of the form (quauti6er, variable, 
restriction, body) 
...). If the verb phrase "sleeps ~were to receive the translation < (X X 
(sleep X)), ~ > (i.e., a unary predicate as head and no storage), then 
the symbolic application of the verb phrase translation to the noun 
phrase translation would compose the heads in the usual way and take 
the "uniou" of the storage yielding < (sleep m), (k S (some m (and 
(man m)(happy m)) S)) >.  
We define an operation called ~pull.s," which has the effect 
of "pulling" the sentence operator out of storage and applying it to 
the head. There is another pull operation, pull.v, which operates on 
heads representing unary predicates rather than sentence matrices. 
When pull.s is applied in our example, it yields < (some m (and (man 
m)(happy m)) (sleep m)), ~b >, corresponding to the translation of the 
clause ~a happy man sleeps." Note that in the process the free vari- 
able m has been "captured." In model-theoretic semantics this cap- 
ture would ordinarily be meaningless, although one can complicate the 
mathematical machinery to achieve the same effect. Since translation 
is fundamentally a syntactic process, however, this operation is well- 
defined and quite natural. 
To handle gaps, we enriched the translations with a third com- 
ponent: a variable corresponding to the gapped position. For example, 
the translation of the relative clause ".,.\[that\] he man saw" would be 
a triple: < (past (see X Y)), Y, (k S (the X (man X) $))>, where 
the second component, Y tracks the free variable corresponding to the 
gap. At the node at which the gap was to be discharged, X-abstraction 
would occur (as specified in the grammar by the operation "uugap') 
producing the unary predicate (X Y (past (see X Y))), which would 
ultimately be applied to the variable corresponding to the head of the 
noun phrase. 
It turns out that triples consisting of (head,  var, storage) 
are adequate to serve as translations of a large class of phrases, but 
that the application operator needs to distinguish two subcases (which 
we call type A and type B objects). Until now we have been discussing 
type A objects, whose application rule is given (roughly) as 
< hal,vat,san>l< hal',vat',san'>\[ 
-~ <(hd hd'),var LI var', sto i3 sto'> 
where one of vat or vat' must be null. In the ease of type B objects, 
which are assigned primarily as translations of determiners, the rule is 
< h d,var ,san > \[< hd',var',sto' >\] 
= <var, var', hd(hd') U sto U sto'> 
For example, if the meaning of "every" is 
every' ~- <(k P (X S (every X (P X) S))), X, ~b> 
and the meaning of ~man" is 
man' ---- < man, ~, ~ > 
then the meaning of "every man" is 
every'\[man'\] = ( X , ?, (X S (man X) S)> , 
as expected. 
Nondeterminism enters in two ways. First, since pull opera, 
tions can be invoked nondeterministically t various nodes in the parse 
tree (as specified by the grammar), there exists the possibility of com- 
puting multiple scopings for a single context-free parse tree. (See 
Section III.B for an example of this phenomenon.) In addition, the 
grammar writer can specify explicit nondeterminism by associating 
several distinct ranslation rules with a single context-free production. 
In this case, he can control the application of a translation schema by 
specifying for each schema guard, a Boolean combination of features 
that the nodes analyzed by the production must satisfy in order for the 
translation schema to be applicable. 
D Imp lementat ion  of  a T rans la t ion  System 
The techniques presented in Sections H.B and II.C were imple- 
mented in a parsing and translation system called PATR which was 
used as a component in a dialogue system discussed in Section III.B. 
The input to the system is a sentence, which is preprocessed by a 
lexical analyzer. Parsing is performed by a simple recursive descent 
parser, augmented to add annotations to the nodes of the parse tree. 
Translation is then done in a separate pass over the annotated parse 
tree. Thus the four conceptual phases are implemented as three actual 
processing phases. This folding of two phases into one was done purely 
for reasons of efficiency and has no effect on the actual results obtained 
by the system. Functions to perform the storage manipulation, gap 
handling, and the other features of translation presented earlier have 
all been realized in the translation component of the running system. 
The next section describes an actual grammar that has been used in 
conjunction with this translation system. 
III EXPERIMENTS IN PRODUCING AND US ING 
LOGICAL  FORM 
A A Work ing  Grammar  
To illustrate the ease with which diverse semantic features 
could be handled, a grammar was written that defines a semantically 
interesting fragment of English along with its translation into logical 
form \[Moore, 1981\]. The grammar for the fragment illustrated in this 
dialogue is compact occupying only a few pages, yet it gives both syntax 
and semantics for modais, tense, aspect, passives, and lexically control- 
led infinitival complements. (A portion of the grammar is included 
as Appendix A.) 4 The full test grammar, Io,~ely based on DIAGRAM 
\[Robinson, 1982\] but restricted and modified to reflect changes in a~ 
proach, was the grammar used to specify the translations of the sen- 
tences in the sample dialogue of Appendix C. 
B An  Example  of  the  System's  Operat ion  
The grammar presented in Appendix A encodes a relation 
between sentences and expressions in logical form. We now present a
sample of this relation, as well as its derivation, with a sample sentence: 
"Every man persuaded a woman to go." 
Lexical analysis relates the sample sentence to two morpheme 
streams: 
every man &ppi persuade a woman to go 
4Since this is just a small portion of the actual grammar selected for expository 
purposes, many of the phrasal categories and annotations will seem unmotivated 
and needlessly complex. These categories and annotations m'e utilized elsewhere 
in the test grammar. 
*, every man ,~past persuade a woman to go. 
The first is immediately eliminated because there is no context-free 
parse for it in the grammar. The second, however, is parsed as 
\[S (SDEC (NP (DETP (DDET (VET every))) 
C~u CN0m~V (SOUN Cs re,a))))) 
(Pn~ICar~ (*u~ (TE~E kpaat)) 
(VPP (V? CV?T (Vpersuado))) 
(~ (DET? CA a)) 
(~u (Nnm~ (~vtm CN womm))))) 
(INFINITIVE (TO to) 
CV~ Cv? CWT CV go\] 
While parsing is being done, annotations are added to each 
node of the parse tree. For instance, the NP -* DETP NOM rule 
includes the annotation rule AGREE( NP, DETP, Definite ). AGREE 
is one of a set of macros defined for the convenience of the grammar 
writer. This particular macro invocation is equivalent to the Boolean 
expression Definite(NP) ~ Definite(DETP). Since the DETP node itself 
has the annotation Definite as a result of the preceding annotation 
process, the NP node now gets the annotation Definite as wello At 
the bottom level, the Definite annotation was derived from the lexical 
entry for the word "evesy'. s The whole parse tree receives the following 
annotation: 
\[S Cb'~O (lqP: Delinite 
(DETP: DeBnite 
CDDET: DeBnite 
(DET: DeBuite 
eve1"y) ) ) 
CNOU (stump CNO~ CSm~))))) 
CPR~ICATE CAU~ CTENSE ~put)) 
(VPP CVP: Active 
(VPT: Active, Ttansitlve, Takesln? 
(V: Active, Transitive, Takesfn\[ 
porsuade) ) 
0~' (DET? CA a) ) 
CNOU C~la'~ C~ml C~ ,,on~))))) 
CDr~ISZTZ'W (TO to) 
(vPP (w: Active 
(VPT: Active 
Cv: Active 
sol 
Finally, the entire annotated parse tree is traversed to assign 
translations to the nodes through adirect implementation f the process 
described in Section II.C. (Type A and B objects in the following 
examples are marked with a prefix 'A:' or 'B:'.) For instance, the 
VP node covering (persuade a woman to go), has the translation rule 
VPT'\[N'P'\]\[INFINITIVE'\]. When this is applied to the translations of 
the node's constituents, we have 
CA: CA X CA P (~ T (persuade ? X (P X)))~ 
\[,CA: X2. ~,. C~ S (some X2 Cwomu X2) S))~\] 
\[cA: (~x C~x))~\] 
which, after the appropriate applications are performed, yields 
CA: CAP (~Y (persuade YX2 CPX2)))). ~, 
(A S (some X2 (~-  X2) S))~ 
5Note that, although the annotation phase was described and is implemented pro- 
cedurally, the process actually used guarantees that the resulting annotation is
ex" "t|y the one specified eclaratlve~y by the annotation rules. 
\[o,: (A x (gox))>\] 
= CA: ()/? (persuadeTX2 (goX2))). ~b, 
CA S (some X2 (roman X2) S))~ 
After the past operator has been applied, we have 
<A: CA T (pant (persumde YX2 (goX2)))). ~b, 
CA S (some X2 (~znu X2) S))) 
At this point, the pull operator (pull.v) can be used to bring the 
quantifier out of storage, yielding 6 
<A: CA Y (some ~2 (womb \]\[2) (pant (peramado T~ (go Yg))))). 
This will ultimately result in "a woman" getting narrow scope. The 
other alternative is for the quantifier to remain in storage, to be pulled 
only at the full sentence l vel, resulting in the other scoping. In Figure 
2, we have added the translations to all the nodes of the parse tree. 
Nodes with the same translations as their parents were left unmarked. 
From examination of the S node translations, the original sentence is
given the fully-scoped translations 
(every X2 (man \](2) 
(some Xi (woman Xi) (paSt (persuade %,9 X! (go Xl) ) ) ) )  
and 
(some XI (vo~ Xl) 
(every X~2 (nan X2) (pant (persuade X2 Xl (go Xl) ))) ) 
C A Simple Question-Answering System 
As mentioned in Section I, we were able to demonstrate he 
semantic apabilities of our language system by assembling a small 
question-answering system. Our strategy was to first translate English 
into logical formulas of the type discussed in \[Moore, 1981\], which 
were then postprocessed into a form suitable for a first-order deduc- 
tion system. 7 (Another possible approach would have been to translate 
directly into first-order logic, or to develop direct proof procedures for 
the non-first-order language.) Thus, we were able to integrate all the 
components into a question-answering system by providing a simple 
control structure that accepted an input, translated it into logical form, 
reduced the translation to first-order logic, and then either asserted the 
translation i the case of declarative s ntences orattempted toprove it 
in the case of interrogatives. (Only yes/no questions have been imple- 
mented.) 
The main point of interest is that our question-answering 
system was able to handle complex semantic entailments involving 
tense, modality, and so on--that, moreover, it was not restricted to 
extensional evMuation in a data base, as with conventional question- 
answering systems. For example, our system was able to handle the 
entailments of sentences like 
John could not have been persuaded to go. 
(The transcript of a sample dialogue is included as Appendix C.) 
6For convenience, when a final constituent o1'a translation is ~ it is often not 
written. Thus we could have written <A: (k Y (some ...) ...)> in this cue. 
7We used a connection graph theorem prover written by Mark Stickel \[Stlckel, 
forthcoming\]. 
(S: <A: (pant (persuade XI X2 (go ~))). ~. 
(A S (every X1 (nan X1) S)) 
()~ S (some ~ (veto \]\[2) S))>, 
<A: (some \]\[2 (~man X2) (past Cpersua4e X1 Y,2 (go Yo)))) 0 ~. 
(~ 8 (every Zl (man \]\[I) S))> 
<A: (everyX2 CnanX2) 
(some XI (woman X1) (pant (persuade X2 Xl (go Y~)) )))> 
cA: (sou Xl (wuan X1) 
(every \]\[2 (man X2) (pant (p0rsuade X2 l i  (go \]\[2))  ) > 
(SV~ 
(NP: <A: Xl. ~. (A S (everyXl (muXl)S))) 
CDKTP: ?~: CA P (~ S (every X (PI) S))). 
X~ 
(DDET (DET every))) 
(NDU: cA: CA X (man X))) 
(None (Nmm (x m~n))))) 
(PREDICATE: <A: (AX (past (persuade YX2 (goX2)))). ~b. 
CA S (some X2 (woma X2) S))), 
<X: CA X (son X2 (woeanX2) 
(pant (persuade YX2 (goX2))))). 
(AU~P: o,: CA P CA X (pant (P x))))> 
C'X '~ a~,,.t)) 
(VPP: <A: (A ? (persuade ? \]\[2 (go \]\[2))). ~b. 
CA S (some X2 (wn--X2) S))~ 
(VP (VPT: cA: (XX 
CA P 
()~ Y (persuade ?X (P ?)))) 
(V persuade))) 
(~: cA: X2. ~, CA S (someX2 (wona Z2) S))~ 
(DETP: <S: (kP (AS (SoNX (PX) S))). 
X~ 
CA n)) 
(~li: (A: (XX (wommX))> 
(N0~ (N0uw (w ,mm~))))) 
(INFINITIVE (TO: none 
to) 
(VPP: ca: (>,X (goX))> 
(w (vPT (v so\] 
Figure 2:. Node-by-node translation of a sample sentence 
The reduction of logical form to first-order logic (FOL) was 
parameterized by a set of recursive xpansions for the syntactic ele- 
ments of logical form in a manner similar to Moore's use of an 
sxiomatization of a modal anguage of belief. \[Moore, 1980\] For ex- 
ample, (past P) is expanded, with respect to a possible world w, as 
(some w2 (and (past w2 w) <P,w2>)) 
where "<P,w2>" denotes the recursive FOL reduction of P relative 
to the world w2. The logical form that was derived for the sample 
sentence "John went ~ therefore reduces to the first-order sentence 
(some w (and (past w REALWORLD)(go w John))). 
More complicated illustrations of the results of translation and reduc- 
tion are shown in Figure 3. Note, for example, the use of restricted 
quantification i LF and ordinary quantification i  FOL. 
To compute the correct semantic entailments, the deduction 
system was preloaded with a set of meaning postulates (axioms) giving 
inferential substance tothe predicates a sociated with lexical items (see 
IMrffT: every ntanus~ be happy 
iF: (everyX (m X) 
(tacosnry (tad (happy X) 
(thlngX)))) 
FOL: (every x0172 
(implies (mtuREALWORLDxOI72) 
(overywO173 
(implies (posnBEALgORLD~173) 
(tad (happy~O175zOt72) 
(~h i~Ot73z0172) ) ) ) ) )  
II~UT: b i l l  persuaded john to go 
iF: (ptat (porsutde b i l l  john (go john))) 
FOL: (some s0175 
(ud  (pant w0175 RF..AL|QP.LD) 
(sou wOrTS 
(Imd (permaade w0175 bill John wOlT?) 
(go wOlTe John))))) 
Figure 3: Translation to LF and Reduction to FOL 
Appendix B). 
IV FURTHER EXTENSIONS 
We are continuing to refine the grammar formalism and im- 
prove the implementation. Some of the refinements are intended to 
make the annotations and translations easier to write. Examples in- 
clude: 
Allowing nonbinary features, including sets of values, in the 
annotations and guards (extending the language to include 
equality and set operations). 
Generalizing the language used to specify synthesis of logi- 
cal forms and developing a more uniform treatment of 
translation types. 
Generalizing the "gap* variable feature to handle ar- 
bitrary collections of designated variables by using an 
"environment" mechanism. This is useful in achieving a 
uniform treatment of free word order in verb complements 
and modifiers. 
In addition, we are working on extensions of the syntactic 
machinery, including phrase-linking grammars to handle displacement 
phenomena \[Peters, 1981\], and methods for generating the augmented 
phrase structure grammar through a metarule formalism similar to 
that of \[Konolige, 1980\]. We have also experimented with alternative 
parsing algorithms, including a chart parser \[Bear, 197g\] adapted to 
carry out annotation and translation in the manner described in this 
paper. 
REFERENCES 
Bear, John, and Lanri Karttunen. PSG: A Simple Phrase Structure 
Parser. Texas Linguistic Forum, vol. 14. 1979. 
Cooper, Robin. Quantification and Syntactic Theory. Forthcoming. 
Reidel, Dordrecht. 
Gazdar, Gerald. Phrase Structure Grammar. To appear in Jacobsen, 
O. and G. K. Pullum (eds.) On the Nature of Syntactic 
Representation. 
Kaplan, R. M., and Martin Kay. Personal communication. 1981. 
Karttunen, Lauri, Rebecca Root, and Hans Uszkoreit. Morphological 
analysis of Finnish by computer. Paper presented at the ACL 
session of the 1981 LSA Annual Meeting, New York, December 
1981. 
Konolige, Karl. Capturing linguistic generalizations with metarules in 
an annotat.d phrase-structure grammar. Proceedings of the 18th 
Annual Meeting of the Association for Computational Linguistics, 
University of Pennsylvania, Philadelphia, June 1980. 
Moore, Robert C. Problems in Logical Form. Proceedings of the 19th 
Annual Meeting of the Association for Computational Linguistics, 
Stanford University, Pale Alto, June, 1981. 
Moore, Robert C. Reasoning About Knowledge and Action. SRI 
International, Technical Note 191. October, 1980. 
Peters, Stanley, and Robert W. Ritchie. Phrase Linking Grammars. 
December 1981. Unpublished manuscript. 
Robinson, Jane. DIAGRAM: A Grammar for Dialogues? 
Communications of the ACM, ~5:1 (January, 1982) 27--47. 
Stickel, Mark. A Non-Clausal Connection Graph Resolution Theorem 
Proving Program. Forthcoming. 
APPENDIX  A. Sample  Grammar  Rules 
The following is a portion of a test grammar for the PATR 
English translation system. Only those portions of the grammar uti- 
lized in analyzing the sample sentences in the text were included. 
The full grammar handles the following constructs: medals, adjec- 
rivals, tense, predicative and nonpredicative copulatives, adverbials, 
quantified noun phrases, aspect, NP, PP, and infinitival complements, 
relative clauses, yes/no questions, restricted wh-questions, noun-noun 
compounds, passives, and prepositional phrases as predicates and ad* 
jectivals. 
a~smf f iamumam GrlmlN, r h les  ?.m~ . . . .  ~mssmtm 
Cone~mt EQ' ? curry (X,,AIIBDA (X ?) (equal X ?)) 
Coast&at PASS' 8 
<A: (LA~DA P (LAIEDA X ((P X) T))). NIL, 
(IIX.IIBD (QUOTE (LAIIBDA S (some T (thing Y) S)))) > 
Constant PhSSIIF' ? 
<A: (LAM~)A P (LAMBDA I (~& x (((P x) I) ?)))) .  NIL, 
(MI(.MBD (QUOTE (IAMBDA S Csome ? (thing ?) S)))) > 
AUXP-> TENSE; 
Trtaslation: 
TENSE' 
DDET -> DET: 
Annotation: 
\[ Defiaite(DDET) \] 
Trtaslation: 
DET' 
DETP -> A; 
Annotation: 
\[ ~Definite(DETP) \]
Translation: 
A' 
DETP -> DDET; 
Annotation: 
\[ AGREE(DET?. DDET, Definite) \] 
Translation: 
DDET' 
II~INITIV~ -~ TO VPP; 
Annotation: 
\[ AGREECINFINITIVE. VPP, G*ppy. |h) \] 
Translation: 
pull.v(VPP') 
NON -> NO~qD; 
Annotation: 
\[ AOREE(NOM. NOMHD. O~ppy) \] 
Translation: 
NON~ID' 
NOMHD -) NOUN; 
Translation: 
NOUN' 
NOUN -> N; 
Translation: 
N' 
NP -) DE?P ~M; 
Annotation: 
\[ AOP~CNP. NOM. Gappy) \] 
\[ Predicative(NP) %/ ~Predicative(NP) \]
\[AGREE(N~. DETP, Definite) \] 
Translation: 
~Predica~ive(~): DET~'\[NOM'\] 
Definite(NP) A Predicative(NP): E~'\[DETP'\[NQM'\]\] 
~Definite(NP) ? Predicative(NP): NON' 
PREDICATE -> AU\]~ ~;  
Annotation: 
\[ AORE~(PREDICATE. VPP. Active. 0appy. ~h) \] 
Translation : 
pull.v(A~' \[VPP'\]) 
S -) SDEC; 
Annotation: 
\[ ~Oappy(.~'~EC) \] 
\[ ~(~EC)  \] 
Translation : 
SDEC' 
&DEC -) NP PREDICATE; 
Annotation: 
\[ 0appy(NP) V Gappy(I~DICATE) ?-) G~ppy(S)EC) \]
\[ ~Predicative(NP) \]
\[ |h(N~) ~/ |b(PREDICATE) <=> Wb(SDEC) \] 
\[ - (Onppy (NP) a Onppy (PKEDICATE)) \] 
Trus lat ion:  
pull.s(PR~DICATE'\[NP'\]) 
VP - ,  VPT; 
Annotation: 
\[ ~TrLnsitive(VPT) \] 
\[-TLkeelnZCV~T) \] 
\[ Active(VPT) \] 
\[ ActiveCVP) \] 
Translation: 
VPT' 
VP -> VPT NP I~FINITIVE; 
Annotation: 
\[ Takeslnf(VPT) \] 
\[ Transitive(VPT) \] 
\[ ~P~,dicativ,(~) \] 
\[ AOP~:~(~. VPT. Active) \] 
\[ Wh(NP) %/ Wh(INFmITIW) ~-* Wh(VP) \] 
\[ IY(lctive(VPT). 
((O&ppy(~) ~/ Oappy(~INITIVE)) ,=) Sappy(%~D)), 
(~Oappy(~T) k Oappy(NP))) \] 
Truslation: 
Active(%?): pulI.v(%~OT?\[NP '\] \[I~INITI~'\]) 
~Active(VP): pul l .v(P~Sl~'~T'\]  \[INFINITIVE'\]) 
V~ -~ VP; 
Annotation: 
\[ a~(v l~.  VP, Gappy. |h)  \] 
\[ Active(VP) \] 
Translation: 
VP' 
VPT -> V; 
Annotation: 
\[ AOREE(VPT. V. Active. Transitive. T~kenInf) \] 
Trsnslatlon: 
V' 
N -> nan: 
Translation: 
?a: mum, NIL, NIL ) 
Translation : 
?A: ~man. NIL, NIL ) 
DET -) every: 
Annotation: 
\[ Definite(DET) \] 
Translation: 
(B: (LAI~A P (LAMBDA S (every X (P X) S))).  X. NIL ? 
A -~ &; 
Translation: 
~B: (IA~mDA P (~DA S (some X (P X) S))). X, NIL ? 
V -~ persuade; 
Annotat ion: 
\[ Trans i t ive(V)  \] 
\[ Active(V) ~/ ~Active(V) \] 
\[ TLkeslnf(V) \] 
T rans la t ion :  
curry (LAIfBDA (X P Y) (persuade Y l (P X))) 
V -> go; 
Annotat ion: 
\[ ~Tranei t ive(V)  \] 
\[ -TskesZ~CV) \] 
\[ ActiveCV) \] 
T rans la t ion :  
<A: go, NIL. NIL 
TENSE -> &past; 
T rans la t ion :  
curry (LAI~A (P X) (past  ~ X))) 
APPENDIX B. Meaning Postulates 
(every ? (every u ( i f f  (pant ? u) 
( .o r  (put  u ?\] 
(eTery ? (some u (put  ? U))) 
\[every ? (every ? (every y (every z ( impl ies  (promise ? ? y z) 
(put  ? z\] 
\[every ? (every ? (every y (every z ( impl ies  (persuade ? ? y z) 
(pant ? z\] 
(every ? (every ? ( th ing ? x) ) )  
\[every ? (every x (every z ( impl ies  (want ? s z) 
(put  ? z\] 
(every ? (pose ? v)) 
\[every v (every u ( impl ies  (pant ? u) 
(pose ? u) 
\[every ? (every u (every v ( impl ies  (and (pant l  ? u) 
(pantl u v)) 
(pant2 ? v\] 
\[every ? (every z ( impl ies  (past2 ? z) 
(pant ? z\] 
\[every v (every z ( i f !  (past  ? z) 
(put l ?  z\] 
~ is john a happy man 
Yes. 
? > no man could have hidden a book 
OK. 
>) did john hide a book 
No. 
>~ bill hid a book 
OK. 
? ~ is b i l l  a man 
No. 
~> ww john a sum 
I don't know. 
>> every ?an ? i l l  be a nan 
OK. 
>) ? i l l  j oh ?be  ? nan 
Yes. 
~, b i l l  persuaded john to go 
OK. 
? > could john have been persuaded to p 
Yes. 
>> ? i l l  john be persuaded to go 
I don ' t  knee. 
APPENDIX C. Transcript of Sample Dialo~ue 
? ~ john is happy 
OK. 
~ i s  john happy 
Yes. 
>> is  john a happy mnn 
I don ' t  kno?. 
>> john is  a man 
nK. 
