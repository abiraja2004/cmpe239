LR Pa rse rs 
For Natural  Languages,  
Masaru  Tomita  
Computer Science Department 
Carnegie-Mellon University 
Pittsburgh, PA 15213 
Abstract  
MLR, an extended LR parser, is introduced, and its 
application to natural language parsing is discussed. 
An LR parser is a ~;hift-reduce parser which is 
doterministically guided by a parsing table. A parsing 
table can be obtained automatically from a context- 
free phrase structure grammar. LR parsers cannot 
manage antl)iguous grammars such as natural 
language grammars, because their I)arsing tables 
would have multiply-defined entries, which precludes 
deterministic parsing. MLR, however, can handle 
mulliply-defined entries, using a dynamic 
programnting method. When an input sentence is 
ambiguous, the MI.R parser produces all possible 
parse trees witftoul parsing any part of the input 
sentenc:e more than once in the same way, despite the 
fact that the parser does not maintain a chart as in 
chart par~ing. Our method also prnvkles an elegant 
solution to the problem of multi-part-of-speech words 
such as "that". The MLR parser and its parsing table 
generator have been implemented at Carnegie-Mellon 
University. 
1 Introduction 
LR parsers\[ I ,  2\] have been developed originally for 
programming language of compilers. An LR parser is a shift- 
reduce parser which is detenninistically guided by a par.~it~g table 
indicating what action should be taken next. The parsing table 
can be obtained automatically from a context-free phrase 
structure grammar, using an algorithm first developed by 
DeRemer \[5, 6\]. We do not describe the algorithm here, reffering 
the render to Chapter 6 in Aho and UIIman \[4\]. The LR parsers 
have seldom been used for Natural Language Processing 
probably because: 
1. It has been thought that natural languages are not 
context-free, whereas LR parsers can deal only with 
context-free languages. 
2. Natural languages are ambiguous, while standard LR 
parsers can not handle ambi~juous languages. 
The recent literature\[8\] shows that the belief "natural 
languages are not context-free" is not necessarily true, and there 
is no reason for us to give up the context-freedom of natural 
languages. We (to not discuss on this matter further, considering 
the fact that even if natural languages are not context-free, a 
fairly comprehensive grammar for a subset of natural language 
suflicient for practical systems can be written in context.free 
phrase structure. lhtJ.% our main concern is how to cope with the 
ambiguity of natural languages, and this concern is addressed in 
the fallowing section. 
2 LR parsers and Ambiguous Grammars  
If a given grammar is ambiguous? we cannot have a parsing 
table in which ~ve~y entry is uniquely defined; at lea~t one entry of 
it~ parsing table is inulliply defined. It has been thought that, for 
LR pa~sers, nndtiple entries are fatal because they make 
deterministic parsing no longer po~$ible. 
Aho et. al. \[3\] and Shieber\[121 coped with this ambiguity 
problem by statically 3 selecting one desired action out of multiple 
actions, and thus converting n=ulliply-defined entries into 
uniquely-defined ones.With this approach, every input sentence 
has no more than one parse tree. This fact is desirable for 
progralnming languages. 
For natural languages, however, it is sometimes necessary for a 
parser to produce more than one parse tree. For example, 
consider the following short story. 
I saw the man with a telescope. 
He should have bought it at the department store. 
When the first sentence is read, there is absolutely no way to 
resolve the ambiguity 4 at that time. The only action the system 
can take is to produce two parse trees and store them 
somewhere for later disambiguation. 
In contrast with Aho et. al. and Shieber, our approach is to 
extend LR parsers so that they can handle multiple entries and 
produce more than one parse tree if needed. We call the 
extended LR parsers MLR parsers. 
ll'his rP.~i:i'?l'Ctl was -~pon~oled by the Df.'ieose Advanced Research Projects 
Agency (DOD), ARPA Older No. 3597, munitoled hy lhe Air Foi'r:e Avionics 
Lot)oratory Under C, uolracl F3:)(~15 81 K-t539. The views and con,.;lusion$ 
conl,lii~cd i=1 lhi.~; (lo=;unlq;nt a~i.~ tho'.;e ()| tt1~.! ;iu|hor.~; alld should not be illlerpreted 
as n:pre.-',enling the official p(':licie:;, c, ilher expressed or implied, of the Defense 
Advanced Re,ql..';.trch Projects Ag4.tncy or the US Gow.~.rnnlent. 
2A grammar is ambiQuous, if some input sentence can be parsed in more than 
on~. W,gy, 
3By t'~tatically", we mean the ~..:election is done at par.~ing table construction 
time, 
4"1" have the telescope, or "the man" has the telescope. 
354 
3 MLR Parsers 
of different parses have in the chart parsing method \[10, 11\]. The 
idea should be made clear by the following example. 
An example grammar and its MLR parsing table produced by 
the construction algorithm are shown in fig. 1 and 2, respectively. 
The MLR parsing table construction algorithm is exactly the same 
as the algorithm for LR parsers. Only the difference is that an 
MLR parsing table may have multiple entries. Grammar symbols 
starting with ..... represent pre-terminals. "sh n" in the action 
table (the left part of the table) indicates the action "shift one 
word from input buffer onto the stack, and go to state n". "re n" 
indicates the action "reduce constituents on the stack using rule 
n". "acc" stands for tile action "accept", and blank spaces 
represent "error". Goto table (the right part of the table) decides 
to what state the parser should go af tera  reduce action. The 
exact definition and operation of LR parsers can be found in Aho 
and Ulhnan \[4\]. 
We can see that there are two multiple entries ir~ the table; on 
the rows of state t t  and 12 at the column of " 'prep".  As 
mentioned above, once a parsing table has multiple entries, 
deterministic parsing is no longer possible; some kind of non- 
determinism is necessary. We .~hali see that our dynamic 
programming approach, which is described below, is much more 
efficient than conventional breath-first or depth-first search, and 
makes MLR parsing feasible. 
4 An Example 
In this section, we demonstrate, step by step, how our MLR 
parser processes the sentence: 
I SAW A MAN WITH A TELESCOPE 
using the grammar and the parsing table shown in fig t and 2. 
This sentence is ambiguous, and the parser should accept the 
sentence in two ways. 
Until the system finds a multiple entry, it behaves in tile exact 
same manner as a conventional LR parser, as shown in fig 3-a 
below. The number on the top (ri.qhtmost) of the stack indicates 
the current state. Initially, the current state is 0. Since the parser 
is looking at the word "1", whose category is "*n",  the next action 
"shift and goto state 4" is determined from the parsing table. "\]he. 
parser takes the word "1" away from the input buffer, and pushes 
the preterminal "*n" onto tile stack. The next word the parser is 
looking at is "SAW", whose category is " 'v " ,  and "reduce using 
rule 3" is determined as the next action. After reducing, the 
parser determines the current state, 2, by looking at the 
intersection of the row of state 0 and the column of "NP ?', and so 
on. 
Our approach is basically pseudo-parallelism (breath-first 
search). When a process encounters a multiple entry with n 
different actions, the process is split into n processes, and they 
are executed individually and parallelly. Each process is 
continued until either an "error" or an "accept" action is found. 
The processes are, however, synchronized in the following way: 
When a process "shifts" a word, it waits until all other processes 
"shift" the word. Intuitively, all processes always look at the 
same word. After all processes shift a word, the system may find 
that two or more processes are in the ~lnle state; that is, some 
processes have a common state number on the top of their 
stacks. These processes would do the exactly same thing until 
that common state number is popped from their stacks by some 
"reduce" action. In our parser, this common part is processed 
only once. As soon as two or more processes in a common state 
are found, they are combined into one process. This combining 
mechanism guarantees that any part of an input sentence is 
parsed no more than once in the same manner." This makes the 
parsing much more efficient than simple breath-first or depth-first 
search. Our method has the same effect in terms of parsing 
efficiency that posting and recognizing common subconstituents 
STACK MrXT-ACI  ION NEXT-WORD 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
0 sh 4 \[ 
0 =n 4 re 3 SAW 
0 NP Z sh 7 SAW 
0 NP 2 "v  7 sh 3 A 
0 NP 2 ev 7 =det. 3 sh IO MAN 
0 NP 2 Ov 7 O?let, 3 en tO re 4 WITH 
0 NP 2 =v 7 NP tZ re 7, sh 6 WI \ [ I I  
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  .: . . . . . . . . . . . . . . . . . . . . . . .  
Fig 3oa 
At this point, tile system finds a multiple entry with two different 
actions, "reduce 7" and ".3hilt g". Both actions are processed in 
parallel, as shown in fig 3-b. 
S ta te  *det  *n *v "prep $ NP PP VP S 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
sh3 sh4 2 t 
sh6 acc 5 
sh7 sh6 9 8 
sht0 
re3 re3 re3 
re2 re2 
sh3 sh4 11 
sh3 sh4 12 
0 
1 
. . . . . . . . . . . . . . . . . . . . . . . . . .  2 
( I )  S --> NP VP 3 
(2) S --> S PP 4 
(3 )  NP - ->  =n 5 
(4 )  NP - ->  *det  *n 6 
(5 )  NP - ->  NP PP 7 
(6 )  PP - ->  =prep NP 8 
(7 )  VP - ->  "v NP 9 
. . . . . . . . . . . . . . . . . . . . . . . . . .  10  
11 
12 
Fig 1 
re t  te l  
re5 re5 re5 
re4 re4 re4 
re6 re6 ,sh6  re6 9 
re7 ,sh6  re7 9 
Fig 2 
355 
0 NP 2 VP 8 re t W\[FII 
0 NP 2 *v 1 HI ) 12 *prep  6 wa i t  A 
0 S \[ sh 6 WI\[I I  
0 NP 2 "v l NP 12 "prep 6 wa i t  A 
This process is also finished by the action "accept".  The 
system has accepted the input sentence in both ways. It is 
important to note that any part of the input sentence, including 
the prepositional phrase "WITH A TELESCOPE", is parsed only 
once in the same way, without maintaining a chart. 
0 S I * l ) rep 6 sh 3 A 
0 NP Z *v 7 NP t2 "prep  6 sh 3 A 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
Fig 3-b 
Here, the system finds that both processes have the common 
state number, 6, on the top of their slacks. It combines two 
proces:;os into one, and operates as if there is only one process, 
as shown in fig 3-c. 
5 Another Example 
Some English words belong to more than one gramillatical 
category. When such a word is encountered, tile MLR parsing 
table can immediately tell which of its cutegories are legal and 
which are not. When more than one of its categories are legal, 
tile parser behaves as if a multiple entry were encountered. The 
idea should be'made clear by the following example. 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  e . . . . . . . . . . . . . . . . . . . . . . . .  
O S | III "p rep  6 sh 3 A 
0 HI' 2 "v 1 i'lP 12 4v  
0 S t "prep  13 "det  3 sh 10 TELESCOPE 
0 MP 2 "v  7 NP t2 d#" 
0 S I I "p rep  6 "dot  3 "n )0 re 4 $ 
0 NP 2 "v  7 NP t2 alP" 
Consider the word "that" in the sentence: 
That information is important is doubtful. 
A ~3ample grammar and its parsing table are shown in Fig. 4 and 5, 
respectively. Initially, the parser is at state O. The first word 
"that" can be either " "det"  or "*that" ,  and the parsing table tells 
us that both categories are legal. Thus, the parser processes "sh 
5" and "sh 3" in parallel, as shown below. 
0 S ! j "prop G ~IP tt re 6 $ 
0 NP 2 "v 7 NP 12 ~ 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
STACK NEXI ACIION N\[XI WORD 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
0 sh 5, sh 3 I 'hat 
Fig 3-c 
The action "reduce 6" pops the common state number 6, and 
the system can no longer operate the two processes as one. The 
two processes are, again, operated in parallel, as shown in fig 
3-d. 
0 S I PP 5 re 2 $ 
0 NP 2 =v 7 NP 12 PP 9 re 5 $ 
0 S \[ accept 
0 NP 2 *v 7 NP 12 re 7 $ 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
Fig 3-d  
NOW, one of the two processes is finished by the action 
"accept".  The other process is still continued, as shown in fig 
3-e. 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
0 NP 2 VP 8 re t $ 
0 S t accept 
0 sh 5 Fhat  
0 sh 3 That  
0 *det  5 sh 9 i n fo rmat ion  
0 " that  3 sh 4 in fo rmat ion  
0 *det  5 *n 9 re 2 is  
0 * that  3 *n 4 re 3 is  
0 NP 2 sh 6 Is 
0 =that  3 NP 2 sh 6 is 
Fig. 6-a  
At this point, the parser founds that both processes are in the 
same state, namely state 2, and they are combined as one 
process. 
Fig 3-e 
0 
(1 )  S - ->  NP VP 2 
(2)  NP - ->  "det *n 3 
(3 )  NP - ->  "n 4 
(4)  NP - - )  * that  S 5 
(5 )  VP - ->  "be "adj  6 
. . . . . . . . . . . . . . . . . . . . . . . . .  7 
8 
9 
Fig. 4 10 
State  *ad j  "be  "det  *n * that  $ NP S VP 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
sh5 sh4 sh3 2 1 
acc 
sh6 7 
sh5 sh4 sh3 2 8 
re3  
sh9 
shlO 
re1 re1 
re4  
re2 
re5 re5  
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
Fig. 5 
356 
00 *t at 3 NP G M P h  q~ml~a'~P 2 sh 6 iS 
0 NP ~ Z  *he 6 sh 10 important  
0 " that  3 NP 
0 NPh=mmmm~2 "be 6 " .d  j . t  at 3 NP f tO re 5 1, 
o 
0 N P ~ 2  VP 7 re t |s 
0 " that  3 NP- 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
Fig. 6- b 
The process is split into two processes again. 
0 ~IP 2 VP 7 re I i$ 
0 * that  3 NP 2 VP 7 re 1 1=1 
0 5 1 #ERRORI t l  
0 "thor 3 $ 8 re 4 is 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
Fig. 6-?  ? 
One of two processes detects "error" and halts; only the other 
process goes on. 
0 NP 2 sh 6 t= 
0 NP 2 *he 6 sh tO doubtful  
0 ~JP Z "be 6 "adJ tO re 5 $ 
0 .P 2 vP 7 re 1 $ 
0 s I ace $ 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
Fig. 6-d 
Finally, the sentence has been parsed in only one way. We 
emphasize again that, "in spite of pseudo-parallelism, each part of 
the sentence was parsed only once in the same way. 
6 Conc lud ing  Remarks  
The MLR parser and its parsing table generator have been 
implemented at Computer Science Department, Carnegie.Mellon 
University. The system is written in MACLISP and running on 
Tops-20. 
One good feature of an MLR parser (and of an LR parser) is 
that, even if the parser is to run on a small computer, the 
construction of the parsing table can be done on more powerful, 
larger computers. Once a parsing table is constructed, the 
execution time for parsing depends weakly on the number of 
productions or symbols in a grammar. Also, in spite of pseudo. 
parallelism, our MLR parsing is theoretically still deterministic. 
This is because the number of processes in our pseudo. 
parallelism never exceeds the number of states in the parsing 
table. 
One concern of our parser is whether the size of a parsing table 
remains tractable as the size of a grammar grows. Fig. 6 shows 
the relationship between the complexity of a grammar and its LR 
parsing table (excerpt from Inoue \[9\]). 
XPL EULER FORTRAN ALGOL60 
Termina ls  47 74 63 66 
Non- termina l  s 51 45 77 99 
Product  ions 108 121 172 205 
Sta tes  180 t93 322 337 
Tab leS ize(byte)  2041 2587 3662 4264 
Fig. 6 
Although the example grammars above are for programming 
langauges, it seems that the size of a parsing table grows only in 
proportion to the size of its grammar and does not grow rapidly. 
Therefore, there is a hope that our MLR parsers can manage 
grammars with thousands of phrase structure rules, which would 
be generated by rule-schema and meta-rules for natural language 
in systems such as GPSG \[7\]. 
Acknowledgements 
I would like to thank Takehiro Tokuda, Osamu 
Watanabe, Jaime Carbonell and Herb Simon for 
thoughtful comments on an earlier version of this 
paper. 
References 
\[1\] Aho, A. V. and Ullman, J. D. 
The Theory of Parsing, Translation and Compiling. 
Prentice-Hall, Englewood Cliffs, N. J., 1972. 
\[2\] AhO, A. V. and Johnson, S. C. 
LR parsing. 
ComPuting Surveys 6:2:99-124, 1974. 
\[3\] Aho, A. V., Johnson, S. C. and UIIman, J. D. 
Deterministic parsing of ambiguous grammars. 
Comm. ACM 18:8:441-452, 1975. 
\[4\] Aho, A. V. and UIIman, J. D. 
Principles of Compiler Design. 
Addison Wesley, 1977. 
\[5\] Oeremer, F. L 
Practical Translators for LR(k) Languages. 
PhD thesis, MIT, 1969. 
\[6\] DeRemer, F. L. 
Simple LR(k) grammars. 
Comm. ACM 14:7:453-460, 1971. 
FI Gazdar, G. 
Phrase Structure Grammar. 
D. Reid,l, 1982, pages 131.186. 
\[8\] G=zder, G. 
Phrase Structure Grammars and Natural Language. 
Proceedings of the Eighth International Joint Conference 
on Artificial Intelligence v.1, August, 1983. 
\[9\] Inoue, K. and Fujiwara, F, 
On LLC(k) Parsing Method of LR(k) Grammars. 
Journal of Inlormation Processing vol.6(no.4):pp.206-217, 
1983. 
\[10\] Kapisn, R. M. 
A general syntactic processor. 
Algorithmics Press, New York, 1973, pages 193.241. 
\[1~\] Kay, M. 
The MIND system. 
Algorithmics Press, New York, 1973, pages 155-188. 
\[12\] Shieber, S. M. 
Sentence Disambiguation by a ShiR-Reduce Parsing 
Technique. 
Proceedings of the Eighth International Joint Conference 
on Artificial Intelligence v.2, August, 1983. 
357 
