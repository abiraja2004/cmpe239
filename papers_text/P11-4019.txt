Proceedings of the ACL-HLT 2011 System Demonstrations, pages 109?114,
Portland, Oregon, USA, 21 June 2011. c?2011 Association for Computational Linguistics
SystemT: A Declarative Information Extraction System
Yunyao Li
IBM Research - Almaden
650 Harry Road
San Jose, CA 95120
yunyaoli@us.ibm.com
Frederick R. Reiss
IBM Research - Almaden
650 Harry Road
San Jose, CA 95120
frreiss@us.ibm.com
Laura Chiticariu
IBM Research - Almaden
650 Harry Road
San Jose, CA 95120
chiti@us.ibm.com
Abstract
Emerging text-intensive enterprise applica-
tions such as social analytics and semantic
search pose new challenges of scalability and
usability to Information Extraction (IE) sys-
tems. This paper presents SystemT, a declar-
ative IE system that addresses these challenges
and has been deployed in a wide range of en-
terprise applications. SystemT facilitates the
development of high quality complex annota-
tors by providing a highly expressive language
and an advanced development environment.
It also includes a cost-based optimizer and a
high-performance, flexible runtime with mini-
mummemory footprint. We present SystemT
as a useful resource that is freely available,
and as an opportunity to promote research in
building scalable and usable IE systems.
1 Introduction
Information extraction (IE) refers to the extraction
of structured information from text documents. In
recent years, text analytics have become the driv-
ing force for many emerging enterprise applications
such as compliance and data redaction. In addition,
the inclusion of text has also been increasingly im-
portant for many traditional enterprise applications
such as business intelligence. Not surprisingly, the
use of information extraction has dramatically in-
creased within the enterprise over the years. While
the traditional requirement of extraction quality re-
mains critical, enterprise applications pose several
two challenges to IE systems:
1.Scalability: Enterprise applications operate
over large volumes of data, often orders of
magnitude larger than classical IE corpora. An
IE system should be able to operate at those
scales without compromising its execution ef-
ficiency or memory consumption.
2.Usability: Building an accurate IE system is
an inherently labor intensive process. There-
fore, the usability of an enterprise IE system in
terms of ease of development and maintenance
is crucial for ensuring healthy product cycle
and timely handling of customer complains.
Traditionally, IE systems have been built from in-
dividual extraction components consisting of rules
or machine learning models. These individual com-
ponents are then connected procedurally in a pro-
gramming language such as C++, Perl or Java. Such
procedural logic towards IE cannot meet the increas-
ing scalability and usability requirements in the en-
terprise (Doan et al, 2006; Chiticariu et al, 2010a).
Three decades ago, the database community faced
similar scalability and expressivity challenges in
accessing structured information. The community
addressed these problems by introducing a rela-
tional algebra formalism and an associated declar-
ative query language SQL. Borrowing ideas from
the database community, several systems (Doan and
others, 2008; Bohannon and others, 2008; Jain et al,
2009; Krishnamurthy et al, 2008; Wang et al, 2010)
have been built in recent years taking an alternative
declarative approach to information extraction. In-
stead of using procedural logic to implement the ex-
traction task, declarative IE systems separate the de-
scription of what to extract from how to extract it,
allowing the IE developer to build complex extrac-
109
Development Environment
Optimizer
Rules(XQL)
ExecutionEngine
SampleDocuments
RuntimeEnvironmentunti environ ent
InputDocumentStream
AnnotatedDocumentStream
Plan(Algebra)
UserInterface
Publish
Figure 1: Overview of SystemT
tion programs without worrying about performance
considerations.
In this demonstration, we showcase one such
declarative IE system called SystemT, designed
to address the scalability and usability challenges.
We illustrate how SystemT, currently deployed in
a multitude of real-world applications and com-
mercial products, can be used to develop and
maintain IE annotators for enterprise applica-
tions. A free version of SystemT is available at
http://www.alphaworks.ibm.com/tech/systemt.
2 Overview of SystemT
Figure 1 depicts the architecture of SystemT. The sys-
tem consists of two major components: the Development
Environment and the Runtime Environment. The Sys-
temT Development Environment supports the iterative
process of constructing and refining rules for information
extraction. The rules are specified in a declarative lan-
guage called AQL (F.Reiss et al, 2008). The Develop-
ment Environment provides facilities for executing rules
over a given corpus of representative documents and vi-
sualizing the results of the execution. Once a developer
is satisfied with the results that her rules produce on these
documents, she can publish her annotator.
Publishing an annotator is a two-step process. First,
given an AQL annotator, there can be many possible
graphs of operators, or execution plans, each of which
faithfully implements the semantics of the annotator.
Some of the execution plans are much more efficient than
others. The SystemT Optimizer explores the space of
the possible execution plans to choose the most efficient
one. This execution plan is then given to the SystemT
Runtime to instantiate the corresponding physical oper-
ators. Once the physical operators are instantiated, the
create view Phone asextract regex /\d{3}-\d{4}/ on D.text as numberfrom Document D;
create view Person asextract dictionary ?firstNames.dict? on D.text as namefrom Document D;
create view PersonPhoneAll asselect CombineSpans(P.name, Ph.number) as matchfrom Person P, Phone Phwhere FollowsTok(P.name, Ph.number, 0, 5);
create view PersonPhone asselect R.name as namefrom PersonPhoneAll Rconsolidate on R.name;
output view PersonPhone; 
Figure 2: An AQL program for a PersonPhone task.
SystemT Runtime feeds one document at a time through
the graph of physical operators and outputs a stream of
annotated documents.
The decoupling of the Development and Runtime en-
vironments is essential for the flexibility of the system. It
facilitates the incorporating of various sophisticated tools
to enable annotator development without sacrificing run-
time performance. Furthermore, the separation permits
the SystemT Runtime to be embedded into larger appli-
cations with minimum memory footprint. Next, we dis-
cuss individual components of SystemT in more details
(Sections 3 ? 6), and summarize our experience with the
system in a variety of enterprise applications (Section 7).
3 The Extraction Language
In SystemT, developers express an information extrac-
tion program using a language called AQL. AQL is a
declarative relational language similar in syntax to the
database language SQL, which was chosen as a basis for
our language due to its expressivity and familiarity. An
AQL program (or an AQL annotator) consists of a set of
AQL rules.
In this section, we describe the AQL language and
its underlying algebraic operators. In Section 4, we ex-
plain how the SystemT optimizer explores a large space
of possible execution plans for an AQL annotator and
chooses one that is most efficient.
3.1 AQL
Figure 2 illustrates a (very) simplistic annotator of rela-
tionships between persons and their phone number. At a
high-level, the annotator identifies person names using a
simple dictionary of first names, and phone numbers us-
ing a regular expression. It then identifies pairs of Person
and Phone annotations, where the latter follows the
110
former within 0 to 5 tokens, and marks the corre-
sponding region of text as a PersonPhoneAll annota-
tion. The final output PersonPhone is constructed by
removing overlapping PersonPhoneAll annotations.
AQL operates over a simple relational data model
with three data types: span, tuple, and view. In this
data model, a span is a region of text within a doc-
ument identified by its ?begin? and ?end? positions,
while a tuple is a list of spans of fixed size. A view
is a set of tuples. As can be seen from Figure 2,
each AQL rule defines a view. As such, a view is the
basic building block in AQL: it consists of a logical
description of a set of tuples in terms of the docu-
ment text, or the content of other views. The input
to the annotator is a special view called Document
containing a single tuple with the document text.
The AQL annotator tags some views as output views,
which specify the annotation types that are the final
results of the annotator.
The example in Figure 2 illustrates two of the
basic constructs of AQL. The extract statement
specifies basic character-level extraction primitives,
such as regular expressions or dictionaries (i.e.,
gazetteers), that are applied directly to the docu-
ment, or a region thereof. The select statement
is similar to the corresponding SQL statement, but
contains an additional consolidate on clause
for resolving overlapping annotations, along with an
extensive collection of text-specific predicates.
To keep rules compact, AQL also allows a short-
hand pattern notation similar to the syntax of the
CPSL grammar standard (Appelt and Onyshkevych,
1998). For example, the PersonPhoneAll view
in Figure 2 can also be expressed as shown below.
Internally, SystemT translates each of these extract
pattern statements into one or more select and ex-
tract statements.
create view PersonPhoneAll as
extract pattern
<P.name> <Token>{0,5} <Ph.number>
from Person P, Phone Ph;
SystemT has built-in multilingual support in-
cluding tokenization, part of speech and gazetteer
matching for over 20 languages using IBM Lan-
guageWare. Annotator developers can utilize the
multilingual support via AQLwithout having to con-
figure or manage any additional resources. In ad-
dition, AQL allows user-defined functions in a re-
firstNames.dict
DocumentInput Tuple
?I?ve seen John and Martin, ?
Output Tuple 2 Span 2Document Span 1Output Tuple 1 Document
Dictionary
Person
(?Anna?, ?John?, ?Martin?, ?)
Figure 3: Dictionary Extraction Operator
stricted context in order to support operations such
as validation or normalization. More details on AQL
can be found in the AQL manual (Chiticariu et al,
2010b).
3.2 Algebraic Operators in SystemT
SystemT executes AQL rules using graphs of op-
erators. These operators are based on an algebraic
formalism that is similar to the relational algebra
formalism, but with extensions for text processing.
Each operator in the algebra implements a single
basic atomic IE operation, producing and consum-
ing sets of tuples (i.e., views).
Fig. 3 illustrates the dictionary extraction operator
in the algebra, which performs character-level dic-
tionary matching. A full description of the 12 differ-
ent operators of the algebra can be found in (F.Reiss
et al, 2008). Three of the operators are listed below.
? The Extract operator (E) performs character-
level operations such as regular expression and
dictionary matching over text, producing one tu-
ple for each match.
? The Select operator (?) takes as input a set of
tuples and a predicate to apply to the tuples, and
outputs all tuples that satisfy the predicate.
? The Join operator (??) takes as input two sets of
tuples and a predicate to apply to pairs of tuples.
It outputs all pairs satisfying the predicate.
Other operators include PartOfSpeech for part-
of-speech detection, Consolidate for removing
overlapping annotations, Block and Group for
grouping together similar annotations occurring
within close proximity to each other, as well as ex-
pressing more general types of aggregation, Sort for
sorting, and Union and Minus for expressing set
union and set difference, respectively.
111
Person Phone
Plan BPlan A Find matches of Person, then discard matches that are not followed by a Phone
? ??dict
Find matches of Person and Phone, then identify pairs that are within 0 to 5 tokens of each other
Plan CFind matches of Phone, then discard matches that are not followed by a Person
?
?
regex
Figure 4: Execution strategies for PersonPhoneAll in
Fig. 2
4 The Optimizer
Grammar-based IE engines such as (Boguraev,
2003; Cunningham et al, 2000) place rigid restric-
tions on the order in which rules can be executed.
Such systems that implement the CPSL standard or
extensions of it must use a finite state transducer to
evaluate each level of the cascade with one or more
left to right passes over the entire input token stream.
In contrast, SystemT uses a declarative approach
based on rules that specify what patterns to extract,
as opposed to how to extract them. In a declarative
IE system such as SystemT the specification of an
annotator is completely separate from its implemen-
tation. In particular, the system does not place ex-
plicit constraints on the order of rule evaluation, nor
does it require that intermediate results of an anno-
tator collapse to a fixed-size sequence.
As shown in Fig. 1, the SystemT engine does
not execute AQL directly; instead, the SystemT
Optimizer compiles AQL into a graph of operators.
Given a collection of AQL views, the optimizer gen-
erates a large number of different operator graphs,
all of which faithfully implement the semantics of
the original views. Even though these graphs always
produce the same results, the execution strategies
that they represent can have very different perfor-
mance characteristics. The optimizer incorporates
a cost model which, given an operator graph, esti-
mates the CPU time required to execute the graph
over an average document in the corpus. This cost
model allows the optimizer to estimate the cost of
each potential execution strategy and to choose the
one with the fastest predicted running time.
Fig. 4 presents three possible execution strategies
for the PersonPhoneAll rule in Fig. 2. If the opti-
mizer estimates that the evaluation cost of Person is
much lower than that of Phone, then it can determine
that Plan B has the lowest evaluation cost among
the three, because Plan B only evaluates Phone in
the ?right? neighborhood for each instance of Per-
son. More details of our algorithms for enumerating
plans can be found in (F.Reiss et al, 2008).
The optimizer in SystemT chooses the best exe-
cution plan from a large number of different algebra
graphs available. Depending on the execution plan
generated by the optimizer, SystemT may evaluate
views out of order, or it may skip evaluating some
views entirely. It may share work among views or
combine multiple equivalent views together. Even
within the context of a single view, the system can
choose among several different execution strategies
without affecting the semantics of the annotator.
This decoupling is possible because of the declar-
ative approach in SystemT, where the AQL rules
specify only what patterns to extract and not how to
extract them. Notice that many of these strategies
cannot be implemented using a transducer. In fact,
we have formally proven that within this large search
space, there generally exists an execution strategy
that implements the rule semantics far more effi-
ciently than the fastest transducer could (Chiticariu
et al, 2010b). This approach also allows for greater
rule expressivity, because the rule language is not
constrained by the need to compile to a finite state
transducer, as in traditional CPSL-based systems.
5 The Runtime
The SystemT Runtime is a compact, small memory
footprint, high-performance Java-based runtime en-
gine designed to be embedded in a larger system.
The runtime engine works in two steps. First, it
instantiates the physical operators in the compiled
operator graph generated by the optimizer. Second,
once the first step has been completed, the runtime
feeds documents through the operator graph one at a
time, producing annotations.
SystemT exposes a generic Java API for the inte-
gration of its runtime environment with other appli-
cations. Furthermore, SystemT provides two spe-
cific instantiations of the Java API: a UIMA API and
a Jaql function that allow the SystemT runtime to
be seamlessly embedded in applications using the
UIMA analytics framework (UIMA, 2010), or de-
ployed in a Hadoop-based environment. The latter
112
allows SystemT to be embedded as a Map job in a
map-reduce framework, thus enabling the system to
scale up and process large volumes of documents in
parallel.
5.1 Memory Consumption
Managing memory consumption is very important
in information extraction systems. Extracting struc-
tured information from unstructured text requires
generating and traversing large in-memory data
structures, and the size of these structures deter-
mines how large a document the system can process
with a given amount of memory.
Conventional rule-based IE systems cannot
garbage-collect their main-memory data structures
because the custom code embedded inside rules can
change these structures in arbitrary ways. As a re-
sult, the memory footprint of the rule engine grows
continuously throughout processing a given docu-
ment.
In SystemT, the AQL view definitions clearly
specify the data dependencies between rules. When
generating an execution plan for an AQL annota-
tor, the optimizer generates information about when
it is safe to discard a given set of intermediate re-
sults. The SystemT Runtime uses this information
to implement garbage collection based on reference-
counting. This garbage collection significantly re-
duces the system?s peak memory consumption, al-
lowing SystemT to handle much larger documents
than conventional IE systems.
6 The Development Environment
The SystemT Development Environment assists a
developer in the iterative process of developing,
testing, debugging and refining AQL rules. Be-
sides standard editor features present in any well-
respected IDE for programming languages such as
syntax highlighting, the Development Environment
also provides facilities for visualizing the results of
executing the rules over a sample document collec-
tion as well as explaining in detail the provenance of
any output annotation as the sequence of rules that
have been applied in generating that output.
7 Evaluation
As discussed in Section 1, our goal in building Sys-
temT was to address the scalability and usability
Application Type Type of Platform
brand management server-side
business insights server-side
client-side mashups client-side
compliance server-side
search (email, web, patent) server-side
security server-side
server-side mashups server-side
Table 1: Types of applications using SystemT
challenges posed by enterprise applications. As
such, our evaluation focuses on these two dimen-
sions.
7.1 Scalability
Table 1 presents a diverse set of enterprise applica-
tions currently using SystemT. SystemT has been
deployed in both client-side applications with strict
memory constraints, as well as on applications on
the cloud, where it can process petabytes of data
in parallel. The focus on scalability in the design
of SystemT is essential for its flexible execution
model. First of all, efficient execution plans are
generated automatically by the SystemT Optimizer
based on sample document collections. This en-
sures that the same annotator can be executed effi-
ciently for different types of document collections.
In fact, our previous experimental study shows that
the execution plan generated by the SystemT opti-
mizer can be 20 times or more faster than a manu-
ally constructed plan (F.Reiss et al, 2008). Further-
more, the Runtime Environment of SystemT results
in compact memory footprint and allows SystemT
to be embedded in applications with strict memory
requirements as small as 10MB.
In our recent study over several document col-
lections of different sizes, we found that for the
same set of extraction tasks, the SystemT through-
put is at least an order of magnitude higher than
that of a state-of-the-art grammar-based IE system,
with much lower memory footprint (Chiticariu et al,
2010b). The high throughput and low memory foot-
print of SystemT allows it to satisfy the scalability
requirement of enterprise applications.
7.2 Usability
Table 2 lists different types of annotators built us-
ing SystemT for a wide range of domains. Most,
113
Domain Sample Annotators Built
blog Sentiment, InformalReview
email ConferenceCall, Signature, Agenda, DrivingDirection, PersonPhone, PersonAddress, PersonEmailAddress
financial Merger, Acquisition, JointVenture, EarningsAnnouncement, AnalystEarningsEstimate, DirectorsOfficers, CorporateActions
generic Person, Location, Organization, PhoneNumber, EmailAddress, URL, Time, Date
healthcare Disease, Drug, ChemicalCompound
web Homepage, Geography, Title, Heading
Table 2: List of Sample Annotators Built Using SystemT for Different Domains
if not all, of these annotators are already deployed
in commercial products. The emphasis on usability
in the design of SystemT has been critical for its
successful deployment in various domains. First of
all, the declarative approach taken by SystemT al-
lows developers to build complex annotators without
worrying about performance. Secondly, the expres-
siveness of the AQL language has greatly eased the
burden of annotator developers when building com-
plex annotators, as complex semantics such as dupli-
cate elimination and aggregation can be expressed in
a concise fashion (Chiticariu et al, 2010b). Finally,
the Development Environment further facilitates an-
notator development, where the clean semantics of
AQL can be exploited to automatically construct ex-
planations of incorrect results to help a developer in
identifying specific parts of the annotator responsi-
ble for a given mistake. SystemT has been suc-
cessfully used by enterprise application developers
in building high quality complex annotators, without
requiring extensive training or background in natural
language processing.
8 Demonstration
This demonstration will present the core function-
alities of SystemT. In particular, we shall demon-
strate the iterative process of building and debug-
ging an annotator in the Development Environment.
We will then showcase the execution plan automati-
cally generated by the Optimizer based on a sample
document collection, and present the output of the
Runtime Environment using the execution plan. In
our demonstration we will first make use of a simple
annotator, as the one shown in Fig. 2, to illustrate
the main constructs of AQL. We will then showcase
the generic state-of-the-art SystemT Named Enti-
ties Annotator Library (Chiticariu et al, 2010c) to
illustrate the quality of annotators that can be built
in our system.
References
D. E. Appelt and B. Onyshkevych. 1998. The common
pattern specification language. In TIPSTER workshop.
B. Boguraev. 2003. Annotation-based finite state pro-
cessing in a large-scale nlp arhitecture. In RANLP.
P. Bohannon et al 2008. Purple SOX Extraction Man-
agement System. SIGMOD Record, 37(4):21?27.
L. Chiticariu, Y. Li, S. Raghavan, and F. Reiss. 2010a.
Enterprise information extraction: Recent develop-
ments and open challenges. In SIGMOD.
Laura Chiticariu, Rajasekar Krishnamurthy, Yunyao Li,
Sriram Raghavan, Frederick R. Reiss, and Shivaku-
mar Vaithyanathan. 2010b. Systemt: an algebraic ap-
proach to declarative information extraction. ACL.
Laura Chiticariu, Rajasekar Krishnamurthy, Yunyao
Li, Frederick Reiss, and Shivakumar Vaithyanathan.
2010c. Domain adaptation of rule-based annotators
for named-entity recognition tasks. EMNLP.
H. Cunningham, D. Maynard, and V. Tablan. 2000.
JAPE: a Java Annotation Patterns Engine (Second Edi-
tion). Research Memorandum CS?00?10, Department
of Computer Science, University of Sheffield.
A. Doan et al 2008. Information extraction challenges
in managing unstructured data. SIGMOD Record,
37(4):14?20.
A. Doan, R. Ramakrishnan, and S. Vaithyanathan. 2006.
Managing Information Extraction: State of the Art and
Research Directions. In SIGMOD.
F.Reiss, S. Raghavan, R. Krishnamurthy, H. Zhu, and
S. Vaithyanathan. 2008. An algebraic approach to
rule-based information extraction. In ICDE.
A. Jain, P. Ipeirotis, and L. Gravano. 2009. Building
query optimizers for information extraction: the sqout
project. SIGMOD Rec., 37:28?34.
R. Krishnamurthy, Y. Li, S. Raghavan, F. Reiss,
S. Vaithyanathan, and H. Zhu. 2008. SystemT: a sys-
tem for declarative information extraction. SIGMOD
Record, 37(4):7?13.
D. Z. Wang, E. Michelakis, M. J. Franklin, M. Garo-
falakis, and J. M. Hellerstein. 2010. Probabilistic
declarative information extraction. In ICDE.
114
