Pseudo-Projectivity: A Polynomially Parsable Non-Projective 
Dependency Grammar 
Sy lva in  Kahane*  and A lex is  Nasr  t and Owen Rambowt  
? TALANA Universit@ Paris 7 (sk0ccr .  juss ieu . f r )  
t LIA Universit@ d'Avignon (a lex is .  nasr?l ia ,  un iv -av ignon,  f r )  
:~CoGenTex, Inc. (owenOcogentex.com) 
1 In t roduct ion  
Dependency grammar has a long tradition 
in syntactic theory, dating back to at least 
Tesni~re's work from the thirties3 Recently, it 
has gained renewed attention as empirical meth- 
ods in parsing are discovering the importance 
of relations between words (see, e.g., (Collins, 
1997)), which is what dependency grammars 
model explicitly do, but context-free phrase- 
structure grammars do not. One problem that 
has posed an impediment to more wide-spread 
acceptance of dependency grammars i the fact 
that there is no computationally tractable ver- 
sion of dependency grammar which is not re- 
stricted to projective analyses. However, it is 
well known that there are some syntactic phe- 
nomena (such as wh-movement in English or 
clitic climbing in Romance) that require non- 
projective analyses. In this paper, we present 
a form of projectivity which we call pseudo- 
projectivity, and we present a generative string- 
rewriting formalism that can generate pseudo- 
projective analyses and which is polynomially 
parsable. 
The paper is structured as follows. In Sec- 
tion 2, we introduce our notion of pseudo- 
projectivity. We briefly review a previously pro- 
posed formalization of projective dependency 
grammars in Section 3. In Section 4, we extend 
this formalism to handle pseudo-projectivity. 
We informally present a parser in Section 5. 
2 L inear  and  Syntact i c  Order  of  a 
Sentence  
2.1 Some Notat ion  and Termino logy  
We will use the following terminology and no- 
tation in this paper. The hierarchical  o rder  
tThe work presented in this paper is collective and 
the order of authors is alphabetical. 
(dominance) between the nodes of a t ree T will 
be represented with the symbol _~T and T .  
Whenever they are unambiguous, the notations 
-< and _ will be used. When x -~ y, we will say 
that x is a descendent  ofy and y an ancestor  
of x. The pro ject ion  of a node x, belonging to 
a tree T, is the set of the nodes y of T such that 
y _T X. An arc between two nodes y and x of a 
tree T, directed from y to x will be noted either 
(y, x) or ~-. The node x will be referred to as 
the dependent  and y as the governor.  The 
latter will be noted, when convenient, x +T (x + 
when unambiguous). The notations ~2- and x + 
are unambiguous because a node x has at most 
one governor in a tree. As usual, an ordered 
t ree is a tree enriched with a linear order over 
the set of its nodes. Finally, if l is an arc of 
an ordered tree T, then Supp(1) represents he 
suppor t  of l, i.e. the set of the nodes of T 
situated between the extremities of l, extremi- 
ties included. We will say that the elements of 
Supp(1) are covered by I. 
2.2 P ro jec t iv i ty  
The notion of projectivity was introduced by 
(Lecerf, 1960) and has received several different 
definitions ince then. The definition given here 
is borrowed from (Marcus, 1965) and (Robin- 
son, 1970): 
Definit ion: An arc ~- is pro ject ive if and 
only if for every y covered by ~2-, y ~ x +. A 
tree T is pro ject ive  if and only if every arc of 
T is projective 
A projective tree has been represented in Fig- 
ure 1. 
A projective dependency tree can be associ- 
ated with a phrase structure tree whose con- 
stituents are the projections of the nodes of 
the dependency tree. Projectivity is therefore 
equivalent, in phrase structure markers, to con- 
646 
The big cat sometimes eats white mice 
Figure 1: A projective sub-categorization tree 
tinuity of constituent. 
The strong constraints introduced by the pro- 
jectivity property on the relationship between 
hierarchical order and linear order allow us to 
describe word order of a projective dependency 
tree at a local level: in order to describe the 
linear position of a node, it is sufficient o de- 
scribe its position towards its governor and sis- 
ter nodes. The domain of locality of the linear 
order rules is therefore limited to a subtree of 
depth equal to one. It can be noted that this do- 
main of locality is equal to the domain of local- 
ity of sub-categorization rules. Both rules can 
therefore be represented together as in (Gaif- 
man, 1965) or separately as will be proposed 
in 3. 
2.3 Pseudo-Pro jec t iv i ty  
Although most linguistic structures can be 
represented as projective trees, it is well known 
that projectivity is too strong a constraint for 
dependency trees, as shown by the example of 
Figure 2, which includes a non-projective arc 
(marked with a star). 
Who do you think she invited ? 
Figure 2: A non projective sub-categorization 
tree 
The non projective structures found in 
linguistics represent a small subset of the 
potential non projective structures. We will 
define a property (more exactly a family of 
properties), weaker than projectivity, called 
pseudo-pro jec t iv i ty ,  which describes a 
subset of the set of ordered dependency trees, 
containing the non-projective linguistic struc- 
tures. 
In order to define pseudo-projectivity, we in- 
troduce an operation on dependency trees called 
lifting. When applied to a tree, this operation 
leads to the creation of a second tree, a lift of 
the first one. An ordered tree T' is a lift of 
the ordered tree T if and only if T and T' have 
the same nodes in the same order and for ev- 
ery node x, x +T ..<T x+T'. We will say that the 
node x has been lifted from x +T (its syntact ic  
governor)  to x +T' (its l inear governor) .  
Recall that the linear position of a node in 
a projective tree can be defined relative to its 
governor and its sisters. In order to define the 
linear order in a non projective tree, we will 
use a projective lift of the tree. In this case, 
the position of a node can be defined only with 
regards to its governor and sisters in the lift, 
i.e., its linear governor and sisters. 
Def in i t ion:  An ordered tree T is said 
pseudo-pro jec t ive  if there exists a lift T' of 
tree T which is projective. 
If there is no restriction on the lifting, the 
previous definition is not very interesting since 
we can in fact take any non-projective tree and 
lift all nodes to the root node and obtain a pro- 
jective tree. 
We will therefore constrain the lifting by a 
set of rules, called lifting rules. Consider a set 
of (syntactic) categories. The following defini- 
tions make sense only for trees whose nodes are 
labeled with categories. 2 
The lifting rules are of the following form 
(LD, SG and LG are categories and w is a reg- 
ular expression on the set of categories): 
LD $ SG w LG (1) 
This rule says that a node of category LD 
can be lifted from its syntactic governor of cat- 
egory SG to its linear governor of category LG 
through a path consisting of nodes of category 
C1, . . . ,  Ca, where the string C1. . .  Cn belongs 
to L(w). Every set of lifting rules defines a par- 
ticular property of pseudo-projectivity b im- 
posing particular constraints on the lifting. A 
sit is possible to define pseudo-projectivity purely 
structurally (i.e. without referring to the labeling). For 
example, we can impose that each node x is lifted to 
the highest ancestor of x covered by ~2" ((Nasr, 1996)). 
The resulting pseudo-projectivity s a fairly weak exten- 
sion to projectivity, which nevertheless covers major non- 
projective linguistic structures. However, we do not pur- 
sue a purely structural definition of pseudo-projectivity 
in this paper. 
647 
linguistic example of lifting rule is given in Sec- 
tion 4. 
The idea of building a projective tree by 
means of lifting appears in (Kunze, 1968) and 
is used by (Hudson, 1990) and (Hudson, un- 
published). This idea can also be compared to 
the notion of word order domain (Reape, 1990; 
BrSker and Neuhaus, 1997), to the Slash feature 
of GPSG and HPSG, to the functional uncer- 
tainty of LFG, and to the Move-a of GB theory. 
3 P ro jec t ive  Dependency  Grammars  
Rev is i ted  
We (informally) define a projective Dependency 
Grammar as a string-rewriting system 3 by giv- 
ing a set of categories uch as N, V and Adv, 4 
a set of distinguished start categories (the root 
categories of well-formed trees), a mapping from 
strings to categories, and two types of rules: de- 
pendency  ru les  which state hierarchical order 
(dominance) and LP  ru les  which state linear 
order. The dependency rules are further sub- 
divided into subcategorization rules (or s-rules) 
and modification rules (or m-rules). Here are 
some sample s-rules: 
dl : Vtrans ) gnom, Nobj, (2) 
d2 : Yclause ~ gnom, Y 
Here is a sample m-rule. 
(3) 
d3 : V ~ Adv (4) 
LP rules are represented as regular expressions 
(actually, only a limited form of regular expres- 
sions) associated with each category. We use 
the hash sign (#) to denote the position of the 
governor (head). For example: 
pl:Yt . . . .  = (Adv)Nnom(Aux)Adv*#YobjAdv*Yt . . . .  (5) 
3We follow (Gaifman, 1965) throughout this paper by 
modeling adependency grammar with a string-rewriting 
system. However, we will identify a derivation with its 
representation as a tree, and we will sometimes refer 
to symbols introduced in a rewrite step as "dependent 
nodes". For a model of a DG based on tree-rewriting 
(in the spirit of Tree Adjoining Grammar (Joshi et al, 
1975)), see (Nasr, 1995). 
4In this paper, we will allow finite feature structures 
on categories, which we will notate using subscripts; e.g., 
Vtrans. Since the feature structures are finite, this is sim- 
ply a notational variant of a system defined only with 
simple category labels. 
~clause 
Adv Nnom thought Vtrans 
yesterday Fernando thought Vtrans 
==~ yesterday Fernando thought Nnom eats Nob jA dv 
yesterday Fernando thought Carlos eats beans slowly 
Vclause 
Adv Nnom thought Vtrans 
yesterday Fernando 
Nnom eats Nobj  Adv 
I f J 
Carlos beans slowly 
Figure 3: A sample GDG derivation 
We will call this system generat ive  depen-  
dency  grammar  or GDG for short. 
Derivations in GDG are defined as follows. 
In a rewrite step, we choose a multiset of de- 
pendency rules (i.e., a set of instances of de- 
pendency rules) which contains exactly one s- 
rule and zero or more m-rules. The left-hand 
side nonterminal is the same as that we want to 
rewrite. Call this multiset he rewrite-multiset. 
In the rewriting operation, we introduce a mul- 
tiset of new nonterminals and exactly one termi- 
nal symbol (the head). The rewriting operation 
then must meet the following three conditions: 
? There is a bijection between the set of de- 
pendents of the instances of rules in the 
rewrite-multiset and the set of newly intro- 
duced dependents. 
? The order of the newly introduced epen- 
dents is consistent with the LP rule associ- 
ated with the governor. 
? The introduced terminal string (head) is 
mapped to the rewritten category. 
As an example, consider a grammar contain- 
ing the three dependency rules dl (rule 2), d2 
(rule 3), and d3 (rule 4), as well as the LP rule Pl 
(rule 5). In addition, we have some lexical map- 
pings (they are obvious from the example), and 
the start symbol is Yfinite: +. A sample deriva- 
tion is shown in Figure 3, with the sentential 
form representation top and the correspond- 
ing tree representation below. 
Using this kind of representation, we can 
derive a bottom-up parser in the following 
648 
straightforward manner. 5 Since syntactic and 
linear governors coincide, we can derive de- 
terministic finite-state machines which capture 
both the dependency and the LP rules for a 
given governor category. We will refer to these 
FSMs as ru le -FSMs,  and if the governor is of 
category C, we will refer to a C-rule-FSM. In 
a rule-FSM, the transitions are labeled by cate- 
gories, and the transition corresponding to the 
governor labeled by its category and a special 
mark (such as #).  This transition is called the 
"head transition". 
The entries in the parse matrix M are of the 
form (m, q), where rn is a rule-FSM and q a state 
of it, except for the entries in squares M(i, i), 
1 <: i < n, which also contain category labels. 
Let wo'"wn be the input word. We initialize 
the parse matrix as follows. Let C be a category 
of word wi. First, we add C to M(i, i) .  Then, 
we add to M(i, i) every pair (m, q) such that m 
is a rule-FSM with a transition labeled C from 
a start state and q the state reached after that 
transition. 6 
Embedded in the usual three loops on i, j ,  k, 
we add an entry (ml,q) to M(i , j )  if (rnl,ql) is 
in M(k, j ) ,  (m2, q2) is in M(i, k-t-l), q2 is a final 
state of m2, m2 is a C-rule-FSM, and ml transi- 
tions from ql to q on C (a non-head transition). 
There is a special case for the head transitions 
in ml: i f k  = i - 1, C is in M(i, i) ,  ml is a C- 
rule-FSM, and there is a head transition from 
ql to q in ml,  then we add (ml, q) to M(i, j). 
The time complexity of the algorithm is 
O(n3\[GIQmax), where G is the number of rule- 
FSMs derived from the dependency and LP 
rules in the grammar and Qmax is the maximum 
number of states in any of the rule-FSMs. 
4 A Formal izat ion of 
PP-Dependency  Grammars  
Recall that in a pseudo-projective tr e, we make 
a distinction between a syntactic governor and 
a linear governor. A node can be "lifted" along 
a lifting path from being a dependent of its syn- 
tactic governor to being a dependent of its linear 
5This type of parser has been proposed previously. 
See for example (Lombardi, 1996; Eisner, 1996), who 
also discuss Early-style parsers for projective depen- 
dency grammars. 
6We can use pre-computed top-down prediction to 
limit the number of pairs added. 
649 
governor, which must be an ancestor of the gov- 
ernor. In defining a formal rewriting system for 
pseudo-projective trees, we will not attempt o 
model the "lifting" as a transformational step in 
the derivation. Rather, we will directly derive 
the "lifted" version of the tree, where a node 
is dependent of its linear governor. Thus, the 
derived structure resembles more a unistratal 
dependency representation like those used by 
(Hudson, 1990) than the multistratal represen- 
tations of, for example, (Mel'~uk, 1988). How- 
ever, from a formal point of view, the distinction 
is not significant. 
In order to capture pseudo-projectivity, we 
will interpret rules of the form (2) (for subcate- 
gorization of arguments by a head) and (4) (for 
selection of a head by an adjunct) as introducing 
syntactic dependents which may lift to a higher 
linear governor. An LP rule of the form (5) or- 
ders all linear dependents of the linear governor, 
no matter whose syntactic dependents hey are. 
In addition, we need a third type of rule, 
namely a lifting rule, or l-rule (see 2.3). The 
1-rule (1) can be rewrited on the following form: 
ll : LG > LD {LG.w SG LD} (6) 
This rule resembles normal dependency rules 
but instead of introducing syntactic dependents 
of a category, it introduces a lifted dependent. 
Besides introducing a linear dependent LD, a 
1-rule should make sure that the syntactic gov- 
ernor of LD will be introduced at a later stage of 
the derivation, and prevent it to introduce LD 
as its syntactic dependent, otherwise non pro- 
jective nodes would be introduced twice, a first 
time by their linear governor and a second time 
by their syntactic governor. This condition is 
represented in the rule by means of a constraint 
on the categories found along the lifting path. 
This condition, which we call the lifting con- 
dition, is represented by the regular expression 
LG. w SG. The regular expression representing 
the lifting condition is enriched with a dot sep- 
arating, on its left, the part of the lifting path 
which has already been introduced uring the 
rewriting and on its right the part which is still 
to be introduced for the rewriting to be valid. 
The dot is an unperfect way of representing the 
current state in a finite state automaton equiv- 
alent to the regular expression. We can further 
notice that the lifting condition ends with a rep- 
etition of LD for reasons which will be made 
clear when discussing the rewriting process. 
A sentential form contains terminal strings 
and categories paired with a multiset of lifting 
conditions, called the lift multiset. The lift mul- 
tiset associated to a category C contains 'tran- 
siting' lifting conditions: introduced by ances- 
tors of C and passing across C. 
Three cases must be distinguished when 
rewriting a category C and its lifting multiset 
LM:  
? LM contains a single lifting condi- 
tion which dot is situated to its right: 
LGw SG C . .  In such acase, Cmust  be 
rewritten by the empty string. The situ- 
ation of the dot at the right of the lifting 
condition indicates that C has been intro- 
duced by its syntactic governor although it 
has already been introduced by its linear 
governor earlier in the rewriting process. 
This is the reason why C has been added 
at the end of the lifting condition. 
? LM contains everal ifting conditions one 
of which has its dot to the right. In such 
a case, the rewriting fails since, in accor- 
dance with the preceding case, C must be 
rewritten by the empty string. Therefore, 
the other lifting conditions of LM will not 
be satisfied. Furthermore, a single instance 
of a category cannot anchor more than one 
lifting condition. 
? LM contains everal lifting conditions none 
of which having the dot to their right. In 
this case, a rewrite multiset of dependency 
rules and lifting rules, both having C as 
their left hand side, is selected. The result 
of the rewriting then must meet the follow- 
ing conditions: 
1. The order of the newly introduced e- 
pendents i consistent with the LP rule 
associated with C. 
2. The union 7 of the lift multisets asso- 
ciated with all the newly introduced 
(instances of) categories i equal to the 
union of the lift multiset of C and the 
multiset composed of the lift condition 
7When discussing set operations on multisets, we of 
course mean the corresponding multiset operations. 
of the 1-rules used in the rewriting op- 
eration. 
3. The lifting conditions contained in the 
lift multiset of all the newly introduced 
dependents D should be compatible 
with D, with the dot advanced appro- 
priately. 
In addition, we require that, when we rewrite 
a category as a terminal, the lift multiset is 
empty. 
Let us consider an example. Suppose we have 
have a grammar containing the dependency 
rules dl (rule 2), d2 (rule 3), and d3 (rule 4); 
the LP rule Pl (rule 5) and p2: 
p2:Vclause : (Ntop: + INwh:+)(Adv)Nnom(Aux)Adv* #Adv* Vt . . . .  
Furthermore, we have the following 1-rule: 
II :Vbridge:+---~Nc . . . . .  bj top:+ {'V~ridge:+VNc . . . . .  bj top:+ } 
This rule says that an objective wh-noun with 
feature top:+ which depends on a verb with no 
further restrictions (the third V in the lifting 
path) can raise to any verb that dominates its 
immediate governor as long as the raising paths 
contains only verb with feature bridge:+, i.e., 
bridge verbs. 
Vclause 
Nobj Nnom thought Adv Y{'Y~ridge: + Y Ncase:obj top:+} 
beans Fernando thought yesterday 
V{.V~ridge: + V Nc . . . .  bj top:+} 
beans Fernando thought yesterday Nnom claims 
V{.V~ridge: + V Nc . . . .  bj top:+} 
=~ beans Fernando thought yesterday Milagro claims 
V{-V~ridge: + Y Nc ..... bj top:+} 
beans yesterday Fernando thought yesterday Milagro 
claims Nnom eats N { Y~ridge:+ V Ycase:obj top:+'} Adv 
:=~ beans Fernando thought yesterday Milagro claims Carlos 
eats slowly 
Vcl~us? 
N ~ a u * e  
beans Fernando yester 
Nno m claims Vtrans 
Milagro 
Nnom eats Adv 
I I Carlos slowly 
Figure 4: A sample PP-GDG derivation 
A sample derivation is shown in Figure 4, 
with the sentential form representation  top 
650 
and the corresponding tree representation be- 
low. We start our derivation with the start 
symbol Vclause and rewrite it using dependency 
rules d2 and d3, and the lifting rule ll which 
introduces an objective NP argument. The lift- 
ing condition of I1 is passed to the V dependent 
but the dot remains at the left of V'bridge:. {. be- 
cause of the Kleene star. When we rewrite the 
embedded V, we choose to rewrite again with 
Yclause , and the lifting condition is passed on to 
the next verb. This verb is a Ytrans which re- 
quires a Yobj. The lifting condition is passed to 
Nob j and the dot is moved to the right of the 
regular expression, therefore Nob j is rewritten 
as the empty string. 
5 A Po lynomia l  Parser  for  PP -GDG 
In this section, we show that pseudo-projective 
dependency grammars as defined in Section 2.3 
are polynomially parsable. 
We can extend the bottom-up arser for GDG 
to a parser for PP-GDG in the following man- 
ner. In PP-GDG, syntactic and linear governors 
do not necessarily coincide, and we must keep 
track separately of linear precedence and of lift- 
ing (i.e., "long distance" syntactic dependence). 
The entries in the parse matrix M are of 
the form (m,q, LM), where m is a rule-FSM, 
q a state of m, and LM is a multiset of lift- 
ing conditions as defined in Section 4. An entry 
(m, q, LM) in a square M(i, j) of the parse ma- 
trix means that the sub-word wi...wj of the 
entry can be analyzed by m up to state q (i.e., 
it matches the beginning of an LP rule), but 
that nodes corresponding to the lifting rules in 
LM are being lifted from the subtrees span- 
ning wi...wj. Put differently, in this bottom- 
up view LM represents the set of nodes which 
have a syntactic governor in the subtree span- 
ning wi...wj and a lifting rule, but are still 
looking for a linear governor. 
Suppose we have an entry in the parse matrix 
M of the form (m, q, L). As we traverse the C- 
rule-FSM m, we recognize one by one the linear 
dependents of a node of category C. Call this 
governor ~?. The action of adding a new entry to 
the parse matrix corresponds to adding a single 
new linear dependent to 77. (While we are work- 
ing on the C-rule-FSM m and are not yet in a 
final state, we have not yet recognized ~? itself.) 
Each new dependent ~?' brings with it a multiset 
651 
of nodes being lifted from the subtree it is the 
root of. Call this multiset LM'. The new entry 
will be (m, q', LM U LM') (where q' is the state 
! , 
that m transitions to when ~? is recognized as 
the next linear dependent. 
When we have reached a final state q of the 
rule-FSM m, we have recognized a complete 
subtree rooted in the new governor, ~?. Some 
of the dependent nodes of ~? will be both syn- 
tactic and linear dependents of ~?, and the others 
will be linear dependents of ~?, but lifted from a 
descendent of 7. In addition, 77 may have syn- 
tactic dependents which are not realized as its 
own linear dependent and are lifted away. (No 
other options are possible.) Therefore, when we 
have reached the final state of a rule-FSM, we 
must connect up all nodes and lifting conditions 
before we can proceed to put an entry (m, q, L) 
in the parse matrix. This involves these steps: 
1. For every lifting condition in LM, we en- 
sure that it is compatible with the category 
of ~?. This is done by moving the dot left- 
wards in accordance with the category of 
77. (The dot is moved leftwards since we 
are doing bottom-up recognition.) 
The obvious special provisions deal with 
the Kleene star and optional elements. 
If the category matches a catgeory with 
Kleene start in the lifting condition, we do 
not move the dot. If the category matches 
a category which is to the left of an op- 
tional category, or to the left of category 
with Kleene star, then we can move the dot 
to the left of that category. 
If the dot cannot be placed in accordance 
with the category of 77, then no new entry 
is made in the parse matrix for ~?. 
2. We then choose a multiset of s-, m-, and 1- 
rules whose left-hand side is the category of 
~?. For every dependent of 77 introduced by 
an 1-rule, the dependent must be compati- 
ble with an instance of a lifting condition in 
LM (whose dot must be at its beginning, or 
seperated from the beginning by optional 
or categories only); the lifting condition is 
then removed from L. 
3. If, after the above repositioning of the dot 
and the linking up of all linear dependents 
to lifting conditions, there are still lifting 
. 
conditions in LM such that the dot is at 
the beginning of the lifting condition, then 
no new entry is made in the parse matrix 
for ~?. 
For every syntactic dependent of ?, we de- 
termine if it is a linear dependent of~ which 
has not yet been identified as lifted. For 
each syntactic dependents which is not also 
a linear dependent, we check whether there 
is an applicable lifting rule. If not, no entry 
is made in the parse matrix for 77. If yes, 
we add the lifting rule to LM. 
This procedure determines a new multiset 
LM so we can add entry (m, q, LM) in the parse 
matrix. (In fact, it may determine several pos- 
sible new multisets, resulting in multiple new 
entries.) The parse is complete if there is an 
entry (m, qrn, O) in square M(n, 1) of the parse 
matrix, where m is a C-rule-FSM for a start 
category and qm is a final state of m. If we keep 
backpointers at each step in the algorithm, we 
have a compact representation f the parse for- 
est. 
The maximum number of entries in each 
square of the parse matrix is O(GQnL), where 
G is the number of rule-FSMs corresponding to
LP rules in the grammar, Q is the maximum 
number of states in any of the rule-FSMs, and 
L is the maximum number of states that the 
lifting rules can be in (i.e., the number of lift- 
ing conditions in the grammar multiplied by the 
maximum number of dot positions of any lifting 
condition). Note that the exponent is a gram- 
mar constant, but this number can be rather 
small since the lifting rules are not lexicalized 
- they are construction-specific, not lexeme- 
specific. The time complexity of the algorithm 
is therefore O(GQn3+21L\[). 
References  
Norbert BrSker and Peter Neuhaus. 1997. The 
complexity of recognition of linguistically ad- 
equate dependency grammars. In 35th Meet- 
ing of the Association for Computational Lin- 
guistics (ACL'97), Madrid, Spain. ACL. 
M. Collins. 1997. Three generative, lexicalised 
models for statistical parsing. In Proceedings 
of the 35th Annual Meeting of the Associa- 
tion for Computational Linguistics, Madrid, 
Spain, July. 
652 
Jason M. Eisner. 1996. Three new probabilis- 
tic models for dependency parsing: An ex- 
ploration. In Proceedings of the 16th Inter- 
national Conference on Computational Lin- 
guistics (COLING'96), Copenhagen. 
Haim Galfman. 1965. Dependency systems and 
phrase-structure systems. Information and 
Control, 8:304-337. 
Richard Hudson. 1990. English Word Gram- 
mar. Basil Blackwell, Oxford, RU. 
Richard Hudson. unpublished. Discontinuity. 
e-preprint (ftp.phon.ucl.ac.uk). 
Aravind K. Joshi, Leon Levy, and M Takahashi. 
1975. Tree adjunct grammars. J. Comput. 
Syst. Sci., 10:136-163. 
Jiirgen Kunze. 1968. The treatment of non- 
projective structures in the syntactic analysis 
and synthesis of english and german. Com- 
putational Linguistics, 7:67-77. 
Yves Lecerf. 1960. Programme des conflits, 
module des conflits. Bulletin bimestriel de 
I'ATALA, 4,5. 
Vicenzo Lombardi. 1996. An Earley-style 
parser for dependency grammars. In Pro- 
ceedings of the 16th International Conference 
on Computational Linguistics (COLING'96), 
Copenhagen. 
Solomon Marcus. 1965. Sur la notion de projec- 
tivit6. Zeitschr. f. math. Logik und Grundla- 
gen d. Math., 11:181-192. 
Igor A. Mel'6uk. 1988. Dependency Syntax: 
Theory and Practice. State University of New 
York Press, New York. 
Alexis Nasr. 1995. A formalism and a parser for 
lexicalised ependency grammars. In 4th In- 
ternational Workshop on Parsing Technolo- 
gies, pages 186-195, Prague. 
Alexis Nasr. 1996. Un syst~me de reformu- 
lation automatique de phrases fondd sur la 
Thdorie Sens-Texte : application aux langues 
contr61des. Ph.D. thesis, Universit6 Paris 7. 
Michael Reape. 1990. Getting things in order. 
In Proceedings of the Symposium on Discon- 
tinuous Constituents, Tilburg, Holland. 
Jane J. Robinson. 1970. Dependency struc- 
tures and transformational rules. Language, 
46(2):259-285. 
