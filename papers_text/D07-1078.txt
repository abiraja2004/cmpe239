Proceedings of the 2007 Joint Conference on Empirical Methods in Natural Language Processing and Computational
Natural Language Learning, pp. 746?754, Prague, June 2007. c?2007 Association for Computational Linguistics
Binarizing Syntax Trees to Improve
Syntax-Based Machine Translation Accuracy
Wei Wang and Kevin Knight and Daniel Marcu
Language Weaver, Inc.
4640 Admiralty Way, Suite 1210
Marina del Rey, CA, 90292
{wwang,kknight,dmarcu}@languageweaver.com
Abstract
We show that phrase structures in Penn Tree-
bank style parses are not optimal for syntax-
based machine translation. We exploit a se-
ries of binarization methods to restructure
the Penn Treebank style trees such that syn-
tactified phrases smaller than Penn Treebank
constituents can be acquired and exploited in
translation. We find that by employing the
EM algorithm for determining the binariza-
tion of a parse tree among a set of alternative
binarizations gives us the best translation re-
sult.
1 Introduction
Syntax-based translation models (Eisner, 2003; Gal-
ley et al, 2006; Marcu et al, 2006) are usually built
directly from Penn Treebank (PTB) (Marcus et al,
1993) style parse trees by composing treebank gram-
mar rules. As a result, often no substructures corre-
sponding to partial PTB constituents are extracted to
form translation rules.
Syntax translation models acquired by composing
treebank grammar rules assume that long rewrites
are not decomposable into smaller steps. This ef-
fectively restricts the generalization power of the in-
duced model. For example, suppose we have an
xRs (Knight and Graehl, 2004) rule R1 in Figure 1
that translates the Chinese phrase RUSSIA MINISTER
VIKTOR-CHERNOMYRDIN into an English NPB tree
fragment yielding an English phrase. Also suppose
that we want to translate a Chinese phrase
VIKTOR-CHERNOMYRDIN AND HIS COLLEAGUE
into English. What we desire is that if we have
another rule R2 as shown in Figure 1, we could
somehow compose it with R1 to obtain the desir-
able translation. We unfortunately cannot do this
because R1 and R2 are not further decomposable
and their substructures cannot be re-used. The re-
quirement that all translation rules have exactly one
root node does not enable us to use the translation of
VIKTOR-CHERNOMYRDIN in any other contexts than
those seen in the training corpus.
A solution to overcome this problem is to right-
binarize the left-hand side (LHS) (or the English-
side) tree of R1 such that we can decompose
R1 into R3 and R4 by factoring NNP(viktor)
NNP(chernomyrdin) out as R4 according to the
word alignments; and left-binarize the LHS of R2 by
introducing a new tree node that collapses the two
NNP?s, so as to generalize this rule, getting rule R5
and rule R6. We also need to consistently syntact-
ify the root labels of R4 and the new frontier label
of R6 such that these two rules can be composed.
Since labeling is not a concern of this paper, we sim-
ply label new nodes with X-bar where X here is the
parent label. With all these in place, we now can
translate the foreign sentence by composing R6 and
R4 in Figure 1.
Binarizing the syntax trees for syntax-based ma-
chine translation is similar in spirit to generalizing
parsing models via markovization (Collins, 1997;
Charniak, 2000). But in translation modeling, it is
unclear how to effectively markovize the translation
rules, especially when the rules are complex like
those proposed by Galley et al (2006).
In this paper, we explore the generalization abil-
ity of simple binarization methods like left-, right-,
and head-binarization, and also their combinations.
Simple binarization methods binarize syntax trees
in a consistent fashion (left-, right-, or head-) and
746
NPB
JJ         NNP      NNP     NNP
russia    minister    viktor   chernomyrdin
RUSSIA   MINISTER      V?C
NPB
?
NNP         NNP      AND  HIS   COLLEAGUE
V?C AND  HIS COLLEAGUE
NPB
JJ
russia
RUSSIA
minister
MINISTER NNP   NNP
viktor  chernomyrdin
V?C
NPB
colleague
and    his     colleague
COLLEAGUE
PRB$
his
HIS
CC
and
ANDNNP      NNP
x0:NNP  x1:NNP V?C AND  HIS COLLEAGUE
NNS
x0:NNP   x1:NNP   CC   PRB$   NNS
R1 R2
NPB
NPB
R3
NPB
NPBR4 R5
R6
R6
R4
NPB
Figure 1: Generalizing translation rules by binarizing trees.
thus cannot guarantee that all the substructures can
be factored out. For example, right binarization on
the LHS of R1 makes available R4, but misses R6
on R2. We then introduce a parallel restructuring
method, that is, one can binarize both to the left and
right at the same time, resulting in a binarization for-
est. We employ the EM (Dempster et al, 1977) algo-
rithm to learn the binarization bias for each tree node
from the parallel alternatives. The EM-binarization
yields best translation performance.
The rest of the paper is organized as follows.
Section 2 describes related research. Section 3 de-
fines the concepts necessary for describing the bina-
rizations methods. Section 4 describes the tree bina-
rization methods in details. Section 5 describes the
forest-based rule extraction algorithm, and section 6
explains how we restructure the trees using the EM
algorithm. The last two sections are for experiments
and conclusions.
2 Related Research
Several researchers (Melamed et al, 2004; Zhang
et al, 2006) have already proposed methods for bi-
narizing synchronous grammars in the context of
machine translation. Grammar binarization usually
maintains an equivalence to the original grammar
such that binarized grammars generate the same lan-
guage and assign the same probability to each string
as the original grammar does. Grammar binarization
is often employed to make the grammar fit in a CKY
parser. In our work, we are focused on binarization
of parse trees. Tree binarization generalizes the re-
sulting grammar and changes its probability distri-
bution. In tree binarization, synchronous grammars
built from restructured (binarized) training trees still
contain non-binary, multi-level rules and thus still
require the binarization transformation so as to be
employed by a CKY parser.
The translation model we are using in this paper
belongs to the xRs formalism (Knight and Graehl,
2004), which has been proved successful for ma-
chine translation in (Galley et al, 2004; Galley et
al., 2006; Marcu et al, 2006).
3 Concepts
We focus on tree-to-string (in noisy-channel model
sense) translation models. Translation models of
this type are typically trained on tuples of a source-
language sentence f, a target language (e.g., English)
parse tree pi that yields e and translates from f, and
the word alignments a between e and f. Such a tuple
is called an alignment graph in (Galley et al, 2004).
The graph (1) in Figure 2 is such an alignment graph.
747
(1) unbinarized tree
  
NPB
viktor chernomyrdin
VIKTOR?CHERNOMYRDIN
NNP1    NNP2   NNP3   NNP4*
(2) left-binarization (3) right-/head-binarization
NPB
NPB
NNP1 NNP2 NNP3
viktor
NNP?4
chernomyrdin
NPB
NNP1 NPB?
NNP2 NNP3
viktor
NNP4?
chernomyrdin
(4) left-binarization (5) right-binarization (6) left-binarization (7) right-/head-binarization
NPB
NPB
NPB
NNP1 NNP2
NNP3
viktor
NNP4?
chernomyrdin
- -
NPB
NNP1 NPB?
NNP2 NPB?
NNP3
viktor
NNP4?
chernomyrdin
Figure 2: Left, right, and head binarizations. Heads are marked with ??s. New nonterminals introduced by binarization are
denoted by X-bars.
A tree node in pi is admissible if the f string cov-
ered by the node is contiguous but not empty, and
if the f string does not align to any e string that is
not covered by pi. An xRs rule can be extracted only
from an admissible tree node, so that we do not have
to deal with dis-contiguous f spans in decoding (or
synchronous parsing). For example, in tree (2) in
Figure 2, node NPB is not admissible because the
f string that the node covers also aligns to NNP4,
which is not covered by the NPB. Node NPB in tree
(3), on the other hand, is admissible.
A set of sibling tree nodes is called factorizable
if we can form an admissible new node dominating
them. For example, in tree (1) of Figure 2, sibling
nodes NNP2 NNP3 and NNP4 are factorizable be-
cause we can factorize them out and form a new
node NPB, resulting in tree (3). Sibling tree nodes
NNP1 NNP2 and NNP3 are not factorizable. In syn-
chronous parse trees, not all sibling nodes are fac-
torizable, thus not all sub-phrases can be acquired
and syntactified. The main purpose of our paper is
to restructure parse trees by factorization such that
syntactified sub-phrases can be employed in transla-
tion.
4 Binarizing Syntax Trees
We are going to binarize a tree node n that domi-
nates r children n1, ..., nr. Restructuring will be
performed by introducing new tree nodes to domi-
nate a subset of the children nodes. To avoid over-
generalization, we allow ourselves to form only one
new node at a time. For example, in Figure 2, we
can binarize tree (1) into tree (2), but we are not
allowed to form two new nodes, one dominating
NNP1 NNP2 and the other dominating NNP3 NNP4.
Since labeling is not the concern of this paper, we re-
label the newly formed nodes as n.
4.1 Simple binarization methods
The left binarization of node n (i.e., the NPB in
tree (1) of Figure 2) factorizes the leftmost r ? 1
children by forming a new node n (i.e., NPB in
tree (2)) to dominate them, leaving the last child
nr untouched; and then makes the new node n the
left child of n. The method then recursively left-
binarizes the newly formed node n until two leaves
are reached. In Figure 2, we left-binarize tree (1)
into (2) and then into (4).
The right binarization of node n factorizes the
rightmost r ? 1 children by forming a new node n
(i.e., NPB in tree (3)) to dominate them, leaving the
748
first child n1 untouched; and then makes the new
node n the right child of n. The method then recur-
sively right-binarizes the newly formed node n. In
Figure 2, we right-binarize tree (1) into (3) and then
into (7).
The head binarization of node n left-binarizes
n if the head is the first child; otherwise, right-
binarizes n. We prefer right-binarization to left-
binarization when both are applicable under the head
restriction because our initial motivation was to gen-
eralize the NPB-rooted translation rules. As we will
show in the experiments, binarization of other types
of phrases contribute to the translation accuracy im-
provement as well.
Any of these simple binarization methods is easy
to implement, but is incapable of giving us all the
factorizable sub-phrases. Binarizing all the way to
the left, for example, from tree (1) to tree (2) and to
tree (4) in Figure 2, does not enable us to acquire a
substructure that yields NNP3 NNP4 and their trans-
lational equivalences. To obtain more factorizable
sub-phrases, we need to parallel-binarize in both di-
rections.
4.2 Parallel binarization
Simple binarizations transform a parse tree into an-
other single parse tree. Parallel binarization will
transform a parse tree into a binarization forest,
desirably packed to enable dynamic programming
when extracting translation rules from it.
Borrowing terms from parsing semirings (Good-
man, 1999), a packed forest is composed of addi-
tive forest nodes (?-nodes) and multiplicative forest
nodes (?-nodes). In the binarization forest, a ?-
node corresponds to a tree node in the unbinarized
tree; and this ?-node composes several ?-nodes,
forming a one-level substructure that is observed in
the unbinarized tree. A ?-node corresponds to al-
ternative ways of binarizing the same tree node in
the unbinarized tree and it contains one or more ?-
nodes. The same ?-node can appear in more than
one place in the packed forest, enabling sharing.
Figure 3 shows a packed forest obtained by pack-
ing trees (4) and (7) in Figure 2 via the following
parallel binarization algorithm.
To parallel-binarize a tree node n that has children
n1, ..., nr , we employ the following steps:
?1(NPB)
?2(NPB)
?3(NPB)
?4(NPB)
?5(NPB)
?6(NPB)
?7(NNP1) ?8(NNP2)
?9(NNP3)
?10(NNP4)
?11(NPB)
?7(NNP1) ?12(NPB)
?13(NPB)
?8(NNP2) ?14(NPB)
?15(NPB)
?9(NNP3) ?10(NNP4)
Figure 3: Packed forest obtained by packing trees (4) and (7)
in Figure 2
? We recursively parallel-binarize children nodes
n1, ..., nr, producing binarization ?-nodes
?(n1), ..., ?(nr), respectively.
? We right-binarize n, if any contiguous1 subset
of children n2, ..., nr is factorizable, by intro-
ducing an intermediate tree node labeled as n.
We recursively parallel-binarize n to generate
a binarization forest node ?(n). We form a
multiplicative forest node ?R as the parent of
?(n1) and ?(n).
? We left-binarize n if any contiguous subset
of n1, ..., nr?1 is factorizable and if this sub-
set contains n1. Similar to the above right-
binarization, we introduce an intermediate tree
node labeled as n, recursively parallel-binarize
n to generate a binarization forest node ?(n),
form a multiplicative forest node ?L as the par-
ent of ?(n) and ?(n1).
? We form an additive node ?(n) as the parent
of the two already formed multiplicative nodes
?L and ?R.
The (left and right) binarization conditions con-
sider any subset to enable the factorization of small
constituents. For example, in tree (1) of Figure 2,
although NNP1 NNP2 NNP3 of NPB are not factor-
izable, the subset NNP1 NNP2 is factorizable. The
binarization from tree (1) to tree (2) serves as a re-
laying step for us to factorize NNP1 NNP2 in tree
(4). The left-binarization condition is stricter than
1We factorize only subsets that cover contiguous spans to
avoid introducing dis-contiguous constituents for practical pur-
pose. In principle, the algorithm works fine without this bina-
rization condition.
749
the right-binarization condition to avoid spurious bi-
narization; i.e., to avoid the same subconstituent be-
ing reached via both binarizations. We could trans-
form tree (1) directly into tree (4) without bother-
ing to generate tree (3). However, skipping tree (3)
will create us difficulty in applying the EM algo-
rithm to choose a better binarization for each tree
node, since tree (4) can neither be classified as left
binarization nor as right binarization of the original
tree (1) ? it is the result of the composition of two
left-binarizations.
In parallel binarization, nodes are not always bi-
narizable in both directions. For example, we do not
need to right-binarize tree (2) because NNP2 NNP3
are not factorizable, and thus cannot be used to form
sub-phrases. It is still possible to right-binarize tree
(2) without affecting the correctness of the parallel
binarization algorithm, but that will spuriously in-
crease the branching factor of the search for the rule
extraction, because we will have to expand more tree
nodes.
A restricted version of parallel binarization is the
headed parallel binarization, where both the left and
the right binarization must respect the head propaga-
tion property at the same time.
A nice property of parallel binarization is that
for any factorizable substructure in the unbinarized
tree, we can always find a corresponding admissi-
ble ?-node in the parallel-binarized packed forest.
A leftmost substructure like the lowest NPB-subtree
in tree (4) of Figure 2 can be made factorizable
by several successive left binarizations, resulting in
?5(NPB)-node in the packed forest in Figure 3. A
substructure in the middle can be factorized by the
composition of several left- and right-binarizations.
Therefore, after a tree is parallel-binarized, to make
the sub-phrases available to the MT system, all we
need to do is to extract rules from the admissible
nodes in the packed forest. Rules that can be ex-
tracted from the original unrestructured tree can be
extracted from the packed forest as well.
Parallel binarization results in parse forests. Thus
translation rules need to be extracted from training
data consisting of (e-forest, f, a)-tuples.
5 Extracting translation rules from
(e-forest, f, a)-tuples
The algorithm to extract rules from (e-forest, f, a)-
tuples is a natural generalization of the (e-parse, f,
a)-based rule extraction algorithm in (Galley et al,
2006). The input to the forest-based algorithm is a
(e-forest, f, a)-triple. The output of the algorithm is
a derivation forest (Galley et al, 2006) composed of
xRs rules. The algorithm recursively traverses the e-
forest top-down and extracts rules only at admissible
forest nodes.
The following procedure transforms the packed e-
forest in Figure 3 into a packed synchronous deriva-
tion in Figure 4.
Condition 1: Suppose we reach an additive
e-forest node, e.g. ?1(NPB) in Figure 3. For
each of ?1(NPB)?s children, e-forest nodes
?2(NPB) and ?11(NPB), we go to condi-
tion 2 to recursively extract rules on these
two e-forest nodes, generating multiplicative
derivation forest nodes, i.e., ?(NPB(NPB :
x0 NNP3(viktor) NNP4(chernomyrdin)4) ?
x0 V-C) and ?(NPB(NNP1 NPB(NNP2 : x0 NPB :
x1)) ? x0 x1 x2) in Figure 4. We make these
new ? nodes children of ?(NPB) in the derivation
forest.
Condition 2: Suppose we reach a multiplicative
parse forest node, i.e., ?11(NPB) in Figure 3. We
extract rules rooted at it using the procedure in
(Galley et al, 2006), forming multiplicative deriva-
tion forest nodes, i.e., ?(NPB(NNP1 NPB(NNP2 :
x0 NPB : x1)) ? x0 x1 x2) We then go
to condition 1 to form the derivation forest on
the additive frontier e-forest nodes of the newly
extracted rules, generating additive derivation for-
est nodes, i.e., ?(NNP1), ?(NNP2) and ?(NPB).
We make these ? nodes the children of node
?(NPB(NNP1 NPB(NNP2 : x0 NPB : x1)) ?
x0 x1 x2) in the derivation forest.
This algorithm is a natural extension of the extrac-
tion algorithm in (Galley et al, 2006) in the sense
that we have an extra condition (1) to relay rule ex-
traction on additive e-forest nodes.
It is worthwhile to eliminate the spuriously am-
biguous rules that are introduced by the parallel bi-
750
?(NPB)
?
(
NPB(NPB : x0 NNP(viktor) NNP(chernomyrdin)) ? x0 V-C
)
?(NPB)
?
(
NPB(NNP : x0 NNP : x1 ? x0 x1)
)
?
(
NPB(NNP : x0 NPB(NNP : x1 NPB : x2)) ? x0 x1 x2
)
?(NNP) ?(NNP) ?(NPB)
?
(
NPB(NNP(viktor) NNP(chernomyrdin)) ? V-C)
Figure 4: Derivation forest.
narization. For example, we may extract the follow-
ing two rules:
- A(A(B:x0 C:x1)D:x2) ? x1 x0 x2
- A(B:x0 A(C:x1 D:x2)) ? x1 x0 x2
These two rules, however, are not really distinct.
They both converge to the following rules if we
delete the auxiliary nodes A.
- A(B:x0 C:x1 D:x2) ? x1 x0 x2
The forest-base rule extraction algorithm pro-
duces much larger grammars than the tree-based
one, making it difficult to scale to very large training
data. From a 50M-word Chinese-to-English parallel
corpus, we can extract more than 300 million trans-
lation rules, while the tree-based rule extraction al-
gorithm gives approximately 100 million. However,
the restructured trees from the simple binarization
methods are not guaranteed to give the best trees for
syntax-based machine translation. What we desire is
a binarization method that still produces single parse
trees, but is able to mix left binarization and right
binarization in the same tree. In the following, we
shall use the EM algorithm to learn the desirable bi-
narization on the forest of binarization alternatives
proposed by the parallel binarization algorithm.
6 Learning how to binarize via the EM
algorithm
The basic idea of applying the EM algorithm to
choose a restructuring is as follows. We perform a
set {?} of binarization operations on a parse tree ? .
Each binarization ? is the sequence of binarizations
on the necessary (i.e., factorizable) nodes in ? in pre-
order. Each binarization ? results in a restructured
tree ?? . We extract rules from (?? , f, a), generating a
translation model consisting of parameters (i.e., rule
e?parse
  (Galley et al, 2006)
composed rule extraction
1
2
parallel binarization e?forest
forest?based rule extraction
         of minimal rules
f,a
synchronous derivation forests
EM
3
4
viterbi derivationsproject e?parse
model
syntax translation 
Figure 5: Using the EM algorithm to choose restructuring.
probabilities) ?. Our aim is to obtain the binarization
?? that gives the best likelihood of the restructured
training data consisting of (?? , f , a)-tuples. That is
?? = arg max
?
p(??, f ,a|??) (1)
In practice, we cannot enumerate all the exponen-
tial number of binarized trees for a given e-parse.
We therefore use the packed forest to store all the
binarizations that operate on an e-parse in a com-
pact way, and then use the inside-outside algorithm
(Lari and Young, 1990; Knight and Graehl, 2004)
for model estimation.
The probability p(??, f ,a) of a (?? , f, a)-tuple
is what the basic syntax-based translation model is
concerned with. It can be further computed by ag-
gregating the rule probabilities p(r) in each deriva-
tion ? in the set of all derivations ? (Galley et al,
2004; Marcu et al, 2006). That is
p(??, f ,a) =
?
???
?
r??
p(r) (2)
Since it has been well-known that applying EM
with tree fragments of different sizes causes over-
fitting (Johnson, 1998), and since it is also known
that syntax MT models with larger composed rules
in the mix significantly outperform rules that min-
imally explain the training data (minimal rules) in
751
translation accuracy (Galley et al, 2006), we decom-
pose p(?b, f ,a) using minimal rules during running
of the EM algorithm, but, after the EM restructuring
is finished, we build the final translation model using
composed rules for evaluation.
Figure 5 is the actual pipeline that we use for
EM binarization. We first generate a packed e-forest
via parallel binarization. We then extract minimal
translation rules from the (e-forest, f, a)-tuples, pro-
ducing synchronous derivation forests. We run the
inside-outside algorithm on the derivation forests
until convergence. We obtain the Viterbi derivations
and project the English parses from the derivations.
Finally, we extract composed rules using Galley et
al. (2006)?s (e-tree, f, a)-based rule extraction algo-
rithm. This procedure corresponds to the path 13?42
in the pipeline.
7 Experiments
We carried out a series of experiments to compare
the performance of different binarization methods
in terms of BLEU on Chinese-to-English translation
tasks.
7.1 Experimental setup
Our bitext consists of 16M words, all in the
mainland-news domain. Our development set is a
925-line subset of the 993-line NIST02 evaluation
set. We removed long sentences from the NIST02
evaluation set to speed up discriminative training.
The test set is the full 919-line NIST03 evaluation
set.
We used a bottom-up, CKY-style decoder that
works with binary xRs rules obtained via a syn-
chronous binarization procedure (Zhang et al,
2006). The decoder prunes hypotheses using strate-
gies described in (Chiang, 2007).
The parse trees on the English side of the bitexts
were generated using a parser (Soricut, 2004) imple-
menting the Collins parsing models (Collins, 1997).
We used the EM procedure described in (Knight
and Graehl, 2004) to perform the inside-outside al-
gorithm on synchronous derivation forests and to
generate the Viterbi derivation forest.
We used the rule extractor described in (Galley et
al., 2006) to extract rules from (e-parse, f, a)-tuples,
but we made an important modification: new nodes
introduced by binarization will not be counted when
computing the rule size limit unless they appear as
the rule roots. The motivation is that binarization
deepens the parses and increases the number of tree
nodes. In (Galley et al, 2006), a composed rule
is extracted only if the number of internal nodes it
contains does not exceed a limit (i.e., 4), similar
to the phrase length limit in phrase-based systems.
This means that rules extracted from the restructured
trees will be smaller than those from the unrestruc-
tured trees, if the X nodes are deleted. As shown in
(Galley et al, 2006), smaller rules lose context, and
thus give lower translation performance. Ignoring X
nodes when computing the rule sizes preserves the
unstructured rules in the resulting translation model
and adds substructures as bonuses.
7.2 Experiment results
Table 1 shows the BLEU scores of mixed-cased and
detokenized translations of different systems. We
see that all the binarization methods improve the
baseline system that does not apply any binarization
algorithm. The EM-binarization performs the best
among all the restructuring methods, leading to 1.0
BLEU point improvement. We also computed the
bootstrap p-values (Riezler and Maxwell, 2005) for
the pairwise BLEU comparison between the base-
line system and any of the system trained from bina-
rized trees. The significance test shows that the EM
binarization result is statistically significant better
than the baseline system (p > 0.005), even though
the baseline is already quite strong. To our best
knowledge, 37.94 is the highest BLEU score on this
test set to date.
Also as shown in Table 1, the grammars trained
from the binarized training trees are almost two
times of the grammar size with no binarization. The
extra rules are substructures factored out by these bi-
narization methods.
How many more substructures (or translation
rules) can be acquired is partially determined by
how many more admissible nodes each binariza-
tion method can factorize, since rules are extractable
only from admissible tree nodes. According to
Table 1, binarization methods significantly increase
the number of admissible nodes in the training trees.
The EM binarization makes available the largest
752
EXPERIMENT NIST03-BLEU # RULES # ADMISSIBLE NODES IN TRAINING
no-bin 36.94 63.4M 7,995,569
left binarization 37.47 (p = 0.047) 114.0M 10,463,148
right binarization 37.49 (p = 0.044) 113.0M 10,413,194
head binarization 37.54 (p = 0.086) 113.8M 10,534,339
EM binarization 37.94 (p = 0.0047) 115.6M 10,658,859
Table 1: Translation performance, grammar size and # admissible nodes versus binarization algorithms. BLEU scores are for
mixed-cased and detokenized translations, as we usually do for NIST MT evaluations.
nonterminal left-binarization right-binarization
NP 96.97% 3.03%
NP-C 97.49% 2.51%
NPB 0.25% 99.75%
VP 93.90% 6.10%
PP 83.75% 16.25%
ADJP 87.83% 12.17%
ADVP 82.74% 17.26%
S 85.91% 14.09%
S-C 18.88% 81.12%
SBAR 96.69% 3.31%
QP 86.40% 13.60%
PRN 85.18% 14.82%
WHNP 97.93% 2.07%
NX 100% 0
SINV 87.78% 12.22%
PRT 100% 0
SQ 93.53% 6.47%
CONJP 18.08% 81.92%
Table 2: Binarization bias learned by EM.
number of admissible nodes, and thus results in the
most rules.
The EM binarization factorizes more admissible
nodes because it mixes both left and right binariza-
tions in the same tree. We computed the binarization
biases learned by the EM algorithm for each nonter-
minal from the binarization forest of headed-parallel
binarizations of the training trees, getting the statis-
tics in Table 2. Of course, the binarization bias
chosen by left-/right-binarization methods would be
100% deterministic. One noticeable message from
Table 2 is that most of the categories are actually bi-
ased toward left-binarization, although our motivat-
ing example in our introduction section is for NPB,
which needed right binarization. The main reason
might be that the head sub-constituents of most cat-
egories tend to be on the left, but according to the
performance comparison between head binarization
and EM binarization, head binarization does not suf-
fice because we still need to choose the binarization
between left and right if they both are head binariza-
tions.
8 Conclusions
In this paper, we not only studied the impact of
simple tree binarization algorithms on the perfor-
mance of end-to-end syntax-based MT, but also pro-
posed binarization methods that mix more than one
simple binarization in the binarization of the same
parse tree. Binarizing a tree node whether to the left
or to the right was learned by employing the EM
algorithm on a set of alternative binarizations and
by choosing the Viterbi one. The EM binarization
method is informed by word alignments such that
unnecessary new tree nodes will not be ?blindly? in-
troduced.
To our best knowledge, our research is the first
work that aims to generalize a syntax-based trans-
lation model by restructuring and achieves signifi-
cant improvement on a strong baseline. Our work
differs from traditional work on binarization of syn-
chronous grammars in that we are not concerned
with the equivalence of the binarized grammar to the
original grammar, but intend to generalize the orig-
inal grammar via restructuring of the training parse
trees to improve translation performance.
Acknowledgments
The authors would like to thank David Chiang,
Bryant Huang, and the anonymous reviewers for
their valuable feedbacks.
References
E. Charniak. 2000. A maximum-entropy-inspired parser.
In Proceedings of the Human Language Technology
Conference of the North American Chapter of the As-
sociation for Computational Linguistics, Seattle, May.
David Chiang. 2007. Hierarchical phrase-based transla-
tion. Computational Linguistics, 33(2).
Michael Collins. 1997. Three generative, lexicalized
models for statistical parsing. In Proceedings of the
753
35th Annual Meeting of the Association for Computa-
tional Linguistics (ACL), pages 16?23, Madrid, Spain,
July.
A. P. Dempster, N. M. Laird, and D. B. Rubin. 1977.
Maximum likelihood from incomplete data via the EM
algorithm. Journal of the Royal Statistical Society,
39(1):1?38.
Jason Eisner. 2003. Learning non-isomorphic tree map-
pings for machine translation. In Proceedings of the
40th Annual Meeting of the Association for Compu-
tational Linguistics (ACL), pages 205?208, Sapporo,
July.
M. Galley, M. Hopkins, K. Knight, and D. Marcu. 2004.
What?s in a Translation Rule? In Proceedings of
the Human Language Technology Conference and the
North American Association for Computational Lin-
guistics (HLT-NAACL), Boston, Massachusetts.
M. Galley, J. Graehl, K. Knight, D. Marcu, S. DeNeefe,
W. Wang, and I. Thayer. 2006. Scalable Inference and
Training of Context-Rich Syntactic Models. In Pro-
ceedings of the 44th Annual Meeting of the Association
for Computational Linguistics (ACL).
Joshua Goodman. 1999. Semiring parsing. Computa-
tional Linguistics, 25(4):573?605.
M. Johnson. 1998. The DOP estimation method is
biased and inconsistent. Computational Linguistics,
28(1):71?76.
K. Knight and J. Graehl. 2004. Training Tree Transduc-
ers. In Proceedings of NAACL-HLT.
K. Lari and S. Young. 1990. The estimation of stochastic
context-free grammars using the inside-outside algo-
rithm. Computer Speech and Language, pages 35?56.
Daniel Marcu, Wei Wang, Abdessamad Echihabi, and
Kevin Knight. 2006. SPMT: Statistical machine
translation with syntactified target language phraases.
In Proceedings of EMNLP-2006, pp. 44-52, Sydney,
Australia.
M. Marcus, B. Santorini, and M. Marcinkiewicz.
1993. Building a large annotated corpus of En-
glish: The Penn Treebank. Computational Linguistics,
19(2):313?330.
I. Dan Melamed, Giorgio Satta, and Benjamin Welling-
ton. 2004. Generalized multitext grammars. In Pro-
ceedings of the 42nd Annual Meeting of the Associa-
tion for Computational Linguistics (ACL), Barcelona,
Spain.
Stefan Riezler and John T. Maxwell. 2005. On some
pitfalls in automatic evaluation and significance test-
ing for MT. In Proc. ACL Workshop on Intrinsic and
Extrinsic Evaluation Measures for MT and/or Summa-
rization.
Radu Soricut. 2004. A reimplementation of Collins?s
parsing models. Technical report, Information Sci-
ences Institute, Department of Computer Science Uni-
versity of Southern California.
Hao Zhang, Liang Huang, Daniel Gildea, and Kevin
Knight. 2006. Synchronous binarization for machine
translation. In Proceedings of the HLT-NAACL.
754
