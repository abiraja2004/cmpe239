Se l f -Mon i to r ing  w i th  Revers ib le  Grammars  
Giinter Neumann* and Gertjan van Noord\] 
*Deutsches Forschungszentrum tRijksuniversiteit Groningen 
f~r Kfinstliche Intelligenz Postbus 716 
Stuhlsatzenhausweg 3 NL 9700 AS Groningen 
D-6600 Saarbr/icken 11 vannoord@let.rug.nl 
neumann@dfki.uni-sb.de 
Abstract 
We describe a method and its implementation 
for self-monitoring during natural anguage gen- 
eration. In situations of communication where 
the generation of ambiguous utterances should be 
avoided our method is able to compute an un- 
ambiguous utterance for a given semantic input. 
The proposed method is based on a very strict 
integration of parsing and generation. During 
the monitored generation step, a previously gen- 
erated (possibly) ambiguous utterance is parsed 
and the obtained alternative derivation trees are 
used as a 'guide' for re-generating the utterance. 
To achieve such an integrated approach the un- 
derlying grammar must be reversible. 
1 Introduct ion 
In many situations of communication a speaker 
need not to worry about the possible ambiguity 
of what she is saying because she can assume that 
the \]tearer will be able to disambiguate ile utter 
ance by means of contextual information or would 
otherwise ask for clarification. But in some sit- 
uations it is necessary to avoid the risk of gen- 
erating ambiguous utterances that could lead to 
misunderstanding by the hearer, e.g., during the 
proecss of writing text, where no interaction is 
possible, or when utterances refer to actions that 
have to bc performed irectly or in some specific 
dialog situations (e.g. having an interview with a 
company). 
The need to generate un-ambiguous tterances 
is also relevant for the development of natural 
language generation systems. For example in 
the case of an intelligent help-system that sup- 
ports the use of an operating system (Wilensky 
et al, 1984), asking an inexperienced user to 'f~e- 
move the folder with the system tools' could \]lave 
tremendous effects on the system itself. 
If one assumes a modular division of the natu- 
ral language generation task between two stages 
of the language production process - -  deciding 
what to say (conecplual evel) and deciding how 
to say it (grammatical level) - -  it is not realis- 
tic to expect hat the conceptual component will 
be able to specify the input for the grammatical 
component such that ambiguous utterances can 
be avoided. 
If it were possible to specify the input in such 
a way, then this would mean that the conceptual 
component has to provide all information eeded 
by the grammatical component to make decisions 
about lexieal and syntactic hoices. Hence, the 
conceptual component would need detailed in- 
formation about the language to use. But this 
would blur the distinction between the grammat- 
ical and the conceptual level, because this would 
imply that both components share the grammar 
(see also Appelt (1989), Meteer (1990), Neumann 
(1991)). 1
In order to maintain a modular design addi- 
tional mechanisms are necessary to perform some 
monitoring of the generator's output. Several 
authors argue for such additional mechanisms 
(Jameson and Wahlster, 1982; De Smedt and 
Kempen, 1987; Joshi, 1987; Levelt, 1989). For 
example, Levelt (1989) pointed out tbat "speak- 
ers monitor what they are saying and how they 
are saying it". In particular he shows that a 
speaker is also able to note that what she is say- 
ing involves a potential ambiguity for the hearer 
and can handle this problem by means of self- 
monitoring. 
In this paper we describe an approach for 
self-monitoring which allows to generate un- 
ambiguous utterances in such situations where 
possible misunderstandings by tire user have to 
be avoided. The proposed method is based on 
a very strict integration of parsing and genera- 
tion. During self-monitoring a generated ambigu 
1As pointed out in Fodor (1983) one of tim chtaxacter- 
istic properties of a module is that it is computationally 
autonomous. But a relevant coimideration of cornputa- 
tionally autonomy is that nmdules do not share sourccs 
(in our case the grarmnar). 
AcrEs DE COLING-92, NANTES. 23-28 AOL'r 1992 7 0 0 PROC. OF COLING-92. NANTES, AUG. 23-28. 1992 
ous utterance is parsed and the obtained alterna- 
tive derivation trees are use.d ms a 'guide' for the 
'monitored' generation step. We will show that 
such an integrated approach makes only sense 
with reversible grammars. To our knowledge, 
there is at present no algorithm that solves the 
problem of generating un-ambiguous utterances 
by nmans of self-monitoring. 
2 Overview of the Monitor- 
ing Algorithm 
Our approach is based on a strict integration of 
parsing and generation in that parsing is used to 
detect whether a produced utterance is ambigu- 
ous or not. The advantages of using comprehen- 
sion mechanisms to facilitate mointoriug arc for 
example mentioned in Levelt (1989). \[n his model 
parsing and generation are performed in an iso- 
lated way by means of two different granunars. 
'Phe problem with this view is that generation of 
un-ambiguous paraphrases can be very inefficient, 
because the source of the ambignons utterance is
not used to guide the generation process. 
To overcome this problem the basic idea of our 
approach is to operate with derivation tl~es ob- 
tained during the generation and parsing step. 
In short, the algorithm works as follows. Firstly, 
it is checked whether a produced utterance S of 
an input form LF is ambiguous, by parsing S~ If 
during parsing e.g. two readings LF and LF ~ are 
deduced LF is generated again along the parse 
trees obtained for S. Now an utterance S' can be 
generated that has the same meaning but differs 
with respect o the ambiguity source of S. 
In this way the derivation trees obtained dur- 
ing parsing of a previously generated utterances 
are used as a guide during monitored generation. 
Grammatical structures obtained during parsing 
arc used directly to restrict he search space dur- 
ing generation. At this point it shouhl be clear 
that the only way in order to be able to generate 
'along parsed structures' is to use reversible gram 
mars. This ensures that every sentence produced 
by the generator can be parsed. Similarly, for ev- 
ery semantic structure computed by the parser, 
the generator delivers an utterance. 
3 A monitoring strategy 
A naive s t ra tegy .  The tirst and most straight- 
forward solution to obtain Olfly nn-ambiguous t- 
terances during generation could hc described 
as a 'brute force' solution. The generator de- 
rives possible utterances for a given logical form. 
For each of these utterances it is easy to check 
whether it is ambiguous or not, by counting the 
results the parser delivers for that utterance. 
Ina  Prolog implementation this simple solution 
can be detincd as follows. Note that we assume 
for simplicity ttlat linguistic signs are represented 
with terms s ign(LF ,S t r ,Syn ,Der )  where LF 
represents tile semantic information, S t r  repre- 
sents the string and Syn represents syntactic in- 
formation. The fourtil argument position will be 
used later in this paper to represent derivation 
trees. 
monitor(sign(LF,Str,Syn,Der)):- 
geuerate(sign(LF,Str,Syn,Der)), 
unambiguous(Sir). 
tmambiguous(Str) : -  
setof(LF,D'S^parse(sign(LF,Str,S,D), 
\[El\]). 
The predicates paxse/1 and generate /1  call re- 
spectively the underlying parser and generator. 
The seto~ predicate is used to obtain the set of 
solutions of the parse  predicate, where " indi- 
cates that D and S are existentially quantified. 
By instantiating the resulting set as a set with 
exactly one element, we implement the idea that 
the utterance should be un-ambiguous (in that 
case there is only one parse result). Given Pro- 
log's search strategy this definition implies that 
the generator generates olutions until an un- 
ambiguous utterance is generated. 
The prol)lem with this 'generate and test' ap- 
proach is that the search of the generator is not 
directed by the goal to produce an un-ambiguous 
result. We will now present a more involved mon- 
itoring strategy which is oriented towards tile goal 
of producing an un-ambiguous utterance. 
Ambigu i t ies  are  of ten ' local ' .  A flmdameu- 
tal assumption is that it is often possible to obtain 
an un-ambiguous utterance by slightly changing 
an ambiguous one. 'fhus, after generating an am- 
biguous utterance, it may bc possible to change 
that utterance locally, to obtain an un-ambiguous 
utterance with the same meaning. In the ease of 
a simple lexieal ambiguity this idea is easily il- 
lustrated. Given the two meanings of the word 
'bank' ('river bank' vs. 'money institution') a 
generator may produce, as a first possibility, the 
following sentence in the eo.se of the first reading 
of 'bauk'. 
ACRES DE COLING-92, NANTES, 23-28 hOt'n 1992 7 0 1 PROC. OF COLING-92, NANTES, AUG. 23-28, 1992 
el  
/ \ 
jo lmi  aux3 
/ \ 
infll8 vp4 
I / \ 
be2 infll2 ppt 
I / \ 
stand3 nearl rip2 
/ \  
the2 bank4 
s l  
/ \ 
j olml aux3 
/ \ 
infll8 vp4 
I / \ 
be2 in~112 ppl 
I / \ 
stand3 near1 rip2 
/ \ 
the2 bemk7 
Figure 1: Derivation trees 
(I) John was standing near the bank while Mary 
tried to make a picture of him. 
To 'repair' this utterance we simply alter the word 
'bank' into the word 'river bank' and we obtain 
an un-ambiguous result. Similar examples can be 
constructed for structural ambiguities. Consider 
the German sentence: 
(2) Heute ist durch alas Au~nminister ium 
bekanntgegeben women, daft Minister van 
den Broek den jugoslawischen 
Delegationsleiter aufgefordert hat, die 
Armee aus Kroatien zuriickzuziehen. 
Today it was announced by the ministry of 
foreign affairs that minister van den Brock 
has requested the Yugoslav delegation 
leaders to withdraw the army from Croatia, 
which is ambiguous (in German) between 'with- 
draw \[the army of Croatia\]' and '\[withdraw \[the 
army\] away from Croatia\]'. In German this ambi- 
guity can be repaired locally simply by changing 
the order of 'aus Kroatien' and 'die Armee', which 
forces the second reading. Thus again we only 
need to change only a small part of the utterance 
in order for it to be un-ambiguous. 
Locat ing  ambigu i ty  w i th  der ivat ion  trees.  
We hypothesise that a good way to eharacterise 
the location of the ambiguity of an utterance is by 
referring to the notion of'derlvation tree'. We are 
assuming that the underlying rammar formalism 
comes with a notion 'derivation tree' which repre- 
sents how a certain derivation is licenced by the 
rules and lexical entries of the grammar. Note 
that such a derivation tree does not necessarily 
reflect how the parser or generator goes about 
finding such a derivation tree for a given string 
or logical form. For example, the derivation trees 
of the two readings of 'john is standing near the 
bank' may look as in figure 1. The intuition that 
the ambiguity of this sentence is local is reflected 
in these derivation trees: the trees are identical 
up to the difference between bamk4 and bank7. 
In our examples each sign s ign(LF ,St r ,Syn ,D)  
is specified for its corresponding derivation tree 
D. In Prolog such a tree is represented with terms 
of the form t;(Label,Ds,M) where Label is the 
node name (the unique name of a rule) and Ds 
is a list of Daughter trees. The third argument 
position will be explained below. 
Given a derivation tree t of a generated sen- 
tence s, we mark the places where the ambigu- 
ity occurs as follows. If s is ambiguous it can 
be parsed in several ways, giving rise to a set of 
derivation trees T = t l . . . tn .  We now compare 
t with the set of trees T in a top-down fashion. 
If for a given node label in t there are several 
possible labels at the corresponding nodes in T 
then we have found an ambiguous spot, and the 
corresponding node in t is marked. Thus, in the 
previous example of structural ambiguity we may 
first generate sentence (2) above. After checking 
wbetfier this sentence is ambiguous we obtain, as 
a result, the marked derivation tree of that sen- 
tence. A marked node in such a tree relates to 
an ambiguity. The relevant part of the resulting 
derivation tree of the example above may be the 
tree in figure 2. 
Markh lg  a der ivat ion  tree.  The predicate 
mark(Tree,Set)  marks the generated tree Tree 
given the trees Set found by the parser. Tile third 
argument M of tile terms t (Labsl,Ds,M) repre- 
ACRES DE COLING-92, Nxlcr~, 23.28 ^Or~T 1992 7 0 2 PRec. OF COLING-92, NANTES, AUG. 23-28, 1992 
vp5 
/ \ 
~ragen3 vp2 MARKED 
npl vp4 
/ \ / 
die2 armeel ppl 
/ \  
aus2 Krl 
\ 
infl4 
t 
zieh3 
Figure 2: Marked derivation tree 
senting derivation trees indicates whether the cur- 
rent node is marked (in that case the value is y) or 
not (using the value n). Subtrees of marked nodes 
have no instantiated value for this variable. 
mark(t(L,Ds,n),Set):- 
root_same(L,Set),!, 
get_ds(Set,DsSet), 
mark ds(Ds,DsSet). 
mark(t(L,Ds,y)~Set). 
root_same(L, \[\] ). 
root_same(L, \[t(L . . . .  ) IT\] ) :- 
root_same (L,T). 
mark ds ( \ [ \ ] , \ [ \ ] ) .  
mark ds(\[HlT\],\[Hs\]Ts\]):- 
mark(H,Hs), mark_ds(T,Ts). 
get_ds(\[t(_,\[\],_)l_\],\[\]). 
get ds(Set,\[~IT\]):- 
get f(Set,Sst2,H), 
get_ds(Set2,T). 
get f ( \ [ \ ] , \ [ \ ] , \ [ \ ] ) .  
get f ( \ [ t ( _ , \ [H3 IB \ ] , _ ) IT \ ] ,  
\ [ t ( _ ,B , _ ) IT2 J , \ [H3 IT3 J ) : -  
get_f(T,T2,T3). 
Chang ing  the  ambiguous parts .  Summaris- 
inK, the generator first generates a possible ut- 
terance. This utterance is then given as input 
to the monitor. The monitor calls the parser to 
find which parts of that utterance are ambiguous. 
These parts are marked in the derivation tree as- 
sociated with the utterance. Finally the monitor 
tries to generate an utterance whictl uses alterna- 
tive derivation trees for the marked, i.e. ambigu- 
ous, parts. 
Generating an utterance given a marked criva- 
tion tree proceeds as follows. The generator sim- 
ply 'repeats' the previous generation in a top- 
down fashion, as long as it encounters unmarked 
nodes. This part of the generation algorithm 
thus simply copies previous results. If a marked 
node is encountered the embedded generation al- 
gorithm is called for this partial structure. The 
result should be a different derivation tree than 
the given one. Now clearly, this may or may not 
he possible depending on the grammar. The next 
paragraph discusses what happens if it is not pos- 
sible. 
The following definition ~sumes that gram- 
mar rules are represented simply as rule(Name, 
No'thor, Ds) where Name is the rule name, 
Mother is the mother sign and Ds is a list of 
daughter signs. The predicate mgen is used to 
generate an utterance, using a marked derivation 
tree as an extra guide. 
mgen(sign(Lf,Str,S,D) ,*(Name,Ds,y)):- 
genera* e (sign(Lf ,Sir, S,D) ), 
\+ D = t(Name,Ds,_). 
mgen(sign(Lf, Str, S ,Dr, t (Name ,Ds ,n) ) : - 
rule (Name, sign (Lf, Sir, S,D), Kids ), 
mgends(Kids,Ds). 
mgen_de ( \[\], _). 
mgen_ds ( \[SIT\], \[Stree,Ttree\] ) :- 
mgen (S, Stree), 
mgen ds (T, Tire ~). 
II.edefining locality. Often it will not be pos- 
sible to generate an alternative xpression by a 
local change as wc suggested. Wc propose that 
the monitor first tries to change things ~-q local mq 
possible. If all possibilities are tried, the notion 
'locality' is redefined by going up one level. This 
process repeats itself until no more alternative so- 
lutions are possible. Thus, given a marked eriva- 
tion tree the monitored generation first tries to 
find alternatives for the marked parts of the tree. 
\]f no further possibilities exist, all markers in the 
trees are inherited by their mother nodes. Again 
the monitored generation tries to find alterna- 
tives, after which the markers are pushed upwards 
yet another level, etc. 
The following definition of the predicate 
laawkA..g(Treo, Set, Guido) will (procedurally 
speaking) first construct the 'guide' Guide given a 
derivation tree Tree and a set of derivation trees 
Set; upon backtracldng it will push the markers 
in the tree one level upward at the time. 
mark_l_g (Tree, Set, Guide ) : - 
Ama~s DE COLING-92, NANTES, 23-28 ao~" 1992 703 PROC. OV COLING-92, NANTES, Auo. 23-28, 1992 
mark  (T ree ,Set ) ,  
l_g (Tree, Guide). 
1 g (Tree ,Tree) .  
l_g(Tree, Guide) : -  
one_up(Tree, Tree2),  
l_g(Tree2 ,Guide). 
one_up(t (L,Ds ,n), t (L,Ds ,y) ) :- 
member(t( . . . .  y),Ds), ! . 
one_up(t (L,Ds ,n) ,t (L,Ds2,n)) :- 
one_up_ds (Ds, Ds2). 
one up_ds ( \ [ \ ] ,  \[\] ). 
one_up_ds ( \[H I T\] , \[H2 IT2\] ) :- 
one_up(It,It2), one_up_ds (T,T2). 
The algorithm can be completed as follows. ~ 
monitored_genorat ion (LF, Sign) :- 
generate ( sign (LF, Str, Syn,D) ), 
!, ~. stick to one.. 
monitor (sign(LF,Str,Syn,D) ,Sign). 
monitor(sign(LF,Str I, Synl,Dl), 
sign(LF,Str,Syn,D)) :- 
Find_all_parse (Strl ,TreeSet ), 
( TreeSet = \[_\] 
-> Strl = Str, Synl = Syn, DI = D 
; mark_l_g(D1 ,TreeSet ,Guide), 
mgen (sign(LF, Str, Syn,D) ,Guide), 
unambiguous (Sir) 
). 
Zind all_parse(Strl ,TreeSet) :- 
seto~ (D,LF~S'parse(sign(LF, Strl ,S.D), 
TreeSet). 
Simple at tac /nnent  example .  In order to 
clarify the monitoring strategy we will now con- 
sider how an attachment ambiguity may be 
avoided. The following German sentence consti- 
tutes a simplified example of the sort of attach- 
ment ambiguity shown in (2). 
(3) Die M~inner haben heute die Frau mit dem 
Fer nglas gesehen. 
The men have today the woman with the 
telescope seen. 
Today the men saw the woman with the 
telescope. 
2 In the actual implementation thepredicate ~ind_all _- 
parse is complicated in order to remember which parses 
were already tried. If a parse has been tried before, then 
the predicate fails because then that reslflt is either al- 
ready shown to be ambiguous, or otherwise the colTs- 
sponding solution he.s already been found. 
Suppose indeed that the generator, as a first pos- 
sibility, constructs this sentence in order to realize 
the (simplified) semantic representation: 
heute(mit(f  ernglas, sehen(pl(mann), frau) ) 
Let us assume that the corresponding derivation 
tree is the tree in figure 3. To find out whether 
topic 
/ \ 
mann verb ~see 
/ \ 
haben vp_compl 
/ \ 
frau vp_mod 
mit dem fernglass gesehen 
Figure 3: Derivation tree of German example 
this sentence is ambiguous the parser is called. 
The parser will find two results, indicating that 
the sentence is ambiguous. For the alternative 
reading tile derivation tree shown in figure 4 is 
found. 
topic 
/ \ 
mann verb_see 
/ \ 
haben vp_compl 
/ \ 
pp-mod gesehen 
/ \ 
frau mit dem fernglass 
Figure 4: Derivation tree of alternative reading 
The derivation tree of the result of generation 
is then compared with the trees assigned to the 
alternative readings (in this ease only one), given 
rise to the marked derivation tree shown in fig- 
ure 5. 
The monitored generation will then try to find 
alternative possibilities at these marked nodes, 
However, no such alternatives exist. Therefore, 
the markers are pushed up one level, obtaining 
the derivation tree given in figure 6. 
ACRES DE COLING-92. NANTES. 23-28 Aou'r 1992 7 0 4 PREC. OF COLING-92, NANTES, AUO. 23-28, 1992 
topic 
/ \ 
n lann  verb~sec 
/ \ 
haben vp_compl 
frau MARKED vpanod MARKED 
/ \ 
tnit dem fernglass gesehen 
Figure 5: Marked tree of German example 
topic 
/ \ 
YilaIln verb~see 
haben vp_eompl MARKED 
/ \ 
frau vp_mod 
/ \ 
mit dem ferngtass gesehen 
Figure 6: Markers are pushed one level upward 
At this point the monitored generator again 
tries to find alternatives for tile marked nodes, 
this time sueeessflflly yielding: 
(4) Die Mgnner haben mit dem Fernglass die 
Prau gesehen. 
At this point we may stop. However, note that 
if we ask for further possibilities we will eventu- 
ally obtain all possible results. For example, if 
the markers are pushed to the root node of the 
derivation tree we will also obtain 
(5) Mit dcm Ferngtass haben (lie Mgnner (lie 
l'?au gesehen. 
4 D iscuss ion  
Proper t ies .  Some of the important properties 
of our approach can be dmraeterised as follows. 
The strategy is sound and complete in the sense 
that no ambiguous utterances will be produced, 
and all un-ambiguous tterances are produced. If 
for a given semantic structure no nn-ambiguous 
utterance is possible, the current strategy will not 
deliver a solution (it is foreseen that in such cases 
the planner decides what should happen). 
The strategy is completely independent on the 
grammars that are bcing used (except for the re- 
li lac6 on derivation trees). Even more interest- 
ingly, the nature of the underlying parsing and 
generalion strategy is not important either. The 
strategy can thus he used with any parsing- or 
generation strategy. 
1)uri~g thc monitored generation previously 
generated structures are re-used, because only 
the ambiguous partial structures have to be re- 
generated. 
Finally, for the proposed strategy to i)e mean- 
ingful, it nmst bc the case that r*;versible gram- 
mars are being used. If this were not the case then 
it would not makc sense to compare the deriva- 
tion tree of a generation result with the derivation 
trees which the parser produces. 
Generat ion  of  Paraphrases .  In Neumann 
and van Noord (to appear) we discuss the imple- 
mentation of a variant of the monitoring strategy, 
to solve tile problem of the generation of para- 
phrases. 
If parsing an utterance has lead to several read- 
ings, one way in order to detcrmme the intended 
meaning is to start a claritication dialog, in which 
the multiple interpretations of the parsed utter- 
ancc are contr~tcd by restating them in different 
form. The dialog partner is then requested to 
almost he approllriate paraphr~qc, by e~sking her 
'Do you nrean X or Y ?'. 
The advantage of our approach is, that it will 
be ensured that the source of the ambiguity is 
used dircctly during the production of such para- 
phrases. Therefore, the generation of irrelevant 
paraphrases is avoided. 
L imi tat ions .  It should be clear that monitor- 
ing involves nlore than the. avoidance of alnhigu-- 
ities, l,evelt (1989) discusses also monitorirlg on 
the conceptual lewd and inonitoring with respect 
to social standards, lexical errors, loudness, pre- 
cision and others. Obviously, our approach is re- 
stricted in the sense that no changes to the inlmt 
LF are made. 
Meteer (1990) makes a strict distinction be- 
tween processes that can change decisions that 
operate on intermediate l vels of representatiml 
(optimisations) and others that operate on pro- 
duced text (revisions). Our strategy is an exam- 
pie of revision. Optimisations are useful when 
changes have to be done during the initial gen- 
eration process. For example, in Neumann and 
AcrEs DE COLING-92, NANTES, 23-28 AO't3T 1992 7 0 5 F"aoc. Ol: COLING-92, NANTES, AUO. 23-28, 1992 
Finkler (1990) an incremental nd parallel gram- 
matical component is described that is able to 
handle under-specified input such that it detects 
and requests missing but necessary grammatical 
information. 
Imp lementat ion .  In Levelt (1989) and Meteer 
(1990) the need for revision respectively moni- 
toring is discussed in detail although they de- 
scribe no implementations. As far as we know 
our approach is the first implementation of re- 
vising a produced utterance in order to find an 
un-ambiguous alternative. The underlying parser 
and generator are described in Shieber et al 
(1990) and van Noord (1991). We are using lex- 
icalized unification-based grammars for German 
and Dutch. 
Acknowledgements 
This research work has been partially supported 
by the German Science Foundation in its Special 
Collaborative Research Programme on Artificial 
Intelligence and Knowledge Based Systems (SFB 
314, Project N3 BiLD), and by the DFKI in the 
project DISCO, funded by the German Ministry 
for Research and Technology under Grant-No.: 
ITW 9002. 
References 
Douglas E. Appelt. Bidirectional grammars and 
the design of natural anguage generation sys- 
tems. In Y. Wilks, editor, Theoretical Issues in 
Natural Language Processing, pages 206-212. 
Hillsdale, N.J.: Erlbaum, 1989. 
K. De Smedt and G. Kempen. Incremental sen- 
tence production, self-correction and coordina- 
tion. In G. Kempen, editor, Natural Language 
Generation, pages 365-376. Martinus Nijhoff, 
Dordrecht, 1987. 
Jerry A. Fodor. The Modularity of Mind: An .Es. 
say on Faculty Psychology. A Bradford Book, 
MIT Press, Cambridge, Massachusetts, 1983. 
Anthony Jameson and Wolfgang Wahlster. User 
modelling in anaphora generation: Ellipsis and 
definite description. In ECAI, pages 222-227, 
Orsay, 1982. 
Aravind K. Joshi. Generation - a new frontier 
of natural anguage processing? In Theoretical 
Issues in Natural Language Processing 3, New 
Mexico State University, 1987. 
Willem J. M. Levelt. Speaking: From Intention 
to Articulation. MIT Press, Cambridge, Mas- 
sachusetts, 1989. 
Marie M. Meteer. The Generation Gap - the 
problem of ezpressibility in test planning. PhD 
thesis, University of Massachusetts, 1990. 
Giinter Neumann and Wolfgang Finkler. A bead- 
driven approach to incremental and parallel 
generation of syntactic structures. In Proceed- 
tugs of the 13th International Conference on 
Computational Linguistics (COL1NG), pages 
288-293, Helsinki, 1990. 
Giinter Neumann and Gertjan van Noord. Re- 
versible grammars for self-monitoring and gen- 
eration of paraphrases. In Tomek Strzalkowski, 
editor, Reversible Grammar in Natural Lan- 
guage Processing. Kluwer, to appear. 
Giinter Neumann. Reversibility and modularity 
in natural anguage generation. In Proceedings 
of the ACL Workshop on Reversible Grammar 
in Natural Language Processing, pages 31-39, 
Berkeley, 1991. 
Stuart M. Shieber, Gertjan van Noord, Robert C. 
Moore, and Fernando C.N. Pereira. Semantic- 
head-driven generation. Computational Lin- 
guistics, 16(1), 1990. 
Gertjan van Noord. Head corner parsing for dis- 
continuous constituency. In 29th Annual Meet- 
ing of the Association for Computational Lin- 
guistics, Berkeley, 1991. 
R. Wilensky, Y. Arens, and D. Chin. Talking to 
unix in english: An overview of uc. Communi- 
cations of the ACM, pages 574 593, 1984. 
ACRES DE COLING-92, NANTES, 23-28 AOUT 1992 7 0 6 PROC. OF COLING-92, NANTES, AUG. 23-28, 1992 
