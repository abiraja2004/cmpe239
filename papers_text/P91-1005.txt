AN ALGORITHM FOR PLAN RECOGNIT ION IN  
COLLABORATIVE  D ISCOURSE*  
Karen E. Lochbaum 
Aiken Computat ion  Lab 
Harvard University 
33 Oxford Street 
Cambridge,  MA 02138 
ke l~harvard .harvard .edu 
ABSTRACT 
A model of plan recognition i discourse must be based 
on intended recognition, distinguish each agent's be- 
liefs and intentions from the other's, and avoid as- 
sumptions about the correctness or completeness of
the agents' beliefs. In this paper, we present an algo- 
rithm for plan recognition that is based on the Shared- 
Plan model of collaboration (Grosz and Sidner, 1990; 
Lochbaum et al, 1990) and that satisfies these con- 
straints. 
INTRODUCTION 
To make sense of each other's utterances, conversa- 
tional participants must recognize the intentions be- 
hind those utterances. Thus, a model of intended plan 
recognition is an important component of a theory of 
discourse understanding. The model must distinguish 
each agent's beliefs and intentions from the other's and 
avoid assumptions about the correctness or complete- 
ness of the agents' beliefs. 
Early work on plan recognition in discourse, e.g. 
Allen & Perrault (1980); Sidner & Israel (1981), was 
based on work in AI planning systems, in particu- 
lar the STRIPS formalism (Fikes and Nilsson, 1971). 
However, as Pollack (1986) has argued, because these 
systems do not differentiate between the beliefs and 
intentions of the different conversational participants, 
they are insufficient for modelling discourse. Although 
Pollack proposes a model that does make this distinc- 
tion, her model has other shortcomings. In particular, 
it assumes a master/slave r lationship between agents 
(Grosz and Sidner, 1990) and that the inferring agent 
has complete and accurate knowledge of domain ac- 
tions. In addition, like many earlier systems, it relies 
upon a set of heuristics to control the application of 
plan inference rules. 
In contrast, Kautz (1987; 1990) presented a theo- 
retical formalization of the plan recognition problem, 
*This research as been supported by U S WEST Ad- 
vanced Technologies and by a Bellcore Graduate Fellow- 
ship. 
and a corresponding algorithm, in which the only con- 
clusions that are drawn are those that are "absolutely 
justified." Although Kautz's work is quite elegant, it 
too has several deficiencies as a model of plan recogni- 
tion for discourse. In particular, it is a model of keyhole 
recognition m the inferring agent observes the actions 
of another agent without that second agent's knowl- 
edge - -  rather than a model of intended recognition. 
Furthermore, both the inferring and performing agents 
are assumed to have complete and correct knowledge 
of the domain. 
In this paper, we present an algorithm for intended 
recognition that is based on the SharedPlan model of 
collaboration (Grosz and Sidner, 1990; Lochbaum et 
al., 1990) and that, as a result, overcomes the limita- 
tions of these previous models. We begin by briefly 
presenting the action representation used by the algo- 
rithm and then discussing the type of plan recogni- 
tion necessary for the construction of a SharedPlan. 
Next, we present he algorithm itself, and discuss an 
initial implementation. Finally, because Kautz's plan 
recognition Mgorithms are not necessarily tied to the 
assumptions made by his formal model, we directly 
compare our algorithm to his. 
ACTION P~EPRESENTATION 
We use the action representation formally defined by 
Balkanski (1990) for modelling collaborative actions. 
We use the term act-type to refer to a type of action; 
e.g. boiling water is an act-type that will be repre- 
sented by boil(water). In addition to types of actions, 
we also need to refer to the agents who will perform 
those actions and the time interval over which they will 
do so. We use the term activity to refer to this type 
of information1; e.g. Carol's boiling water over some 
time interval (tl) is an activity that will be represented 
by (boil(water),carol,tl). Throughout the rest of this 
paper, we will follow the convention of denoting ar- 
bitrary activities using uppercase Greek letters, while 
using lowercase Greek letters to denote act-types. In 
1This terminology supersedes that used in (Lochbaum 
et al, 1990). 
33 
Relations 
Constructors 
Act-type Activity 
CGEN(71,72,C) 
CENABLES(7~,~f2,C) 
sequence(v1 ,...,Tn) 
simult(71 .... ,7-) 
conjoined(v1 ,.-.,7n) 
iteration(AX.v\[XJ,{X1,...Xn}) 
GEN(r,,r~) 
ENABLES(FI,r2) 
g(r l  ..... r , )  
I(Ax.rixl,iX~,...x,}) 
Table 1: Act-type/Activity Relations and Constructors defined by Balkanski (1990) 
addition, lowercase letters denote the act-type of the 
activity represented by the corresponding uppercase 
letter, e.g. 7 -- act-type(F). 
Balkanski also defines act-type and activity con- 
structors and relations; e.g. sequence(boil(water), 
add(noodles,water)) represents the sequence of doing 
an act of type boil(water) followed by an act of type 
add(noodles,water), while CGEN(mix(sauce,noodles), 
make(pasta_dish),C) represents that the first act-type 
conditionally generates the second (Goldman, 1970; 
Pollack, 1986). Table 1 lists the act-type and corre- 
sponding activity relations and constructors that will 
be used in this paper. 
Act-type constructors and relations are used in 
specifying recipes. Following Pollack (1990), we use 
the term recipe to refer to what an agent knows 
when the agent knows a way of doing something. 
As an example, a particular agent's recipe for lift- 
ing a piano might be CGEN(simult(lift(foot(piano)), 
lift(keyboard(piano))), lift(piano), AG.\[IGI=2\]); this 
recipe encodes that simultaneously lifting the foot- and 
keyboard ends of a piano results in lifting the piano, 
provided that there are two agents doing the lifting. 
For ease of presentation, we will sometimes represent 
recipes graphicMly using different ypes of arrows to 
represent specific act-type relations and constructors. 
Figure 1 contains the graphical presentation of the pi- 
ano lifting recipe. 
lift(pi~o) 
\]" AG.\[IGI-= 2\] 
simult (lift (foot (piano)),lift (keyboaxd(piano))) 
c, / \c2 
lift(foot(piano)) lift (keyboaxd (piano)) 
TC indicates generation subject to the condition C 
c~/indicates constituent i of a complex act-type 
Figure 1: A recipe for lifting a piano 
THE SHAREDPLAN AUGMENTATION 
ALGORITHM 
A previous paper (Lochbaum et hi., 1990) describes 
an augmentation algorithm based on Grosz and Sid- 
ner's SharedPlan model of collaboration (Grosz and 
Sidner, 1990) that delineates the ways in which an 
agent's beliefs are affected by utterances made in the 
context of collaboration. A portion of that algorithm 
is repeated in Figure 2. In the discussion that follows, 
we will assume the context specified by the algorithm. 
SharedPlan*(G1,G2,A,T1,T2) represents that G1 and 
G2 have a partial SharedPlan at time T1 to perform 
act-type A at time T2 (Grosz and Sidner, 1990). 
Assume: 
Act is an action of type 7, 
G~ designates the agent who communicates Prop(Act), 
Gj designates the agent being modelled 
i, j E {1,2}, i ~ j, 
SharedPlan*(G1 ,G~,A,T1,T2). 
4. Search own beliefs for Contributes(7,A) and where pos- 
sible, more specific information as to how 7 contributes 
to A. 
Figure 2: The SharedPlan Augmentation Algorithm 
Step (4) of this algorithm is closely related to the 
standard plan recognition problem. In this step, agent 
Gj is trying to determine why agent G~ has mentioned 
an act of type 7, i.e. Gj is trying to identify the role 
Gi believes 7 will play in their SharedPlan. In our 
previous work, we did not specify the details of how 
this reasoning was modelled. In this paper, we present 
an algorithm that does so. The algorithm uses a new 
construct: augmented rgraphs. 
AUGMENTED RGRAPH CONSTRUCTION 
Agents Gi and Gj each bring to their collaboration pri- 
vate beliefs about how to perform types of actions, i.e. 
recipes for those actions. As they collaborate, a signifi- 
cant portion of their communication is concerned with 
deciding upon the types of actions that need to be per- 
formed and how those actions are related. Thus, they 
establish mutual belief in a recipe for action s. In ad- 
dition, however, the agents must also determine which 
2Agents do not necessarily discuss actions in a fixed or- 
der (e.g. the order in which they appear in a recipe). Con- 
sequently, our algorithm is not constrained to reasoning 
about actions in a fixed order. 
34 
agents will perform each action and the time inter- 
val over which they will do so, in accordance with the 
agency and timing constraints specified by their evolv- 
ing jointly-held recipe. To model an agent's reasoning 
in this collaborative situation, we introduce a dynamic 
representation called an augmented recipe graph. The 
construction ofan augmented recipe graph corresponds 
to the reasoning that an agent performs to determine 
whether or not the performance of a particular activ- 
ity makes ense in terms of the agent's recipes and the 
evolving SharedPlan. 
Augmented recipe graphs are comprised of two 
parts, a recipe graph or rgraph, representing activities 
and relations among them, and a set of constraints, 
representing conditions on the agents and times of 
those activities. An rgraph corresponds to a partic- 
ular specification of a recipe. Whereas a recipe rep- 
resents information about the performance, in the ab- 
stract, of act-types, an rgraph represents more spe- 
cialized information by including act-type performance 
agents and times. An rgraph is a tree-like representa- 
tion comprised of (1) nodes, representing activities and 
(2) links between odes, representing activity relations. 
The structure of an rgraph mirrors the structure of the 
recipe to which it corresponds: each activity and ac- 
tivity relation in an rgraph is derived from the corre- 
sponding act-type and act-type relation in its associ- 
ated recipe, based on the correspondences in Table 1. 
Because the constructors and relations used in specify- 
ing recipes may impose agency and timing constraints 
on the successful performance ofact-types, the rgraph 
representation is augmented by a set of constraints. 
Following Kautz, we will use the term explaining to 
refer to the process of creating an augmented rgraph. 
AUGMENTED RGRAPH SCHEMAS 
To describe the explanation process, we will assume 
that agents Gi and Gj are collaborating to achieve an 
act-type A and Gi communicates a proposition from 
which an activity F can be derived 3 (cf. the assump- 
tions of Figure 2). Gj's reasoning in this context is 
modelled by building an augmented rgraph that ex- 
plains how F might be related to A. This representa- 
tion is constructed by searching each of Gj's recipes for 
A to find a sequence of relations and constructors link- 
ing 7 to A. Augmented rgraphs are constructed during 
this search by creating appropriate nodes and links as 
each act-type and relation in a recipe is encountered. 
By considering each type of relation and construc- 
tor that may appear in a recipe, we can specify gen- 
eral schemas expressing the form that the correspond- 
ing augmented rgraph must take. Table 2 contains 
the schemas for each of the act-type relations and 
3F need not include a complete agent or time specifica- 
tion. 
constructors 4. 
The algorithm for explaining an activity F according 
to a particular ecipe for A thus consists of consider- 
ing in turn each relation and constructor in the recipe 
linking 7 and A and using the appropriate schema 
to incrementally build an augmented rgraph.. Each 
schema specifies an rgraph portion to create and the 
constraints to associate with that rgraph. If agent 
G/ knows multiple recipes for A, then the algorithm 
attempts to create an augmented rgraph from each 
recipe. Those augmented rgraphs that are successfully 
created are maintained as possible explanations for F 
until more information becomes available; they repre- 
sent Gj's current beliefs about Gi's possible beliefs. 
If at any time the set of constraints associated with 
an augmented rgraph becomes unsatisfiable, a failure 
occurs: the constraints stipulated by the recipe are not 
met by the activities in the corresponding r raph. This 
failure corresponds to a discrepancy between agent 
Gj's beliefs and those Gj has attributed to agent G~. 
On the basis of such a discrepancy, agent G i might 
query Gi, or might first consider the other recipes that 
she knows for A (i.e. in an attempt to produce a suc- 
cessful explanation using another ecipe). The algo- 
rithm follows the latter course of action. When a recipe 
does not provide an explanation for F, it is eliminated 
from consideration and the algorithm continues look- 
ing for "valid" recipes. 
To illustrate the algorithm, we will consider the 
reasoning done by agent Pare in the dialogue in 
Figure 3; we assume that Pam knows the recipe 
given in Figure 1. To begin, we consider the ac- 
tivity derived from utterance (3) of this discourse: 
F1 =(lift(foot(piano)), {joe},tl), where tl is the time in- 
terval over which the agents will lift the piano. To ex- 
plain F1, the algorithm creates the augmented rgraph 
shown in Figure 4. It begins by considering the other 
act-types in the recipe to which 7x=lift(foot(piano))is 
related. Because 71 is a component of a simultaneous 
act-type, the simult schema is used to create nodes N1, 
N2, and the link between them. A constraint of this 
schema is that the constituents of the complex activ- 
ity represented by node N2 have the same time. This 
constraint is modelled irectly in the rgraph by creat- 
ing the activity corresponding to lift(keyboard(piano)) 
to have the same time as F1. No information about 
the agent of this activity is known, however, so a vari- 
able, G1, is used to represent the agent. Next, because 
the simultaneous act-type is related by a CGEN rela- 
tion to lift(piano), the CGEN schema is used to create 
node N3 and the link between N2 and N3. The first 
two constraints of the schema re satisfied by creating 
node N3 such that its activity's agent and time are the 
4The technicM report (Lochbaum, 1991) contains amore 
detailed iscussion of the derivation of these schemas from 
the definitions given by Balkanski (1990). 
35 
Recipe Augmented Rgraph 
Rgraph Constraints 
CGEN(7, 6,C) 
CENABLES(7, 6,C) 
sequence(71,72,...7-) 
conjoined(71,72, ...7-) 
simult (71,72, ...7,) 
iteration(AX.7\[X\], 
{Xa, X2, ...X,}) 
(6,G,T) 
T GEN 
r 
(8, G,T) 
~r ENABLES 
r 
K(rl, r2, ..., r , )=A 
I ci 
r~ 
K(rl, r2 .... r , )=A 
J ci 
ri 
K(ra, r2, :..r,)=A 
I cl 
r~ 
I(AX.r\[x\], {X~, ...X~})=A 
I ci 
\[xx.rixllx~ 
G=agent(r) 
T=time(r) 
HOLDS'(C,G,T) 
HOLDS'(C,agent(r),time(r)) 
BEFORE(time(F),T) 
Yj BEFORE(time(r)),time(rj+l)) 
agent(A)=Ujagent(rj) 
time(A)=cover_interval({time(rj )})~. 
agent(A)=Ujagent(rj) 
time(A)=coverAnterval({ time(r) )) 
Yj time(r3)=time(rj+,) 
agent (A)=~j j  agent ( r , )  
time(A)=coverAnterval({time(rj )}) 
agent(A)=agent(r) 
time(A)=time(r) 
Table 2: Rgraph Schemas 
same as node N2's. The third constraint is instantiated 
and associated with the rgraph. 
(1) Joe: I want to lift the piano. 
(2) Pare: OK. 
(3) Joe: On the count of three, I'll pick up this 
\[deictic to foot\] end, 
(4) and you pick up that 
\[deictic to keyboard\] end. 
(5) Pam: OK. 
(6) Joe: One, two, three! 
Figure 3: A sample discourse 
Rgraph: 
NS:{lift(piano),{joe} v G 3,tl) 
1" GEN 
N2:K({lift(foot(pitmo)),{joe},t 1},0ift(keyboard(piano)),G1 ,t 1}) 
I cl 
N 1: 0ift (foot (piano)),{joe } #1} 
ConBtrainta: {HOLDS'(AG.\[\[G I -- 2\],{joe} u Gl,tl)} 
Figure 4: Augmented rgraph explaining (lift(foot(pi- 
ano)),{joe},tl) 
MERGING AUGMENTED RGRAPHS 
As discussed thus far, the construction algorithm pro- 
duces an explanation for how an activity r is related 
to a goal A. However, to properly model collaboration, 
one must also take into account he context of previ- 
ously discussed activities. Thus, we now address how 
the algorithm explains an activity r in this context. 
Because Gi and Gj are collaborating, it is appropri- 
ate for Gj to assume that any activity mentioned by 
Gi is part of doing A (or at least that Gi believes that 
it is). If this is not the case, then Gi must explicitly 
indicate that to Gj (Grosz and Sidner, 1990). Given 
this assumption, Gj's task is to produce a coherent ex- 
planation, based upon her recipes, for how all of the 
activities that she and Gi discuss are related to A. 
We incorporate this model of Gj's task into the algo- 
rithm by requiring that each recipe have at most one 
corresponding augmented rgraph, and implement this 
restriction as follows: whenever an rgraph node corre- 
sponding to a particular act-type in a recipe is created, 
the construction algorithm checks to see whether there 
is Mready another node (in a previously constructed 
rgraph) corresponding to that act-type. If so, the al- 
gorithm tries to merge the augmented rgraph currently 
under construction with the previous one, in part by 
merging these two nodes. In so doing, it combines the 
information contained in the separate xplanations. 
The processing of utterance (4) in the sample di- 
Mogue illustrates this procedure. The activity de- 
rived from utterance (4) is r2=(lifl(keyboard(piano)), 
{pare}, tl). The initial augmented rgraph portion cre- 
ated in explaining this activity is shown in Figure 
5. Node N5 of the rgraph corresponds to the act- 
type simult(lifl(foot(piano)),lift(keyboard(piano))) and 
includes information derived from r2. But the rgraph 
(in Figure 4) previously constructed in explaining r l  
also includes a node, N2, corresponding to this act-type 
(and containing information derived from rl) .  Rather 
than continuing with an independent explanation for 
r2, the algorithm attempts to combine the information 
5The function cover_interval takes a set of time intervals 
as an argument and returns a time interval spanning the 
set (Balkanski, 1990). 
from the two activities by merging their augmented 
rgraphs. 
Rgraph: 
NS:K((lift(foot(piano)),G2,t 1),(lift(keyboard(piano)),{pam} ,tl)) 
I c2 
N4:(lift (keyboard(piano)),{pam} ,tl) 
Constraints:{} 
Figure 5: Augmented rgraph partially explaining 
(lift(keyboard(piano)) ,{pain} ,tl) 
Two augmented rgraphs are merged by first merg- 
ing their rgraphs at the two nodes corresponding to 
the same act-type (e.g. nodes N5 and N2), and then 
merging their constraints. Two nodes are merged by 
unifying the activities they represent. If this unifica- 
tion is successful, then the two sets of constraints are 
merged by taking their union and adding to the result- 
ing set the equality constraints expressing the bindings 
used in the unification. If this new set of constraints 
is satisfiable, then the bindings used in the unification 
are applied to the remainder of the two rgraphs. Oth- 
erwise, the algorithm fails: the activities represented in
the two rgraphs are not compatible. In this case, be- 
cause the recipe corresponding to the rgraphs does not 
provide an explanation for all of the activities discussed 
by the agents, it is removed from further consideration. 
The augmented rgraph resulting from merging the two 
augmented rgraphs in Figures 4 and Figure 5 is shown 
in Figure 6. 
Rgraph: 
N3:{lift (piano),{joe,pam} ,tl)
T GEN 
N2:K((lift (foot (piano)),{joe} ,tl),(lift(keyboard(piano)),{pam} ,tl)) 
/ ?1 \ ?2 
N1 :(lift(foot(piano)),{joe},t 1) N4:(lift(keyboard(piano)),{pam},t 1 ) 
Constraints: {HOLDS'(AG.IlG I = 2\],{joe} Lt Gl,t l) ,  Gl={pam}} 
Figure 6: Augmented rgraph resulting from merging 
the augmented rgraphs in Figures 4 and 5 
IMPLEMENTATION 
An implementation of the algorithm is currently un- 
derway using the constraint logic programming lan- 
guage, CLP(7~) (Jaffar and Lassez, 1987; Jaffar and 
Miehaylov, 1987). Syntactically, this language is very 
similar to Prolog, except that constraints on real- 
valued variables may be intermixed with literals in 
rules and goals. Semantically, CLP(~) is a generaliza- 
tion of Prolog in which unifiability is replaced by solv- 
ability of constraints. For example, in Prolog, the pred- 
icate X < 3 fails if X is uninstantiated. In CLP(~), 
however, X < 3 is a constraint, which is solvable if 
there exists a substitution for X that makes it true. 
Because many of the augmented rgraph constraints 
are relations over real-valued variables (e.g. the time 
of one activity must be before the time of another), 
CLP(T~) is a very appealing language in which to im- 
plement he augmented rgraph construction process. 
The algorithm for implementing this process in a logic 
programming language, however, differs markedly from 
the intuitive algorithm described in this paper. 
RGRAPHS AND CONSTRAINTS VS. EGRAPHS 
Kautz (1987) presented several graph-based algorithms 
derived from his formal model of plan recognition. In 
Kautz's algorithms, an explanation for an observation 
is represented in the form of an explanation graph or 
egraph. Although the term rgraph was chosen to par- 
allel Kautz's terminology, the two representations and 
algorithms are quite different in scope. 
Two capabilities that an algorithm for plan recog- 
nition in collaborative discourse must possess are the 
abilities to represent joint actions of multiple agents 
and to reason about hypothetical ctions. In addition, 
such an algorithm may, and for efficiency should, ex- 
ploit assumptions of the communicative situation. The 
augmented rgraph representation and algorithm meet 
these qualifications, whereas the egraph representation 
and algorithms do not. 
The underlying action representation used in r- 
graphs is capable of representing complex relations 
among acts, including simultaneity and sequentiality. 
In addition, relations among the agents and times of 
acts may also be expressed. The action representation 
used in egraphs is, like that in STRIPS, simple step de- 
composition. Though it is possible to represent simul- 
taneous or sequential actions, the egraph representa- 
tion can only model such actions if they are performed 
by the same agent. This restriction is in keeping with 
Kautz's model of keyhole recognition, but is insuffi- 
cient for modelling intended recognition in multiagent 
settings. 
Rgraphs are only a part of our representation. Aug- 
mented rgraphs also include constraints on the activ- 
ities represented in the rgraph. Kautz does not have 
such an extended representation. Although he uses 
constraints to guide egraph construction, because they 
are not part of his representation, his algorithm can 
only check their satisfaction locally. In contrast, by col- 
lecting together all of the constraints introduced by the 
different relations or constructors in a recipe, we can 
exploit interactions among them to determine unsat- 
isfiability earlier than an algorithm which checks con- 
straints locally. Kautz's algorithm checks each event's 
constraints independently and hence cannot determine 
satisfiability until a constraint is ground; it cannot, for 
example, reason that one constraint makes another un- 
satisfiable. 
Because agents involved in collaboration dedicate a
significant portion of their time to discussing the ac- 
tions they need to perform, an algorithm for rood- 
37 
elling plan recognition in discourse must model rea- 
soning about hypothetical and only partially specified 
activities. Because the augmented rgraph representa- 
tion allows variables to stand for agents and times in 
both activities and constraints, it meets this criteria. 
Kautz's algorithm, however, models reasoning about 
actual event occurrences. Consequently, the egraph 
representation does not include a means of referring to 
indefinite specifications. 
In modelling collaboration, unless explicitly indi- 
cated otherwise, it is appropriate to assume that all 
acts are related. In the augmented rgraph construction 
algorithm, we exploit this by restricting the reasoning 
done by the algorithm to recipes for A, and by combin- 
ing explanations for acts as soon as possible. Kautz's 
algorithm, however, because it is based on a model of 
keyhole recognition, does not and cannot make use of 
this assumption. Upon each observation, an indepen- 
dent egraph must be created explaining all possible 
uses of the observed action. Various hypotheses are 
then drawn and maintained as to how the action might 
be related to other observed actions. 
CONCLUSIONS ~ FUTURE DIRECTIONS 
To achieve their joint goal, collaborating agents must 
have mutual beliefs about the types of actions they will 
perform to achieve that goal, the relations among those 
actions, the agents who will perform the actions, and 
the time interval over which they will do so. In this 
paper, we have presented a representation, augmented 
rgraphs, modelling this information and have provided 
an algorithm for constructing and reasoning with it. 
The steps of the construction algorithm parallel the 
reasoning that an agent performs in determining the 
relevance of an activity. The algorithm does not re- 
quire that activities be discussed in a fixed order and 
allows for reasoning about hypothetical or only par- 
tially specified activities. 
Future work includes: (1) adding other types of con- 
straints (e.g. restrictions on the parameters of actions) 
to the representation; (2) using the augmented rgraph 
representation i  identifying, on the basis of unsatisfi- 
able constraints, particular discrepancies in the agents' 
beliefs; (3) identifying information conveyed in Gi's 
utterances as to how he believes two acts are related 
(Balkanski, 1991) and incorporating that information 
into our model of Gj's reasoning. 
ACKNOWLEDGMENTS 
I would like to thank Cecile Balkanski, Barbara Grosz, 
Stuart Shieber, and Candy Sidner for many helpful 
discussions and comments on the research presented 
in this paper. 
REFERENCES 
Allen, J. and Perrault, C. 1980. Analyzing intention 
in utterances. Artificial Intelligence, 15(3):143-178. 
Balkanski, C. T. 1990. Modelling act-type relations 
in collaborative activity. Technical Report TR-23- 
90, Harvard University. 
Balkanski, C. T. 1991. Logical form of complex sen- 
tences in task-oriented ialogues. In Proceedings of 
the 29th Annual Meeting of the ACL, Student Ses- 
sion, Berkeley, CA. 
Fikes, R. E. and Nilsson, N. J. 1971. STRIPS: A new 
approach to the application of theorem proving to 
problem solving. Artificial Intelligence, 2:189-208. 
Goldman, A. I. 1970. A Theory Of Human Action. 
Princeton University Press. 
Grosz, B. and Sidner, C. 1990. Plans for discourse. 
In Cohen, P., Morgan, J., and Pollack, M., editors, 
Intentions in Communication. MIT Press. 
Jaffar, J. and Lassez, J.-L. 1987. Constraint logic 
programming. In Proceedings of the 14th ACM 
Symposium on the Principles of Programming Lan- 
guages, pages 111-119, Munich. 
Jaffar, J. and Michaylov, S. 1987. Methodology and 
implementation f a CLP system. In Proceedings of 
the .~th International Conference on Logic Program- 
ming, pages 196-218, Melbourne. MIT Press. 
Kautz, H. A. 1987. A Formal Theory of Plan Recog- 
nition. PhD thesis, University of Rochester. 
Kautz, H. A. 1990. A circumscriptive theory of 
plan recognition. In Cohen, P., Morgan, J., and 
Pollack, M., editors, Intentions in Communication. 
MIT Press. 
Lochbaum, K. E., Grosz, B. J., and Sidner, C. L. 
1990. Models of plans to support communica- 
tion: An initial report. In Proceedings of AAAI-90, 
Boston, MA. 
Lochbaum, K. E. 1991. Plan recognition in collabo- 
rative discourse. Technical report, Harvard Univer- 
sity. 
Pollack, M. E. June 1986. A model of plan inference 
that distinguishes between the beliefs of actors and 
observers. In Proceedings of the 2~th Annual Meeting 
of the ACL. 
Pollack, M. E. 1990. Plans as complex mental at- 
titudes. In Cohen, P., Morgan, J., and Pollack, M., 
editors, Intentions in Communication. MIT Press. 
Sidner, C. and Israel, D. J. 1981. Recognizing in- 
tended meaning and speakers' plans. In Proceedings 
of IJCAI-81. 
38 
