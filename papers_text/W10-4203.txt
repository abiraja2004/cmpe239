Generating Referring Expressions with Reference Domain Theory
Alexandre Denis
TALARIS team / UMR 7503 LORIA/INRIA
Lorraine. Campus scientifique, BP 239
F-54506 Vandoeuvre-le`s-Nancy cedex
alexandre.denis@loria.fr
Abstract
In this paper we present a reference gen-
eration model based on Reference Domain
Theory which gives a dynamic account of
reference. This reference model assumes
that each referring act both relies and up-
dates the reference context. We present a
formal definition of a reference domain, a
generation algorithm and its instantiation
in the GIVE challenge.
1 Introduction
Reference is a process in which participants interpret
and produce their referring expressions according to
the previous context. But as Stalnaker puts it: the
discourse context ?is both the object on which speech
acts act and the source of the information relative to
which speech acts are interpreted? (Stalnaker, 1998).
To put it briefly, referring acts not only rely on the
context to produce a reference but also modify it.
This aspect is not taken into account in the classi-
cal generation algorithm by (Dale and Reiter, 1995).
Each referent is generated by discriminating it inside
a context. However, the construction and update of
this context is not adressed.
Further literature on reference generation partially
gives an account for the dynamic nature of the re-
ferring process. For example in (Krahmer and The-
une, 2002), each referring act increases the salience
of the referent such that further references can be
made according to a smaller context, namely the set
of objects whose salience is greater than the referent?s
salience. Reference Domain Theory (RDT) (Reboul,
1998; Salmon-Alt and Romary, 2001) goes a step fur-
ther by assuming that referring acts make salient the
context sets themselves. This theory addresses the
construction and update of the context sets, called
in this theory reference domains. The goal of a re-
ferring act is then to discriminate a referent inside
a reference domain but also a reference domain in
a set of reference domains that we call here referen-
tial space. Moreover each referring act presupposes
a given state of the referential space, and the ex-
plicit representation of these presuppositions as con-
straints on the suitable domain for interpretation or
generation allows the implementation of a reversible
reference module. We will focus here on generation.
Details about the interpretation side of RDT can be
found in (Salmon-Alt and Romary, 2001; Denis et
al., 2006).
However most of the previous work on RDT
does not address computational details. Although
(Salmon-Alt and Romary, 2000) provides a genera-
tion algorithm, the formal definition of a reference
domain and the explicit representation of the con-
straints are not provided. In this paper we show how
RDT can be used to generate referring expressions.
The context of our work is the GIVE challenge (By-
ron et al, 2007; Byron et al, 2009). This challenge
aims to evaluate instruction generation systems in a
situated setting. The goal is to provide instructions
to a player in a 3D maze in order to guide him to find
a hidden trophy. We are here interested with the re-
ferring aspect involved in GIVE: the player has to
push buttons to open doors or disable alarms, thus
the system has to generate referring expressions to
these buttons.
We first present in section 2 some definitions, then
in section 3 we detail a generic generation algorithm.
Section 4 shows a use case of RDT in the context of
the GIVE challenge and provides a detailed exam-
ple of the reference process. The presented model is
generic, but all the examples given throughout the
paper refer to the GIVE setting. Eventually, in sec-
tion 6 we conclude the paper by demonstrating the
success of RDT in an evaluation based on the GIVE
setting.
2 Definitions
The referring process is a discrimination process
whose goal is to discriminate one or more individ-
uals in a context set. The discrimination can make
use of different sources of information. It can be a
semantic discrimination, for instance by uttering se-
mantic properties possessed by the referent to rule
out distractors, e.g. ?the blue button?. It can be
a discrimination of the focus, that is to make use of
the current center of attention, e.g. ?this button?
or ?the other button?. The discrimination can also
rely on the previous referring acts, for instance when
uttering ?Push a blue button. Yes this one?, where
?this one? would be unambiguously uttered in a con-
text of a red and a blue button thanks to the mention
of ?a blue button?. A reference model has to take
into account these different ways to discriminate.
On the other hand, a reference model has also to
consider how objects are grouped together to form
the context sets. They can be constructed thanks to
similarity or proximity of objects (Thorisson, 1994),
by the gestures that are made (Landragin, 2006) or
by the discourse itself (Denis et al, 2006). We will
be limited to the dimension of semantic similarity in
this paper.
RDT claims that the context sets (reference do-
mains or RD) are structures that both gather indi-
viduals and discriminate them. A reference domain
is basically a set of objects that share some seman-
tic description N . A partition that discriminates the
elements is also attached to the domain. The parti-
tion is based on a differentiation criterion such that
two elements being discriminated with this criterion
are put in two different equivalency classes. For in-
stance, in a domain of two buttons, one blue and
one red, the two individuals share the same type and
are differentiated with the color. While each one is
?a button?, they can unambiguously be referred to
with ?the blue button? and ?the red button? (or even
shorter ?blue?, ?red?).
Different elements of a domain may be more or less
focused/salient depending on the visual scene, or on
the previous discriminations. We are assuming that
the focus is defined as the most salient parts of the
partition of a domain and can thus be represented as
a subset of the partition. This is a binary state, that
is, a part is focused or not. While it removes the
possibility to have different degrees of focus inside a
domain, it would help modeling a preference to focus
similar objects together. We did not explore though
the empirical relevance of this hypothesis.
We assume that each domain could be said more
or less salient in a set of reference domains, called
a referential space or RS. The referential space is a
storage for the domains that have been created so
far. We consider here it is unique and shared. In the
GIVE setting, the RS is actually not shared because
the player does not know the maze a priori while the
system knows it completely. But we assume that the
RS is limited to the current room where the player is
standing. Each time the player enters a new room,
the RS is refreshed and a new one is built. We then
suppose that the player is able to access the objects
by walking around, and hence that the RS is shared,
removing problems related to asymmetry.
The referential space provides a traversal order for
the reference domains it contains. The most salient
RD are tested first. While it would be interesting
to model visual salience in the GIVE setting (Lan-
dragin, 2006), we are limited to equate salience and
recency. Thus, each domain will be associated to a
number indicating how recently it has been selected.
The way the salience or the whole RS is affected by
the discrimination process is described in section 3.2.
We now provide a formal definition of a reference do-
main and a referential space building algorithm.
2.1 Reference domains
We assume that ?E, V ? is an environment composed
of E, the universe of all objects and V , the set
of ground predicates that hold in the environment.
Props is a set of unary predicates names such as blue,
red, left, or right. Types is a set of types of unary
predicates such as color, or position. We distinguish
two disjoint subsets of Types, Typespers the persis-
tent types, that are all the properties that describe
permanently the objects, and Typestrans the tran-
sient types, that are all the properties that change
across time. val is the function val : Types? 2Props
which maps a type on the predicates names, e.g.
val(color) = {blue, red, green, yellow}
A reference domain D is a tuple
?GD, SD, ?D, (c, P, F )?
where:
? GD ? E is the set of objects of the domain,
called the ground of the domain.
? SD ? Props is the semantic description of the
domain, such that ?p ? SD,?x ? GD, p(x) ? V ,
that is, SD is a description satisfied for all the
elements of the ground.
? ?D ? N is the salience of the domain
And (c, P, F ) is a partition structure where:
? c ? Types is a differentiation criterion
? P is the partition generated by c, that is, if we
define the equivalence relation
Rc(x, y) ? ?p ? val(c), p(x) ? V ? p(y) ? V
then P = GD/Rc, i.e. P is the quotient set of
GD by Rc.
? F ? P is the focus of P .
For instance, a domain composed of two buttons,
b1 a blue button and b2 a red button, with a salience
equal to 3, where b1 and b2 are differentiated using
the color, and where b1 is in focus, would be noted
as:
D =?{b1, b2}, {button}, 3,
(color, {{b1}, {b2}}, {{b1}})?
2.2 Referential space
The referential space RS is the set of existing do-
mains. In the GIVE context, we assumed that it is
both shared and refreshed each time the player enters
a room. The initial construction of the RS consists
in grouping all the objects of the room that are sim-
ilar inside new reference domains. The RS can be
viewed as a tree-like structure whose nodes are RD.
The root node is a RD whose ground is all objects of
the room. For a node domain D, and for each part
of its partition which is not a singleton, there exists
a child domain which discriminates the elements of
the part. In other words, if a domain does not dis-
criminate some individuals of its ground there exists
another domain which does. Formally, the RS has to
respect the following proposition where PD denotes
the partition of D.
?D ? RS,?P ? PD,
|P | > 1? ?D? ? RS;GD? = P ? |PD? | > 1
In order to make sure that all the individuals could
be discriminated, and thus focused, we introduce the
default partition structure of a set X, which is a par-
tition structure where the criterion is the identifier
of objects and that contains then only singletons, we
note def(X) the default partition of a set X, that is
def(X) = (id, X/Rid, ?).
To build initially the RS, the grouping algorithm
(figure 1) is the following: it takes a list of types T
(T0 means the head, and T1..n the tail) which corre-
sponds to different properties to group the objects.
We are here only using the permanent properties of
objects, that is in GIVE their type and their color,
ordered arbitrarly. It takes also an input domain
which has a default partition. It then tries to parti-
tion the ground of this domain with the first prop-
erty. If this property does not partition the ground,
the next property is tested. If this property parti-
tions the ground, a new domain is created for each
non-singleton part of the partition, and the algo-
rithm tries to partition it with the next property,
so on recursively. We note sh(X, c) the set of prop-
erties of the type c that are shared by all elements of
X: sh(X, c) = {p|p ? val(c),?x ? X; p(x) ? V }.
This partitioning algorithm is slightly different
from the partitioning algorithm called IApart found
in (Gatt and van Deemter, 2007). First, it only par-
titions a set of objects using one unique property,
whereas in IApart the same set of objects can be
partitioned several times. And second, while IApart
?destroys? the ground that is partitioned, our par-
titioning algorithm maintains both the ground and
the partition attached to the domain.
1: RS ? RS ? {D}
2: if T 6= ? then
3: P ? GD/RT0
4: if |P | = 1 then
5: SD ? SD ? sh(GD, T0)
6: createPartitions(D, T1..n, RS)
7: else
8: set (T0, P, ?) as D?s partition structure
9: for all X ? P such that |X| > 1 do
10: D? ? ?X,SD ? sh(X,T0), ?D,def(X)?
11: createPartitions(D?, T1..n, RS)
12: end for
13: end if
14: end if
Figure 1: createPartitions(D, T , RS)
3 Referring
In this section we detail the generation algorithm
in RDT. It implements a dynamic view of referring
whereby each referring act updates the current ref-
erential space. This incremental update of the refer-
ential space proceeds in three steps. First, a domain
containing the referent is found. Then this domain
is used to match a so called underspecified domain
(Salmon-Alt and Romary, 2001). Third, the input
RS is restructured relative to the selected reference
domain.
The approach enables the implementation of a
type B reversible reference module (Klarner, 2005),
that is a module in which both directions share the
Expression U(N, t) matches D iff ?(c, P, F ) ? D;
this one F = {{t}} ? msd(D)
this N F = {{t}} ? t ? NI
the N t ? NI ? {t} ? P ? ?X?P,X 6={t}?X?NI =?
the other one F 6= ? ? P \ F = {{t}} ? msd(D)
the other N F 6= ? ? P \ F = {{t}} ?GD ? N
I
another one F 6= ? ? {t} ? P \ F ? msd(D)
another N F 6= ? ? {t} ? P \ F ?GD ? N
I
a N t ? NI ? t ? GD
Table 1: Underspecified domains for each type of
referring expression
same resources, namely a set of underspecified do-
mains. In interpretation, the goal is to check for
each existing domain if it matches the underspeci-
fied domain obtained from the referring expression.
In generation, the idea is the opposite, that is, to
check from an existing domain and a referent, which
underspecified domain matches them.
We first introduce the different types of underspec-
ified domains. We then present the overall referring
algorithm and the process steering the continuous
update of the referential space.
3.1 Underspecified domains
An underspecified domain (UD) represents a par-
tially specified reference domain corresponding to the
constraints carried by a referring act. We will say
that an underspecified domain matches a reference
domain if all the constraints of the UD are satis-
fied for the reference domain. There may be con-
straints on the ground of the domain, its salience
or the existence of a particular partition structure.
Table 1 summarizes most of the types of under-
specified domains described in (Salmon-Alt and Ro-
mary, 2000; Salmon-Alt and Romary, 2001). Each
underspecified domain is noted U(N, t), where t is
the intended referent and N ? Props is a seman-
tic description. We will note NI the set of ob-
jects that have the semantic description N that is
NI = {x|x ? E,?p ? N, p(x) ? V }. We assume
there is for each description N a given wording, and
we will write for instance ?the N? to denote a defi-
nite RE where N has to be replaced by the wording
of N . The notation msd(D) stands for most salient
description, that is, there is no more salient domain
than D with a different description. This is equiva-
lent to @D? ? RS;?D? ? ?D ? SD? 6= SD.
The indefinite ?a N? can always be generated but
may be ambiguous. The only constraint placed on a
domain by the corresponding UD is that it contains
an element of type N. For example, the domain D1 =
?{b1, b2, b3}, {button}, 0, (color, {{b1, b2}, {b3}}, ?)?
does not differentiate b1 from b2, the only way we
could access to b1 would be by uttering ?a blue
button?.
The definite expression ?the N? requires that the
target forms a semantically disjoint part in the ref-
erence domain partition. For example, in the above
domain D1, ?the red button? can be used to refer to
b3.
Like the definite and indefinite, the demonstrative
?this N? requires that the referent is of type N (be-
longs to NI), but also requires the existence of a fo-
cused partition containing exactly the referent. For
example, if a domain of blue buttons contains a par-
tition structure such that P = {{b1}, {b2}}, it is pos-
sible to refer to b1 given that F = {{b1}} by uttering
?this blue button?, but it would not be the case if
F = {{b1}, {b2}}.
Alternative phrases such as ?another/the other N?
both require that there is already something in focus
which is not the referent. Definite alternative phrases
require that the unfocused part of the partition con-
tains exactly the target referent while indefinites only
require that the unfocused part contains the referent.
For example, if there is a domain of three blue but-
tons b1, b2, b3 with a partition structure such that
F = {{b2}}, it is possible to use the indefinite ?an-
other blue button? to refer to b1 while it would not be
possible to use the definite ?the other blue button?.
One-anaphora of the form ?this/another/the other
one? can be generated only if the description of the
domain in which the referent has to be discriminated
is already salient, in other words that msd(D) is true.
For example, if the most salient domain in RS is a
domain of blue buttons, it would not be possible to
utter ?this one? to refer to a red button inside a less
salient domain.
3.2 Generation algorithm
The referring algorithm (figure 2) proceeds in three
steps as follows.
The first step (line 1?2) determines in which refer-
ence domain, referring will be processed and thereby,
which description will be used for instantiating the
underspecified domains. The selected RD is the most
salient RD with the smallest ground containing the
target referent. If there are several such RD, an
arbitrary one is picked. If the selected domain is
D = ?GD, SD, ?D, (c, P, F )?, then the description S
used to instantiate the underspecified domain is the
conjunction of the properties in the description SD
with the value of the differentiation criterion used
to create the partition namely, properties of val(c)
true of the referent (line 2). If the criterion is the
identifier, it is ignored in S. For instance, if there is
a domain of buttons with a partition on color, the
description might be {button, blue}.
In the second step, the algorithm iterates through
the underspecified domains instantiated with S and
selects the first that matches. The order in which
underspecified domains are tested is particularly im-
portant. We use (Gundel et al, 1993) Givenness hi-
erarchy and ordered the UDs based on the cognitive
status of the corresponding referent. We extended
the hierarchy to include alternative NPs: ?this one?
> ?this N? > ?the N? > ?the other one? > ?the
other N? > ?another one? > ?another N? > ?a N?.
In the third step, the referential space is restruc-
tured by either creating a new domain or increasing
the salience of an existing domain (Figure 3). The
goal of this restructuring step is to be able to re-
strict the further focus to a smaller domain. For
instance, when dealing with red buttons we want
to avoid focusing the blue buttons. The function
first gathers all objects of D that have the persis-
tent part of description S (Gp and Sp), and if there
is already a domain composed by these objects, its
salience is increased such that it is the most salient
(line 4). If there is no such domain, a new most
salient domain is created with these objects and a
default partition. Transient properties are not taken
into account to regroup the objects because it would
restrict too much further focus. For instance, limit-
ing the restructuring to persistent properties avoids
sequences like ?Push the button on the right. Yeah
this one?.
For example in a domain D containing a button
b1 and a chair c1,
D =?{b1, c1}, ?, 0,
(objType, {{b1}, {c1}}, ?)?
a reference to b1 could lead to the generation of
the expression ?the button?, the restructuring makes
sure to create a new domain whose ground is only
{b1}. Therefore, we avoid producing unecessary ref-
erence to the chair such as ?Not this chair! Look for
the button? (see section 4).
3.3 Dealing with plurals
The plurals treatment is quite similar to the singu-
lar cases, but we need to do two modifications to
be able to generate plurals. The first modification
is about the underspecified domains. Whereas we
had individuals, here we want to generate an RE to
a set of targets T = {t1..tn}. The UDs can eas-
ily be modified by just replacing every occurrence
of {t} by T (and t ? NI by T ? NI). With this
modification, we can only generate plurals for sets of
1: D ? most salient/specific domain containing t
2: S ? SD ? {p|p ? val(c), p(t) ? V }
3: for all U(S, t) sorted by Givenness do
4: if U(S, t) matches D then
5: restructure(D, S, RS)
6: return U(S, t)
7: end if
8: end for
9: return failure
Figure 2: generate(t, RS)
1: Sp ? {p|p ? S, val?1(p) ? Typespers}
2: Gp ? {x|x ? GD,?p ? Sp, p(x) ? V }
3: if ?D? ? RS;GD? = Gp then
4: ?D? ? max?(RS) + 1
5: else
6: D? ? ?Gp, Sp,max?(RS) + 1,def(Gp)?
7: RS ? RS ? {D?}
8: end if
Figure 3: restructure(D, S, RS)
objects that are parts of an existing partition. Imag-
ine we have GD = {b1, b2, b3, b4}, and a partition
P = {{b1, b2}, {b3, b4}} then it is not possible to refer
to {b2, b3} using a demonstrative because they can-
not be focused together. It may be possible to adapt
the UD to consider
?
F instead of F , that is for in-
stance instead of F = {T} we would require that
?
F = T . But this possibility and its side-effects
have not been yet explored.
The second modification is related to the gener-
ation algorithm and the description used to build
the underspecified domains. Instead of retrieving the
properties of the differentiation criterion for a single
target we need to make sure that the properties are
true for all the targets, that is (line 2), we need to
have S ? SD ? {p|p ? val(c),?t ? T, p(t) ? V }.
4 Generation in the GIVE challenge
We present here how the generation module has been
instantiated in the second edition of the GIVE chal-
lenge (Byron et al, 2007).
First, each time the player enters a new room,
the partition algorithm is called on an initial domain
Dr = ?Gr, ?, 0,def(Gr)?, with Gr ? E the set of all
objects in the room, and the list of GIVE persistent
types, that is objType, the type of objects, and color.
We then use the above referring algorithm in two
ways. First, it is used to produce a first mention us-
ing only persistent properties and without updating
the focus. Second, it is used to produce a series of
additional subsequent mentions whose function is to
guide the player search. In this second step, tran-
sient spatial properties are used and the visual focus
is continuously updated.
4.1 First mention
The referring algorithm just described (cf. Figure 2)
takes as input the current referential space RS, gen-
erates a referring expression for the target referent
t and outputs a push instruction of the form ?Push
?+v(generate(t, RS)) where v is the verbalization
function. Note that the referential space may con-
tain domains with focused partitions coming from
previous references to other objects, and therefore is
not limited to producing definite or indefinite NPs.
4.2 Subsequent mentions
All the subsequent mentions assume that the first
mention has been performed but has not succeeded
yet in identifying the referent. They are all based on
focus and potentially on transient properties. The
focus is defined as the set of visible objects. The al-
gorithm (figure 4) first updates the focus of the parti-
tion of the most salient/specific domain D containing
the target t. Then the rest of the algorithm gener-
ates different instructions depending on whether the
target is or is not focused.
The lines 7?8 refine the focus using relative spa-
tial properties of objects in their domain. It first
computes these new properties hpos and vpos for all
objects in
?
F , and adds them in V . The refinement
is made by calling the partition function (algorithm
1) on a new domain DF = ?GF , SD, ?D+1,def(GF )?,
using [hpos,vpos]. The salience of DF is just higher
than the salience of D such that DF is preferred
over D when generating. This refinement allows
producing expressions like ?the blue button on the
right?. Because these properties are transient, they
are erased from V after the generation and all the
domains and partitions that may have been created
using them including DF are also erased.
Other lines produce expressions if the referent is
not in focus. If there is nothing in focus, it produces
?Look for X? where X is an RE for the referent. If
there is something in focus which is not the referent,
it first produces ?Not X? where X is an RE designat-
ing what is in focus, then ?Look for X? where X is an
RE for the referent. Note that this is the only place
where plurals can be generated (see section 3.3).
5 Detailed example
We present here a detailed example of the behavior
of the reference module in the GIVE setting (Table
2). We assume that the player U enters a room with
1: D ? most salient/specific domain containing t
2: F ? focus of the visible objects in D
3: GF ?
?
F
4: if t ? GF then
5: if |GF | > 1 then
6: computePositions(GF )
7: DF ? ?GF , SD, ?D + 1,def(GF )?
8: createPartitions(DF , [hpos,vpos], RS)
9: end if
10: return ?Yeah!?+v(generate(t, RS))+? !?
11: else
12: if |GF | = 0 then
13: return ?Look for ?+v(generate(t, RS))
14: else
15: return ?Not ?+v(generate(GF , RS))+? !
Look for ?+v(generate(t, RS))+? !?
16: end if
17: end if
Figure 4: Algorithm to instruct the search for a ref-
erent
state of U utterance of S
Push a blue button (b1)
see(b2) Not this one! Look for the other one!
see(b1,b2) Yeah! The blue button on the right!
see(b1) Yeah! This one!
push(b1)
Push the red button (b3)
see(b3) Yeah! This one!
push(b3)
Push the other blue button (b2)
Table 2: Utterances produced by the system S
three buttons, two blue buttons, b1 and b2 and a red
button b3.
5.1 Initializing the referential space
As soon as the player enters the room, the partition
algorithm is called on the initial domain:
D0 = ?Gr, ?, 0, def(Gr)?
with Gr = {b1, b2, b3}. The result is the RS :
D0 =?{b1, b2, b3}, {button}, 0,
(color, {{b1, b2}, {b3}}, ?)?
D1 =?{b1, b2}, {button, blue}, 0,
(id, {{b1}, {b2}}, ?)?
We will note the RS by grouping the domains that
have the same salience and indicating the salience
of a set of domains in subscript. That is, after the
construction, the RS is: {{D0, D1}0}.
5.2 ?Push a blue button?
The system is first required to refer to b1. As all the
domains all are equally salient, the algorithm tries to
pick the most specific domain containing b1, and it
finds D1. The description used to refer to b1 is the
description of the domain SD1 = {button, blue} and
the value for the criterion which is the identifier and
is then ignored. Inside D1 it then tries to refer to
b1 by iterating through the underspecified domains
to find the first one that matches D1. Because there
is no focus at this moment, the first found UD that
matches is ?a N?. It then performs restructuration
of the RS, by trying to build a new subdomain of
D1. However, because there are only blue buttons
in D1, no subdomain is created and the salience of
D1 is increased. Eventually, the expression is verbal-
ized and ?Push a blue button? is uttered. After this
reference, the RS is then {{D1}1, {D0}0}.
5.3 ?Not this one! Look for the other one!?
Before the subsequent mentions to b1 are made, the
focus of the most salient/specific domain containing
b1 is updated. We assume first that only b2 is visible,
thus D1 becomes:
D1 =?{b1, b2}, {button, blue}, 1,
(id, {{b1}, {b2}}, {{b2}})?
According to the algorithm in figure 4, a reference
to b2 has to be made first ?Not b2!?. Underspeci-
fied domains are iterated and the first that matches
is ?this one? considering that {blue, button} is the
most salient description and b2 is in focus. No sub-
domain is created when restructuring the RS, only
the salience of D1 is increased. The uttered expres-
sion is then ?Not this one!?. As for the reference
to b1, the reference is still made in D1 and the first
UD that matches is ?the other one?. No restructur-
ing apart from increasing salience is performed and
the returned expression is eventually ?Look for the
other one!?. So, after referring to b2 and b1, the RS
is {{D1}3, {D0}0}.
5.4 ?The blue button on the right?
We enjoined the player to turn around to search for
b1. We assume here that he did so and now can see
both b1 and b2. Before any reference can take place,
the focus of D1 is updated:
D1 =?{b1, b2}, {button, blue}, 3,
(id, {{b1}, {b2}}, {{b1}, {b2}})?
However, the focus can no more discriminate both
buttons, and a refinement with the position has to be
performed according to the algorithm 4. We assume
that b1 is on the right while b2 is on the left. Positions
are computed and new ground predicates are added
to V : {right(b1), left(b2)}. A new domain D2 with a
ground equal to the focus of D1, that is {b1, b2}, is
built and used as input for the partition algorithm.
It is partitioned along the horizontal position (hpos),
and then added to the RS, that is:
D2 =?{b1, b2}, {button, blue}, 4,
(hpos, {{b1}, {b2}}, ?)?
Before the reference to b1, the RS is then
{{D2}4, {D1}3, {D0}0}. A new reference to b1 is
then made, but as D2 is more salient than D1 it
is preferred for the reference. The first UD that
matches is the definite ?the N? built with the de-
scription {button, blue, right}, and ?the blue button
on the right? is uttered. However, because D2 was
built with transient properties, it is erased from the
RS and is recreated before each reference unless the
player changes its visual focus.
5.5 ?Yeah! This one!?
Now we assume that the player turned around again
and only sees now b1. The most salient/specific do-
main containing b1 is D1 and its focus is updated:
D1 =?{b1, b2}, {button, blue}, 3,
(id, {{b1}, {b2}}, {{b1}})?
The first matching UD is the demonstrative one-
anaphora ?this one?, no restructuring takes place ex-
cept the increased salience of D1 and ?Yeah! This
one!? is produced. The RS is thus {{D1}4, {D0}0}.
5.6 ?Push the red button?
We assume that given all these referring expressions,
the player is at last able to push b1. A new reference
has to be made, this time to b3, the red button. The
most salient/specific domain containing b3 is actually
D0. In D0, the first matching underspecified domain
is the definite ?the N?. The restructuring leads this
time to create a new most salient domain D3 com-
posed only of b3 (because it is the only red button):
D3 =?{b3}, {button, red}, 5,
(id, {{b3}}, ?)
The further reference to objects will thus avoid re-
ferring to something else than red buttons (see sec-
tion 3.2). The RS is then {{D3}5, {D1}4, {D0}0}.
5.7 ?Yeah! This one!?
Provided that D3 is now the most salient/specific
container of b3, b3 can be focalized in the default
partition of D3, resulting in:
D3 =?{b3}, {button, red}, 5,
(id, {{b3}}, {{b3}})?
The first matching UD is then ?this one?, the re-
structuring just increases the salience of D3 and the
system utters eventually ?Yeah! This one!?. The
RS is then {{D3}6, {D1}4, {D0}0}. Note that, even
if the player would turn around and see b1 or b2 in
the same time than b3, D3 being the current most
salient/specific domain, b1 or b2 would not be fo-
cused.
5.8 ?Push the other blue button?
We now have to refer to the last button b2. The
most salient/specific domain containing b2 is D1,
however D1 contains already a focus to b1. Thus,
the first matching UD is ?the other N?. Note that
we only considered visual focus, therefore the alter-
native anaphora ?the other? does not refer to b2 be-
cause we already mentioned b1 but only because it
is the last object the player saw in D1. By chance,
in the GIVE setting, the visual focus corresponds
to the linguistic focus and thus uttering ?Push the
other blue button? sounds natural. It would be more
complex to handle a setting with both the linguistic
and the visual focus, but we think that the RDT is
well-equipped to resolve this issue.
6 Evaluation
We evaluated the RDT generation model by compar-
ing its performances with another system also com-
peting in the GIVE challenge but based on a clas-
sical approach on (Dale and Haddock, 1991) that is
restricted to generating definite and indefinite NPs.
We designed a special evaluation world to test several
reference cases, and for both approaches, we mea-
sured the average time from the moment of uttering
a first mention designating a button to the moment
of completion, that is when the button is success-
fully pushed. We also measured the average number
of instructions that were provided in the meantime.
The evaluation has been conducted with 30 subjects
resulting in 20 valid games. The results show that
the RDT performs better than the classical strategy,
both for the average completion time (8.8 seconds
versus 12.5 seconds) and for the number of instruc-
tions (6.4 versus 9.3). We conjecture that the good
results of RDT can be explained by the lower cog-
nitive load resulting from the use of demonstrative
NPs and one-anaphoras.
7 Other works and extensions
While some RE generation models focus on the side
of generating the description itself (Dale and Re-
iter, 1995; Krahmer et al, 2003), we tried to focus
more on the side of generating the determiner. While
works such as (Poesio et al, 1999) also generates the
determiner, they rely on statistical learning of this
determiner. On the contrary we did so by represent-
ing logically the constraints carried by a referring ex-
pressions on the context of its interpretation. How-
ever, the presented model has several limits. First,
as (Landragin and Romary, 2003) describe, there is
no one-to-one relation between the referring expres-
sions and the referring modes. In order to tackle this
problem we can associate a set of UD to a referring
expression. We only need then to add an additional
loop on the different UDs for a given type of referring
expression. The second extension is the possibility
to have several partitions. It is also possible to it-
erate over the set of partitions of a domain, but we
then need to consider the salience of each partition.
In addition, the restructuring has to be amended to
increase the salience of the partition in which a gen-
eration is made.
8 Conclusions
We presented a reference generation algorithm based
on Reference Domain Theory. The main improve-
ment of this algorithm over existing approaches is
the construction and update of a set of local con-
texts called a referential space. Each local context
(reference domain) can be used as a context for re-
ferring. The dynamic aspect of the reference process
consists both in the continuous update of the ref-
erence domains and in the update of the referential
space. Thus, the presented algorithm can generate a
variety of referring expressions ranging from definite,
indefinite to demonstrative, alternative phrases, one-
anaphora and plurals. The instantiation in the GIVE
challenge was a baptism for the generation algorithm
and the GIVE setting offered us a good opportunity
to test the serial nature of the reference process. It
enabled us to evaluate the RDT approach and proved
that it is successful.
We would like to thank Luciana Benotti, Claire
Gardent, and the people participating to the GIVE
challenge at the LORIA for their help during the
model development. We also would like to thank the
anonymous reviewers for their precious insights.
References
Donna K. Byron, Alexander Koller, Jon Oberlander,
Laura Stoia, and Kristina Striegnitz. 2007. Gener-
ating instructions in virtual environments (GIVE):
A challenge and an evaluation testbed for NLG.
In Proceedings of the Workshop on Shared Tasks
and Comparative Evaluation in Natural Language
Generation, Washington, DC.
Donna Byron, Alexander Koller, Kristina Striegnitz,
Justine Cassell, Robert Dale, Johanna Moore, and
Jon Oberlander. 2009. Report on the First NLG
Challenge on Generating Instructions in Virtual
Environments (GIVE). In Proceedings of the 12th
European Workshop on Natural Language Gen-
eration (ENLG 2009), pages 165?173, Athens,
Greece, March. Association for Computational
Linguistics.
Robert Dale and Nicholas J. Haddock. 1991. Gener-
ating referring expressions involving relations. In
Proceedings of the 5th Conference of the European
Chapter of the ACL, EACL-91.
Robert Dale and Ehud Reiter. 1995. Computational
interpretations of the gricean maxims in the gen-
eration of referring expressions. Cognitive Science,
19(2):233?263.
Alexandre Denis, Guillaume Pitel, and Matthieu
Quignard. 2006. Resolution of Referents Group-
ings in Practical Dialogues. In Proceedings of the
7th SIGDial Workshop on Discourse and Dialogue
- SIGdial?06, Sydney Australia.
Albert Gatt and Kees van Deemter. 2007. Incre-
mental generation of plural descriptions: Similar-
ity and partitioning. In Proceedings of the Confer-
ence on Empirical Methods in Natural Language
Processing, EMNLP-07.
Jeanette K. Gundel, Nancy Hedberg, and Ron
Zacharski. 1993. Cognitive status and the form
of referring expressions in discourse. Language,
69(2):274?307.
Martin Klarner. 2005. Reversibility and re-usability
of resources in NLG and natural language dia-
log systems. In Proceedings of the 10th Euro-
pean Workshop on Natural Language Generation
(ENLG-05), Aberdeen, Scotland.
Emiel Krahmer and Marit Theune. 2002. Effi-
cient context-sensitive generation of referring ex-
pressions. In K. van Deemter and R. Kibble, edi-
tors, Information sharing: Givenness and newness
in language processing, pages 223?264. CSLI Pub-
lications, Stanford.
Emiel Krahmer, Sebastiaan van Erk, and Andr Ver-
leg. 2003. Graph-based generation of referring
expressions. Computational Linguistics, 23:53?72.
Fre?de?ric Landragin and Laurent Romary. 2003. Re-
ferring to Objects Through Sub-Contexts in Multi-
modal Human-Computer Interaction. In Proceed-
ings of the Seventh Workshop on the Semantics
and Pragmatics of Dialogue (DiaBruck?03), pages
67?74. Saarland University.
Fre?de?ric Landragin. 2006. Visual perception, lan-
guage and gesture: A model for their understand-
ing in multimodal dialogue systems. Signal Pro-
cessing, 86(12):3578?3595.
Massimo Poesio, Renate Henschel, Janet Hitzeman,
and Rodger Kibble. 1999. Statistical NP genera-
tion: A first report. In Proceedings of the ESSLLI
Workshop on NP Generation, Utrecht.
Anne Reboul. 1998. A relevance theoretic approach
to reference. In Acts of the Relevance Theory
Workshop, University of Luton, England.
Susanne Salmon-Alt and Laurent Romary. 2000.
Generating referring expressions in multimodal
contexts. In Workshop on Coherence in Generated
Multimedia - INLG 2000, Mitzpe Ramon, Israel.
Susanne Salmon-Alt and Laurent Romary. 2001.
Reference resolution within the framework of cog-
nitive grammar. In Proceeding of the International
Colloquium on Cognitive Science, San Sebastian,
Spain.
Robert Stalnaker. 1998. On the representation of
context. Journal of Logic, Language and Informa-
tion, 7(1):3?19.
Kristinn R. Thorisson. 1994. Simulated perceptual
grouping: An application to human-computer in-
teraction. In Proceedings of the Sixteenth Annual
Conference of the Cognitive Science Society, At-
lanta, Georgia.
