18 
"1965 International Conference on Computational 
Linguistics" 
A Heuristic Approach to Natural 
Language Processing 
Denis M. Manelski and 
Shell Oil Company 
50 West 50th Street 
New York 20, New York 
Gilbert K. I~ l .ee  
Northwestern University 
Technological Institute 
Evanston, Illinois 
Manelskl & Krulee 
1 
ABSTRACT 
This paper is concerned with the design of a processor capable of 
formalizing English language descriptions of problems in the sententlal 
calculus. The emphasis is on the design of a system with natural language 
processing capabilities, but the formal languages specified are oriented 
to the problem context. 
A series of automata are specified to carry out the necessary 
functions. The automata identifythe premises in the problem strings~ 
specify the appropriate logical connectives among the premises and deter- 
mine which premises are meaning-equivalent. The syntax of each automaton is 
defined and examples are used to illustrate their functioning. 
The automata accept statements in the language L1, the set of 
English statements of problems in the sententlal calculus. The individual 
premises p @ L1 are recognized by the syntax~, where ~ is chosen so that 
the language L2 recognized by it is a subset of L1. Furthermore, the 
strings in L2 are restricted to the declarative sentences. Once the premises 
and their logical connectives have been identified, those that are meaning- 
equivalent are located in two additional steps. First the L2 description 
of the string is mapped into a string in L3. The L3 language consists 
of a limited set of canonical forms that ease the problem of establishing 
meaning equivalence of premises. Finally, the automaton applies 
heuristically a sequence of problem-orlented and meaning-preserving 
transformations in order to establish meaning-equivalence. Two premises 
are taken to be meaning-equivalent if one can be deduced from the other. 
Otherwise~ they are taken to be not meaning-equlvalent. 
Manelskl &Krulee 
2 
A HEURISTIC APPROACH TO NATURAL 
LANGUAGE PROCESSING 1 
Introduction 
The recent evolution of programming languages has tended to 
improve communication between man and computer. The use of mnemonics~ 
automatic storage allocation~ English-like operators (such as in COBOL) 
and problem-oriented languages has greatly facilitated the task of the 
programmer. Thus, the solution algorithm for a large class of computa- 
tional problems can be defined with relative ease in languages such as 
FORTRAN and ALGOL, specifically designed for these classes of problems. 
This paper describes an attempt to further simplify the communica- 
tion between programmer and computer by defining a system which can produce 
a formal description from its natural (verbal) input. 2 
In order to study this approach a specific problem area was 
chosen, the propositional or statement calculus. It will be evident that 
the problem area chosen has influenced the design of the system; nonetheless 
it should be clear that the linguistic capabilities of the system are 
general rather than specific to the problem context. 
In designing this processor, two major abilities are required. 
First, the processor must be able to identify each elementary premise and 
all logical connectives. It must also determine which premises are to be 
taken as equivalent. 
i This research was supported by Grant G-17951 of the National Science 
Foundation. A majority of the system has been programmed in the list 
processing language IPL-V (Newell, 1961). 
2 For a more complete description and some program listings see Manelski, 
196~. 
Manelski & Krulee 
3 
The processor is composed of th ree  series coupled automata 
(see Fig. 1). The first automaton, A1, accepts as its inputs the language 
L1, where L1 is the set of all English language statements of problems in 
the propositional calculus. This automaton is concerned with the identi- 
fication of the premises and logical connectives of a problem. This is 
achieved by using a syntax ~ capable of recognizing strings in L2. where 
L2 is a subset of L1. The syntax ~ consists of a hierarchy of syntaxes; 
a phrase structure syntax ~idesigned to recognize a subset of English 
composed of simple declarative sentences and the set of' transformations 
specified by~ T.I 
The equivalent premises are identified by the automata A2 and 
A3. The automaton A2 maps a premise, identified by AI~ into a canonical 
form specified by the syntax C that defines the language L3. This step 
is designed to facilitate the distinction of equivalent premises. Finally 
A3 applies a sequence of meaning preserving transformations from the set 
TO = ~TI,T2,... ~ Tm~ on the string (~r,~'s ~ L3 such that if: 
TiTj'''T% (~r) :~s  
with T k C TO 
the two strings are considered meaning equivalent. Should the system 
be unable to find a deduction satisfying these conditions or under certain 
other heuristically chosen criteria the strin6~s are asslnned to represent 
different premises. 
In order to test the system described in this paper, problems 
were drawn from Stoll (1961). Some will be used later to illustrate the 
capabilities and inadequacies of the present system. 
1 Chomsky's discussion of transformations and the inadequacies of various 
models for natural languages can be found in the monograph "Syntactic 
Structure s". 
96 ~ ' 
r~ 
u~ 
~J N 
,k/ 
I1 F-~ U 
~ ,,,4 U 
P,I ,1~ 0 
~t~4 
ZO 
I1 
(~?  
Q 
.< 
o 
r~ 
u) 
, GJ 
?) 
0 
k~ 
u 
,IJ 
r,n 
.<  
. 
Manelski &Krulee 
5 
Each of the automata will be discussed in two ways, first in 
terms of its syntax. Finally the information flow for its implementation 
as a computer program will be outlined. 
Characteristics of the Natural Language Processor (AI) 
The automaton A1, as mentioned in the previous section, consists 
of two completely different syntactic mechanisms. The system includes a 
phrase structure syntax designed to recognize an extremely restricted 
subset of the English language, simple declarative sentences. The syntax 
of the processor also includes a limited set of transformations chosen 
to enhance the power of the language generated, but also specifically 
chosen for the problem context. 
If we consider the syntax of A1, ~ , as consisting o f~ l  and 
T we have defined a hierarchy of languages: 
L1 ~ L2 ~ I~l 
Here L1 consists of all the legal problem statements; L2 consists of the 
set of strings recognized by~ ; and L~l consists of all the strings 
recognized by the syutax ~.  Thus, the syntax ~ of the automaton A1 
is really composed of two disjoint sets of rewriting rules,~l and ~T. 
The syntax ~l is a phrase structure crammar designed to generate or 
recognize a subset of English Composed of simple declarative sentences. 
The syntax ~T contains a set of transformations designed for the purposes 
of isolating premises and specifying logical connectives. This hierarchy 
can be visualized in Figure 2. 
II I I I1? 
6, 
F:l.~ure 2 
Manelski & Krulee 
7 
Initially~ we shall describe the class of sentences recognized 
by 91~ and then characterize the strings recognized by P. From the 
following discussion it will be made clear that we are building a 
recognizer rather than a generator. The automaton A1 will not perform 
syntactic analysis below the level of the alphabet (i.e., words) of the 
language. Thus~ the processor w?uld recognize: 
The bridge was high 
The bridges was high 
as the same sentence since the differences are at a level below that 
specified by its syntax. 
The processor consists of an alphabet A, where: 
A = N u D u PN u ADJ u VEQu VTRu V INu  VFAC U VAUX 
o PREPu ADVu THANu ADJC 
with the sets representing: 
N: noun 
D: determiner 
PN: pronoun 
ADJ: adjective 
VEQ: verb equational 
VTR: verb transitive 
VIN: verb intransitive 
VFAC : verb factitive 
VAUX: verb auxiliary 
PREP: prepos it ion 
ADV: adverb 
ADJC: comparative adjective 
THAN: Than 
Manelski &Kru lee  
8 
Although the task of the assignment of word classes is that of 
the linguist, in general, if X i and Xj are sets comprising A we expect 
xi x j for i J 
where ~ represents the empty set. The occurrence of an element of the 
alphabet in more than one word class is known as homography and is 
common to the natural languages. 
For purposes of derivation, we distinguish between the elements 
of the alphabet, to be known as the "terminal" elements, and the symbols 
the nonterminals. 
from the syntax such as S, NP, ADJ, etc., which will be referred to as 
The word assignments might be as shown in Table 1. 
N .. 
D = 
PN = 
ADJ = 
VMEQ = 
V~R = 
VMINTR = 
VMFAC - 
VAUX 
PRP = 
ADV = 
AI~C = 
man, boy, house,... 
a, the,... 
he, they,... 
blue, large,... 
is, are,... 
hit, hits,... 
rained, went,... 
appoint, call,... 
will, should, ... 
in, to, ... 
quickly, slowly,... 
larger, better,... 
Table 1 
Although the processor is limited in the size of the available dictionary , 
for purposes of discussion no limitations will be assumed. 
In addition it is necessary to specify the syntax of the 
recognizer, which uses the rewriting rules of the axiomatic ~system ~l in 
Table 2. Examining the syntax ~l, we see that it meets all the requirements 
of a phrase structure grammar. Also, ~l  generates several classes of strings 
characterized by the verb type. Since this classification will be funda- 
mental to the design of A2, we shall give some examples in L2 and later 
show the mapping of A2. 
Manelski &Kru.lee 
9 
Syntax ~i for Processor A1 
i) S -~NP + VP 
2) NP- ,D+ N 
N 
PN 
3) NP-~NP + PRP 
4) PRP-~ PREP + NP 
5) N-~ADJ  + N 
6) AOJ-~AOJ + ADJ 
7) PADJC-~ ADJC + than + 
8) NP~ NP+ NP 
9) VP-~ VEQ + PREDEQ 
VTR + PREDTR 
VITR + PADV 
VFAC + PREDFAC 
10) VEQ -~ VMEQ 
ll) VMEQ -~VAUX + VMEQ 
12) PREDEQ~ NP 
ADJ 
PRP 
PADJC 
13) VITR-~ VMITR 
14) VMITR -~ VAUX + VMITR 
15) PADV~ 
ADV 
N 
PRP 
16) PADV~ PADV + PADV 
17) VTR-~ VMrR 
18) VM~R -~ VAUX + VM~R 
19) PREDTR ~ NP 
NP + PADV 
NP+ PRP 
NP+NP 
20) VFAC ~- VMFAC 
21) VMFAC-~ VAUX + VMFAC 
22) PREDFAC -~ NP 
NP+NP 
NP+ PADV 
NP 
sentence, noun phrase, verb phrase 
determiner, noun 
pronoun 
prepositional phrase 
preposition 
adjective 
comparative adjectival phrase, compara- 
tive adjective 
verb equational, equational predicate 
verb transitive, transitive predicate 
verb intransitive, adverbial phrase 
verb factitive, factitive predicate 
main verb, equational 
verb auxiliary 
main verb, intransitive 
empty 
main verb, transitive 
main verb~ factitive 
Table 2 
Manelski &Krulee 
lO 
The syntax~l identifies four verb types, equational verbs, 
intransitive verbs, transitive verbs, and factitive verbs with their 
corresponding predicates. The following examples show some of the 
possible sentences: 
Equational verb: 
(i) John is home. 
(ii) John is tall. 
(iii) John is by the house. 
(iv) John is taller than Peter. 
A derivation of (ii) in the syntax~l is 
(S(NP(N John)) (VP(VEQ(VMEQ is)) (PREDEQ(ADJ tall) )) ) 
Intransitive verb: 
(i) The Dodgers win. 
(ii) The Dodgers win seldom. 
(iii) The Dodgers win money. 
(iv) The Dodgers win at home. 
The derivation of (i) is 
(S(NP(D The)(N Dodgers))(VP(VITR win)(PADV?))) 
Transitive verb: 
(i) John loves Mary. 
(ii) John loves the winnings from the track. 
The derivation for (it is 
John) loves) MaryS) 555 
Fact it ire verb: 
(i) John called home. 
(il) John called his friend a fool. 
F~nelski & Krulee 
ii 
The derivation of (i) is 
(S(~P(N John) ) (VP(VFAC(V~FAC called) ) (PREDFAC(~P(N Mary) ) ) ) ) 
Several types of sentences will not be recognized by~l.  Some of these 
could be included by additional productions. Some additional types of 
sentences will be recognized when ~T is added to the syntax. Other 
sentence forms are not considered necessary within the original problem 
conte}~. Let us list some of the sentences in LI that are outside of 
the capabilities of recognition with ~i. 
Imperative sentences: 
Go home. 
Interrogative sentences: 
Is John coming home? 
Passive sentences: 
Home is where John should be. 
Conditional sentences: 
If John should come home... 
Compound sentences: 
John will go home and Mary will stay. 
Complex sentences: 
John, should he so desire, will go home. 
In order to make the processor A1 useful in the problem 
context, it is necessary to increase the class of strings in L2. In 
contrast to the syntax ~i, which uses the rewriting rules on the non- 
terminals in the deduction string, the transformation set rT is designed 
to operate on the derivations in ~i. Generally, transformations have 
Manelski &Krulee 
12 
been discussed in terms of generators. Attention has been focused on 
increasing the class of strings that a formal language can generate (39). 
However, our problem is to use ~T in order to simplify the class of 
strings that ~l will have to recognize. Thus, our transformation set rT  
should decompose the string 
John will go home and Mary will stay. 
into the following simpler strings: 
(1) John will go home. 
(il) will stay. 
Since we are interested in formalizing the natural language 
inputs as statements in the sententlal calculus, the transformations 
will also give us information as to the appropriate logical connectives 
for the premise. Thus, in the previous example our processor could be 
expected to define a statement of the form: 
P ;kg  
In order to explore the powerful linguistic possibilities of 
transformations, a limited number were chosen. We shall now define the 
transformations and show how the linguistic capabilities of A1 have been 
increased. 
The transformation set~T presently contains as its axioms: 
T = ~TNOT, TCOM, TCOND~ 
In order to specify a transformation, we must not only define 
the structural changes it produces but also the class of strings to 
which it is applicable. The transformations~ as defined in~T were 
adapted for A1. Since we are not interested in generating grammatically 
Manelski & Krulee 
13 
correct English sentences, but rather mapping the input strings into a 
form recognizable to ~l, it is possible to omit the transformations 
for tenses because they operate at a level lower than that of the 
terminals. By implication~ 1 will process strings that are not 
grammatically correct. Thus, if A1 were presented with the sentence: 
If it were cold tomorrow~ .... 
the transformation TCOND will give as its output: 
It were cold tomorrow. 
This premise would still be processed althouch it is grammatically 
incorrect. 
Another difference between the transformations as specified 
by Chomsky~ and those used by A1 is in the direction of the mapping. 
The ~T transformations have L2 as their domain and the kernel strings 
generated by ~l as their range. This is the inverse of the mappings 
considered by Chomsky (1957). 
TNOT: is defined on strings of the form 
( i)..+ NP+ VAUX+ not+VMTR+... 
( ii)..+NP+VAUX+never+VM~R+... 
(iii) . .+ NP+V~EQ+not+... 
(iv) . .+ NP+VMEQ~ never+... 
(v)..+NP+VAUX+not+VMEQ+... 
( vi)..+ NP+ VAUX+ never+ VMEQ*... 
(vii)..+NP+VAUX+not+VITR+... 
( vi ii)..+ NP+ VAUX+ never*VITR+. ?. 
( ix)..+NP+ never+VITR+ ... 
Manelskl &Krulee 
14 
( x)..+NP+VAUX+ never+VTR+... 
( xi)..+ NP+VAUX+never+VTR... 
( x? i )..+ NP+ never+VTR+... 
( xill)..+ NP+VAUX+ not+VFAC+... 
(xiv) .. + NP+VAUX+ never+ VFAC+... 
( xv)..+ NP+ never+VFAC+... 
Should a str ing~ 1 correspond to one of the above patterns TNOT(0-1) 
becomes: 
( i)..+NP+VAUX+VMrR+... 
. ( ii)..+ NP+ VAUX+ ~ ... 
(iii)..+~+nmQ+... 
(iv)..+~+VME~... 
(v)..+~P+VAUX+VME~... 
(vi)..+ NP+VAUX+VMEQ+... 
( vii)..+ NP+VAUX+VITB+... 
( viii)..+ NP+VAUX+VITR+... 
( ix)..+ ~P+vI~+... 
(x)..+NP+VAUX+VTR+... 
(xi)..+ NP+VAUX+VTR+... 
( xll)..+~+VTR+... 
(xiii)..+NP+VAUX+VFAC+... 
(xiv)..+NP+VAUX+VFAC+ ... 
(xv)..+NP+VFAC+... 
Examples of some of the cases follow: 
Manelski & Krulee 
15 
~'l: John will never hit Mary. 
TNOT(~): John will hit Mary. 
(~2: Today is not cold. 
TNOT~--2) : Today is cold. 
~3: Tomorrow will not be cold. 
TNOT~3): Tomorrow will be cold. 
~-4: John never suffers. 
TNOT(q-4) : John suffers. 
TCOM: operates on strings in the following domain only: 
(i) ? .+Sl+and+S2+ ? ? ? 
( ii)..+Sl+ ,+ s2+... 
( i i i ) . .+S I+oreS2+. . .  
( iv)..+Sl+then+S2+... 
(v i )  Either +Sl+Or+S2+... 
(vii) Therefore+,+Either+Sl+or+S2+ ?. ;
The range of the function is any string with the following format: 
S I 
S 2 
Here the information between "SI" and "$2" is used by the processor only 
to establish the Boolean connectives for the statements. Some examples 
will show the effect of TCOM On strings ~'in the domain of the 
t rans format ion. 
~'i: Either Sally and Bob are the same age or Sally is older than Bob. 
TCOM~I): Sally and Bob are the same age. 
Sally is older than Bob. 
Manelski &Krulee 
16  
~2:  The races are fixed or the gambling houses are crooked? 
TCOM(~): The races are fixed. 
The gambling houses are crooked. 
TCOND: is defined over strings wlth the following configuration: 
( i)..+ If+ Sl+...+, then+ $2+ .... 
( li)..+If+Sl+...+ ,+$2+ .... 
and has as its range the following forms: 
? .+S l+ . . .  
? .+S2+. . .  
As in the other transformations its application defines the logical 
connectives for A1. 
We can see the effect of TCOND on the following strings: 
~ i :  If the Dodgers win~ then Los Angeles will celebrate? 
TCOND(~I) : The Dodgers win. 
Los Angeles will celebrate? 
The definitions of the syntactic elements used in establishing 
the domain o f~T are given by the phrase-structure grammar ~i. Another 
convention used in the discussion is to allow a series of dots ( .... ) 
to refer to any syntactic structure. It is also implied that the 
transformations may be concatenated as necessary. 
To illustrate their use, we utilize the following examples: 
~i:  If the then Los Angeles will celebrate, and Dodgers wln~ 
if the White Box win, Chicago will celebrate. 
TCOND(~I): The Dodgers win. 
Los Angeles will celebrate and if the White Sox win, 
Chicago wlll celebrate. 
Manelski & Krulee 
17 
TCOM(TCOND~ 1)) : The Dodgers will win. 
Los Angeles will celebrate. 
If the White Sox win, Chicago will celebrate. 
Dodgers will win. 
Los Angeles will celebrate. 
The }~nite Sox win. 
Chicago will celebrate. 
~'2: If I miss my appointment and start to feel downcast, then 
I should not go home. 
TCOND(~2): I miss my appointment and start to feel downcast. 
I should not go home. 
TCOM(TCOND(~): I miss my appointment. 
Start to feel downcast. 
I should not go home. 
TNOT(TCOM(TCOND(~2)): I miss my appointment. 
Start to feel downcast. 
I should go home. 
In this example the resultant strings are not recognizable by 
~i. Thus~ "start to feel do~ncast" has its subject implied by the 
preceding string, and could be thought of as "I start to feel downcast". 
Some of the difficulties caused by the transformations can be overcome 
by AI. 
Manelski & K_rulee 
18 
Description of the Natural Language Processor (Al~ 
In order to design a processor of the type described in the 
previous section it is necessary to specify therelationship between 
the recognition rules ~l  of the phrase structure grammar and the rewriting 
rules ~T of the set of transformations. Clearly ~l and~T are inter- 
dependent since the input cannot always be analyzed in terms of the 
syntax~ \]. and because the rewriting rules o f~T are defined in terms of 
1. Perhaps an example illustrates this point more effectively. Consider 
the inp~ string: 
If John went to the store then Mary went home. 
This is clearly a case in which we sho~d apply TCOND~ T in order to 
obtain: 
S1 - John went to the store. 
$2 - Mary went home. 
However, the processor cannot find S1 and S2 because they are defined in 
terms of ~ 1 which cannot determine S1 and $2 since it cannot analyze 
strings such as "If John went to the store...". This vicious circle has 
been resolved by determining heuristically when the transformations 
should be applied. If the strings resulting from the application of 
the transformations cannot be analyzed by ~i~ the system attempts to 
apply the transformations again. 
The general hierarchy of the programs can be found in Figure \]~- . 
The program DO embodies the essential features of the automaton AI. A 
brief description of the various sub-routines involved will serve to 
illustrate the workings of the processor and the difficulties that it 
might encounter. 
Manelski & Krulee 
19 
The automaton A1 can be considered as having two quite distinct 
functions. Initially, certain key words are marked in the problem input 
(giving rise to the hypothesized input string) and later the set of 
transformations are used in conjunction with the marked words to generate 
possible premises (to be called "input strings"). 
The necessary information can be more fully explained by 
considering a program DO designed to implement A1 (see Figure 3). The 
program DO initially calls the sub-routine D15 which performs a left-to- 
right scan on the problem string. All elements of the set MTO (where 
MTO = ~if, then, and~ or, not, never, either, therefore. 
then, ~} 
the last two elements are the symbols ", then" and ",") are marked. 
After marking, the problem string becomes both the input string (i.s.) 
and the hypothesized input string (h.i.s.). The syntactic analysis of 
an h.i.s, is attempted by EO. Failing to find a satisfactory parsing~ 
control is transferred by D2 to DI; otherwise control goes to DI3. The 
sub-routine D13 searches for an additional h.i.s.; on finding one, it 
deletes the successfully parsed string from the i.s. and the list of 
h.i.s. Should no other h.i.s, be found, the executive calls D14 which 
halts the program. After performing the necessary output functions, D1 
scans the h.i.s, currently being processed. If any marked words are 
found, control is passed to D3; otherwise the transfer is to Dll. Dll 
erases the previous h.i.s, and replaces them (i.e., all of them) with 
the i.s. Should D1 find that some of the words are marked, the processor 
20. 
DOz Start 
DISz mark a~l words in MTO . .~ '  . ~'~ 
. / t  
' D2. Was a sat i s fac tory  pars ing 
/ .' . found for scrlng? / !  
/ ~  \ Dl6: stop ~ 
~ D13Z are .y  additional | ( ~  /pu~ .tring.? S ~o \ '  
~/  No . DI~ are there any marked 
DI0z Try Co fill In~ 
~. ~ s ized input: s t r ing?  
Yes / D9: Does s t r ing  
ii~ Copy Input string as ~ . begin with 
hypothesized sCrlns? 
D31 For TNOT? ........ ~> 
Yes 
No 
D4z For TCOND? . . . .  
Yes 
DSz For TCOM? xes 
)'No 
r ?  
D6z Apply TNOT 
D7: Apply TCOND 
~D8: Apply TCOM 
No 
S cop 
Figure 3 
Manelski & Krulee 
21 
attempts to apply the transformations TNOT, TCOND, or TCOM by using the 
test routines D3, D4 or D5 in transferring control to D6, D7 or DS~ 
respectively. D3 transfers control to D6 when "no__~t" or "never" (the 
underlining is used in this section to indicate the symbols as marked.) 
are in the h.i.s.; D6 deletes the marked symbol from the h.i.s. The 
sub-routine D5 is only applied when the h.i.s, begins with "if"" it in 
turn transfers control to D7 which deletes the first of the marked 
" " . . . .  then" that it finds in the h.i.s. symbols "then", "therefore , ? or ~_ 
While removing the marking from the corresponding symbol in the i.s. 
two new h.i.s, are created by dividing the list at the location of the 
marked symbol. D5 and D8 are similar to D4 and D7; however, division of 
the  h . i . s ,  is  done  on  "and" ,  "o r "  o r  w i th  the  symbo l  "e i ther"  be ing  
erased  f rom the  beg inn ing  o f  the  h . i . s ,  i f  i t  is p resent .  The  rout ines  
D6, D7 and D8 t rans fer  cont ro l  to  D9  wh ich  is ca l led  to  tes t  whether  the  
h . i . s . ,  be ing  processed ,  beg ins  w i th  a verb :  i f  th i s  cond i t ion  ex is ts  HO 
at tempts  to  precede  it  w i th  the  f i r s t  noun  or  p ronoun o f  the  prev ious  
h . i . s .  Shou ld  i t  not  be  poss ib le  fo r  the  processor  to  car ry  out  th i s  
operat ion ,  the  program pr in ts  out  the  syntact i c  ana lys i s  i t  has  
accomplished and halts. Both DIO and D9 transfer to EO. 
Some examples will clarify the logic of DO. Let the input 
str ing~ 1 be: 
(~'l: John and went home. Mary 
Manelski & Krulee 
22 
The branching of the problem would be 
DO: 
D15: 
EO: 
DI3: 
DI4: 
transfers control to DI5. 
marks the word 'and"; the h.i.s, is "John and Mary went 
home (the underlining indicates the marked word). 
parses "John and Mary" went home. 
there are no additional h.i.s. 
stop. 
(: 
DO: 
DI5: 
EO: 
D2: 
DI: 
D3: 
D4: 
D5: 
D8: 
D9: 
John went home and Mary went to the store. 
transfers to DI5. 
the i.s. and h.i.s, become John went home and Mary went 
to the store. 
fails to parse the sentence. 
transfers to D1. 
transfers control to D3. 
control parses to D4. 
transfers control to D5. 
transfers control to D8. 
the i.s. becomes 
John went home and Mary went to the store. 
while the h.i.s, become 
John went home. 
Mary went to the store. 
after testing the h.i.s, at the top of the pushdown list 
(John went home) transfers control to EO. 
Manelski & Krulee 
23 
EO: 
D2: 
DI3: 
EO: 
I)2" 
DI3: 
DI4: 
3 
DO: 
DI5: 
EO: 
D2: 
DI: 
D3: 
D4: 
D7: 
09: 
successfully parses the current h.l.s. 
transfers control to DI3. 
locates the next h.i.s. 
successfully parses the h.i.s, at the top of the 
pushdown list (Mary went to the store). 
transfers the processor to D13. 
cannot locate any additional h.i.s. 
prints the results of the parsing. 
If John, Peter and Paul were at the game,... 
calls D15. 
marhs the problem string as "If John~ Peter an__~d Paul 
were at the gs~ne~, .... ' which is copied as the h.i.s. 
fails to find a deduction for the h.i.s. 
transfers control to DI. 
transfers control to D3. 
transfers control to D4. 
transfers control to D7. 
the marked words have the structure required for TCOND 
and changes the i.s. to 
"l_~f John, Peter an__~d Paul were at the game~ .... " 
and the h.i.s, become 
"John" 
"Peter and Paul were at the game...." 
the h.i.s, does not begin with a verb. 
Manelskl &Kru lee  
24 
EO: 
D2: 
DI: 
DII: 
EO: 
D2: 
DB: 
D4: 
D7: 
D9: 
EO: 
D2: 
DI: 
DII: 
EO: 
D2: 
D3: 
D4: 
fails to find a parsing. 
transfers control to D1. 
the h.i.s. "John" has no marked words. 
the "previous i.s. becomes the h.l.s. 
"If John, Peter an__~d Paul were at the game,..." 
fails to find a parsing. 
transfers control to D3. 
calls sub-routine D4. 
Ir finds the marked "If" and "? calling for TCOND. 
the h.l.s, become 
"John, Peter" 
"Paul were at the gam2A..." 
and the i.s. is marked as 
"If John, Peter and Paul were at the game&..." 
the h.l.s, does not begin with a verb. 
a satisfactory parsing cannot be found. 
transfers the processor to D1. 
there are no marked words in the h.i.s. 
the h.i.s, becomes 
"If John, Peter and Paul were at the gamez..." 
fails to flnd a parsing. 
transfers control to D3. 
calls D4. 
finds the "If" and "2" for TCOND. 
Manelski & Krulee 
25 
D7: the new h.i.s, is formed 
"John, Peter and Paul were at the game" (the remainder 
of the sentence is a separate h.i.s.). 
the i.s. is changed to 
"If John, Peter and Paul were at the game,..." 
D9: transfers the processor to EO. 
E0: analyzes the first h.i.s. The program would then 
analyze the remainder of the sentence. 
As indicated in the above examples the parsing of the i.s. is 
attempted by sub-routine E0, using the syntax specified in Table 2. The 
presently implemented version of EO uses a bottom-to-top search in the 
sense that the parsing tree always begins by analyzing the input string 
1 rather than the set of productions. In addition, the sub-routine is 
"predictive" in utilizing the productions to and establishing the next 
syntactic element. 
Syntax of the Predicate Forms (A2) 
The automaton A2 has as its domain the strings of L2. However, 
its syntax is based on Reichenbach's methods of linguistic analysis. In 
this section we will define a convenient formalism~ the predicate form, 
and discuss its syntax. Later we will discuss how the processor discovers 
the L3 (predicate function) mapping of an L2 string. In defining the 
syntax C of A2, it will be shown that U1  was designed in order to simplify 
i 
For a review of current parsing algorithms see Bobrow. 
M~nelski &KavA lee 
26 
the mapping into a predicate form. As in~l ,  the patterns that can be 
specified by a predicate form depend on the verb. Thus, the forms fall 
into four basic categories; equational, intransitive, transitive and 
factitive forms. 
Equational Forms - 
PRED(ARG) Examples: 
PRED (~)) 
PRED(ARG, ARG) 
Intransitive Forms 
PRED(ARG) 
John is home. John is tall. 
There is a man. 
John is taller than Peter. 
The Dodgers win. 
The Dodgers win seldom. 
Transitive Fornm - 
PRED(ARG, ARG ) Tall John loves Mary. 
PRED(ARG, ARG, ARG) John saw Peter at the track. 
Factitive Forms - 
PRED(ARG, ARG, ARG) John elected Peter the chairman. 
With one exception the verb types used in the above classifica- 
tion follow conventional definitions. However, following Sledd, factitive 
verbs are also included. Factitive verbs are transitive verbs that take 
an object complement. 
The following predicate functions show the L3 mappings of the 
examples. In order to avoid using Church's Lambda notation to bind the 
variables, the convention of using upper case letters for the nonterminal 
elements and following them by the variables in lower case letters, is 
utilized to fully define the predicate function. 
Manelski & Krulee 
27 
(i) 
....... (ii) 
(iii) 
(iv) 
(v) 
(vi) 
(vii) 
(viii) 
(i~) 
PRED is home (ARG John) 
PRED is tall (ARG John) 
FRED is a man (ARG~ 
PRED is taller than (ARG John, ARG Peter) 
PRED win (ARG The Dodgers) 
PRED win seldom (ARG The Dodgers) 
PRED loves (ARG Tall Johns ARG Mary) 
PRED saw at the track (ARG John, ARG Peter) 
PRED elected (ARG John, ARG Peter, ~LRG the chairman) 
One special characteristic of the mapping should be noted. It is not 
necessary that elements be contiguous for them to be bound to the same 
variable. Thus, the verb "saw" and the preposition "at the track" are 
not contiguous in the string yet appear so in the function. This 
characteristic of the syntax has influenced the design of the processor, 
as will be made explicit in a later section. 
Using the syntax C shown in Table 3, and the same conventions for 
Syntax C for Predicate Forms 
I) PRED-~ PRED (PREDMOD) 
2) PREDMOD-~ PREDMOD, PREDMOD 
3) ARG --~ ARG (ARGMOD) 
4) ARGMOD-~ ARGMOD, ARGMOD 
Table 3 
binding the variables, results in the following predicate functions for 
the previous examples: 
Manelski & Krulee 
28 
(i)-(iv) identical 
(v) PRED win (ARG Dodgers (ARGMOD the) 
(vi) FRED win (PREDMOD seldom) (ARG Dodgers (ARGMOD The) 
(vii) FRED loves (ARe John (ARGMOD Tall), Mary) 
(viii) FRED saw (PREDMOD at the track)(ARG John, ARG Peter) 
(ix) PRED elected (ARG John, ARG Peter, ARG chairman 
(ARaMOD t e)) 
The mapping from L2 to L3 has not been formalized by the syntax C. 
However, this syntax is implicit in the processor and will be described 
in the same section. 
Description of the Canonical Form Processor (A?) 
The predicate forms have been designed to mechanize efficiently 
the problems of pattern recognition and of equivalence of strings by 
providing a limited number of canonical forms or patterns to describe a 
large number of natural language strings. The syntax implicit in the 
processor for canonical reduction is quite simple as is shown in Table 4. 
It should be noted that the mapping presupposes a description in L2. 
Another implication is the necessity to order the arguments. The ordering 
of arguments is not made explicit by the rewriting rules given; however, 
the ordering is implicit in the processor. The rule followed in ordering 
arguments is simply defining each one as it is found in a left to right 
scan of the L2 description. 
Manelski & Krulee 
29 
1) PR O(?) 
PRED(ARG) 
PRED(AR% ARG) 
PRED(ARG, ARG, ARG) 
2) NP--~ ARO 
3) VMEQ -~ PRED 
4) VMITR -~PRED 
5) VHrR-~ PRED 
6) VMEQ + ADJC ~ PRED 
7) VFAC -~ PRED 
8) ADJ -~ ARGMOD 
9) THAN (deleted) 
10) PREDEQ-~ ARG 
ii) PADV--~ PREDMOD 
12) PRP --@ PREDMOD 
Table 4 
The flow diagram of FO, designed to behave like the automaton 
~,  is described in Figure 4. Although the syntax does not give a complete 
description of how the L2 to L3 mapping should be carried out, it will 
become clear in the descriptions of the subroutines. F1 is essentially 
a hypothesis generator. It examines the L2 input and decides on an 
appropriate canonical form. Should it find the string L2 to have 
an equational verb, the possible canonical forms are: 
PRED(~) 
PRED(ARG) 
PRED(ARG, ARG) ? 
Manelski &Kru lee  
3o 
Intransitive verbs restrict us to the form: 
'~hen the string has a transitive verb, we choose between the canonical 
forms: 
PRED(ARG, ARG) 
PRED(ARG, ARG, ARG). 
Finally problem strings with factitive verbs must follow the form: 
PRED(ARG, ARG, ARG) 
Sub-routine F1 searches the string and locates the main verb. 
The verb class is noted in order to establish the appropriate forms. 
When no verb is located, control is transferred to FlO, which notifies 
the programmer of the difficulty and stops. Once a verb has been 
located Fll generates a predicate form. F12 copies the form as the 
current prediction. The next sub-routine is F2; it binds the words of 
the problem string to the form. Thus, the words of each NP are bound to 
an ARG in accordance with a left-to-right scan of the problem string. 
~.2nen a one-to-one correspondence is established between the NPs and the 
ARGs the processor transfers to F14. F14 leaves all the names of the 
ARGs on a pushdown list. The next sub-routine is F13 which tests whether 
the pushdown list string named by the ARG is empty. Should the llst be 
empty F6 is the next sub-routine; otherwise it is F~. F4 tests whether 
there are any variables beside an N or PN in the ARG named on the push- 
down list. If there are not the processor returns to F13. When 
additional words are found F5 rewrites the predicate form as 
~a ~ ~G(A~MOD)  
F13: 
F6: 
FT: 
F8: 
FO: ? Star~ 
F1: locate 
main verb 
8 ~w m 
e 
. 31 .  
~ ~ -'--->F~o. ~r~ ~Ow" 
Yll: generate a prediction ~ . . 
YI2: copy prediction as - ~  
current predicate form ~ no 
I 
. ~ ~ F2: Bind the ARGs. Does the number of 
FI4: place names of variables for 
a 
locate verb and bind ?5: modify form and b:Lu~/ 
are there variables for , > Yg: modii~ canonical form 
a PRE~0D? Yes and bind variable 
nO ~ 
Pr ln~ and  s top  
YlG. 4 " 
Manelski &Krulee 
32 
and erases the additional variables from the ARG and binds them to the 
ARGMOD. Following the execution of F5 the processor returns to F13. 
F6 locates the verb. For transitive, intransitive, and factitive verbs 
all the words in VTR, VITR and VFAC are bound to the PRED of the form. 
For equational verbs, the processor searches to see if it is followed by 
an ADJC or a PRP; if it is, the ADJC or a PRP becomes part of the PRED. 
F7 searches for a PADV or a PRP on the tree of a PREDTR. The words 
named by the PADV or PRP are bound to the PREDMOD. Sub-routine F8 then 
prints the L3 mapping of the problem string and halts the processor. 
The following example illustrates the flow of the program: 
InputS" l~  L2 = (S(NP(ADJ Big)(N John)) (VP(VEQ(VMEQ is) )(PREDEQ 
(PADJC(ADJC smarter) (THAN thanl(NP(N Paul)))))) 
Fl: locates the main verb "is". The available predicate 
forms are: 
PRED(~) 
PRED(ARG) 
PRED(ARG, ARG) 
FII: The form PRED(~) is generated. 
FI2: PRED(~) is the current form. 
F2: Since NP "Big John" is localized this predicate form is 
not appropriate. The executive returns to FII. 
FII: The form PRED(ARG) is generated. 
FI2: PRED(ARG) is the current form. 
F2: Since the NPs ~'Big John" and "Paul" are localized this 
form is inappropriate. Control returns to FII. 
Manelski & Krulee 
33 
FII: 
FI2: 
F2: 
FI4: 
FI3: 
F4: 
FI5: 
FI3: 
F4: 
F15: 
FI3: 
F6: 
The form PRED(AR%ARG) is generated. 
PRED(AR%ARG) is the current form.  
The NPs are in one-to-one correspondence with the ARGs. 
The variables are bound as 
PRED (ARG Big John, ARG Paul) 
and the executive transfers to F14. 
The names of the ARGs are placed in a pushdown list. 
Since the pushdown list is not empty control passes to F4. 
The first ARG in the pushdown list names 'Maul". There 
is no ARGMOD so control passes to F15. 
Pops up the ARG naming "Paul". 
There is still an ARG name on the pushdown list. 
The ARG names "Big John"; so the output becomes 
PRED(~C Big John (ARG Mod)), ~a Paul) 
and then the var iab les  are rearranged as 
PRED(ARG John (tLRGMOD Big) ), ARG Paul) .  
Pops up the last ARG name. 
Since the pushdown list is empty the executive program 
calls F6. 
Since L2 has a VEQ the PRED is bound as 
PRED is (ARG John (ARGMOD Big), ARG Paul) 
and then a further search is  made for an ADJC or PRP. 
The f~)JC naming "larger" is found so the predicate 
function becomes PRED is larger (ARG John (ARGMOD Big), 
ARG Paul) .  
Manelskl &Kru lee  
34 
FT: Since a PADV cannot be located and the verb is not 
transitive (so there can be no PREDTR) the processor 
calls sub-routlne F8. 
F8: The  predicate function is printed and the processor 
halts. 
Recognition of Equivalent Strings (A3) 
Meaning equivalence is determined by A3 which attempts to 
apply a set of heuristically determined transformations in order to 
eliminate the differences between the strings ~-i and ~'j. The set of 
transformations TO was chosen on the basis that it is found useful in a 
large class of problems taken from Stoll. The set TO does not correctly 
solve all premise equivalence problems. Some examples will be given 
where it is inadequate. 
The recognition of meaning equivalence is postponed until the 
mapping to L3 is complete. L3 was chosen to determine the pattern 
classes because the language not only orders the structure of L2~ but 
also shows the dependencies between the elements of the language, and 
permits us to manipulate easily the L3 representations ofG" i andO"j. 
The actual recognition of equivalence is determined by the 
set of transformations TO. 
Definition: The strings ~'l and~-2~ ~ L 3 are said to be 
"meaning equivalent" when we can find: 
(Ti(Tj'" "(Tm~l) 1) =6"2 
where the Ti~ Tj~...T m belong to the set TO. Where: 
TO =~ TPRN, TIMP, TTIME, TSYN~ 
Manelski & Krulee 
35 
The domain and the range of TPRN are the ARGs of the predicate forms. 
The transformation replaces the current ARG with the corresponding one 
of the preceding premise. A necessary condition for the application of 
TPRN is that the first ARG be a pronoun in its L2 representation. For 
example, let: 
i: John loves music. 
~'2: He dressed quickly. 
Their representation is 
PRED loves (ARG John, ARG music) 
PRED dressed (PREMOD quickly)(ARG He) 
The transformation TPRN~'-2) results in 
PRED dressed (PREDMOD quicl~ly)(ARG John) 
The implied transformation, TIMP, has a domain of the predicate 
functions with a null argument. The transformation replaces the missing 
argument with that of the preceding premise. For: 
~l: Dodgers won pennant. The the 
: lost the series 
with a representation of 
PRED won (ARG Dodgers (ARGMOD the), ARG Pennant(ARGMOD the)) 
PRED lost (ARGO, ARG series (ARGMOD the)). 
TIMP (~-2) results in "the predicate function 
PRED lost (ARG Dodgers, ARG series (ARGMOD the)). 
The time transformation, TTIME~ has as its domain the predicates. 
The range is also the predicates. This transformation eliminates auxiliary 
verbs and replaces the main verb with its root. The main verb is deter- 
mined by the L2 representation of the string. An example would be: 
Manelski & Krulee 
36 
~-l: John should go home. 
with ~,n L3 representation 
PRED should go (ARG John, ARG home) 
Thus TTIME ~l )becomes  
PRED go (ARG John, ARG home) 
The synonym transformation, TSYN, has a domain of the words 
Wi~ L2. Its range is also the words Wi~ L2. The transformation is 
defined by replacing any W i by its synonym as defined in the dictionary 
of the processor. The effect of TSY~ can be seen on~-le L1. 
~--l: John is happy. 
which has an L3 representation 
PRED is happy (ARG John) 
after TSYN(~'I) the predicate function might appear as 
PRED is glad (ARG John) 
This approach can certainly lead to difficulties. 
Some problems in semantics have been avoided. A word can take 
on various meanings depending on the context, as in: 
The bug crawled along the leaf. 
~ne b_~ in the program was found. 
He likes to bug me. 
The word bug takes on a different meaning in each sentence. The mistakes 
that transformations can lead to should be evident. In some contexts the 
TSYN might be appropriate while in others it is not. 
Another type of difficulty that has not been considered in 
the derivation of meaning equivalent strings is the following: One 
Manelski & Krulee 
37 
possible transformation contracts a number of arguments in the L3 
representation of a string. Thus~l ,  0" 2 ~ L2. 
~l :  John hits the ball with the bat. 
~'2: John bats the ball. 
would have their respective representations as follows in L3: 
PRED hits (ARG John) ARG ball (ARGMOD the), ARG bat (ARGMOD the)) 
PREO bats (ARG John, ARG ball (ARGMOD the))l 
By changing the predicate, a 3 ARG function becomes a 2 ARG 
function with the same meaning. By working with the set TO, the great 
majority of problems in Stoll are amenable to solution. However, the 
processor is not capable of doing justice to the human abilities of 
linguistic resolution. One noticeable characteristic of utilizing TO 
as a recognition device is its tendency to err by not recognizing 
equivalent strings rather than by un~iustified recognition. 
Although this section defines the scope and effect of TO, it 
is also necessary to specify under what conditions the automaton attempts 
to apply one of the transformations, and under what conditions the 
processor will stop trying to match the strings. The criteria for 
applying a member of TO, and the decision to halt, will. be made explicit 
in the next section. 
i Example thanks to D. Kuck. 
Manelski & Krulee 
38 
Structure of the Equivalence Recognizer (A3) 
The flow chart (seeFigure 5) of GO was intended to implement 
A3. Clearly, meaning equivalence, as defined by GO, can only be under- 
stood in light of the problem context. Thus, in the formalization of 
the sentential calculus, we shall consider 1 and 2 
i: John will go home. 
2: John went home. 
as meaning equivalent, because in this problem context meaning is time 
invariant. Obviously this is not true in conversational English. The 
program GO initially calls GI whose function is to test the number of 
~RGs in the problem strings. Failing to find the number of ARGs to be 
the same, control is passed to G3. G3 is one of a set of sub-routines, 
including G13, G17, GI4 and GI5, designed to notify the programmer that 
the strings were not found to be meaning equivalent and briefly indicate 
the reason. Should the problem strings have the same number of ARGs 
control is passed to G4 which tests for equality of PREDs. When this 
requirement is not met G5 is executed by dropping any VAUX and attempting 
to find the root of the main verb. If the existing differences are not 
eliminated by G5 the executive transfers control to G6. This sub-routine, 
like G22, G21 and G20, attempts to eliminate the differences between 
strings by using a dictionary search. Sub-routine G7 tests the PREDMODs 
for equality. Uhen any differences in the PRtVDMODs are reconciled the 
executive program calls G8. It also tests for identity in the sub-strings. 
In this case the matching is of the first ARG of each string, the second 
ARG of each string~ etc...until a 
GI7: prints 
"PREDMOD DIFF" 
G22: , re  no 
the PREI~OD6 
synonyms ? < 
L. HI 
Yes 
GO: 
GI: 
G2: 
GT: 
start 
initialize storage 
Do a~ ana ~2 have the same 
no. uf ARGs? 
Yes 
are the FRED's of" o I  and sa 
the same? 
I 
no 
are the PREDMODs of al and 02 
the same? ~ Yes 
GS: are the ARGs of al and a2 
G3: Print "DIFF NO 
ARGs" 
39@ "~ 
no GS: eliminate roots..@ G~: are-~ 
) and auxiliary Ithe FREDs I 
verbs  J of a~. and I 
/ a2 the / 
/ same ? Nd 
Yes J /  / 
' ~ G6: are the ~' 
Gg: 
Yes 
GI2: 
PRED's 
Yes 
~.~ strings 
synonyms 
the same? 
G21: are there 
e? 
no 
GI3: Po in t  
"PREDI DI~7 
PRED2" 
Print "ARGs DIFF". 
are the ARGMODS of ?I and "am 
the same? 
? GIO: are there any \ 
print "PREMH EQUIV," ' wor~ permutations? 
transformations used,  
and the strings on which GI6: Have G6 and GIO reduced 
they are used the differences between/ 
same differences 
GIS: ,:pm?nt '~GDS DIYF" . 
FIG. S ", 
Manelski &Kru lee  
4o 
difference is found in the strings. A difference in the strings leads 
the processor to execute G20, GlO~ and G16. As previously mentioned~ 
G20 searches for synonyms. G10 attempts to reduce differences by 
finding permutations of the differing ARGMODs. Finally, G16 keeps 
track of the number of differences in the strings (based on the order 
and symbols on each ARGMOD list). ~ When all differences are eliminated 
control is passed to a print routine, G12. Should the number of differ- 
ences remain constant on successive executions of the G20, G10 and G16 
loop~ the processor calls sub-routine G15. If the number of differences 
is decreasing the loop is repeated. 
The following example illustrates the logic of the system: 
~J~ l: PRED is (ARG John(ARGMOD Big tall), ARG home) 
~'2: PRED is (ARG John (ARGMOD Tall large), ARG home) 
GO: Calls GI. 
GI: Initializes storage. 
G2: Both~" 1 andS- 2 have two ARGs so the executive calls G4. 
G4: Since both the ARGs have the PRED "is" control is 
transferred to GT. 
GT: There are no PREDMODs so the processor continues to G8. 
GS: ARGs are checked in order, firstQ- 1 andS- 2 are shown 
to have the same ARG "John"~ then the second ARGs are 
both identified as "home". Since no difference exists 
the processor calls G9. 
G9: In the first ARG~DD the difference count is 2 since "Big 
tall" and "Tall large" are both different symbols. No 
second ARC~MOD is located for e i ther~ 1 or~" 2. The 
executive program calls G20. 
Manelski & Kru.lee 
41 
G20: 
GIO: 
GI6: 
G20: 
GIG: 
G16: 
GI2: 
Attempts to locate "Tall' as a synonym for f'big" and 
"large" as a synonym for "tall", and fails in both cases. 
Notes that the difference count can be decreased by 
rearranging the ARGMODs as "Big tall" and "Large tall". 
Since the number of differences has decreased from 2 to 
i the executive returns to G20. 
This time the synonym "Large' is located for "Big" 
(assuming that the synonym is stored in the dictionary 
DO). 
Since no differences are located by GI0 it cannot perform 
any permutations. 
The differences between the ARGMODs of G- I and~ 2 have 
been eliminated so a transfer is made to GI2. 
The print out "PR~4S EQUIV" is followed by the fact that 
the transformation TGYN was necessary on "Big" and TPERM 
on "Tall large". 
Manelski &Kru lee  
h2 
Summary 
This completes our description of a processing system for 
problems in the statement calculus. The  system accepts problems as 
they are normally written in English and attempts to produce a 
formalized equivalent as its outpu t . It makes uses of a series of 
automata, the first of which attempts to identify the elementary 
premises and the logical connectives. Two additional automata are 
used in order to compare premises and to determine whether or not they 
should be identified as equivalent. As a first step, each premise is 
mapped into a canonical form which simplifies the identification of 
equivalent premises. In the second step~ pairs of premises are compared. 
This automata makes use of a number of meaning-preserving transformations. 
In a sense, two premises are equivalent if one can be derived from the 
other with the aid of these transformations. Otherwise, the premises are 
evaluated as not equivalent. Although this processor is limited to a 
particular class of problems~ it was designed with two purposes in mind: 
as an attempt to simplify the problems of communications between 
programmer and computer and to clarify those processes by means of which 
meaning is extracted from natural language. 
Manelski & ~ee 
43 
GLOSSARY OF ABBREVIATIONS 
h.i.s. 
i.s. 
l.h.s. 
n.w.f.s. 
p.o.s. 
r.h.s. 
hypothesized input string 
input string 
left-hand side 
not a well formed string 
part of speech 
right-hand side 
Manelski &Krulee 
44 
R  CES 
Bobrow, D., "Syntactic Analysis of English by Computer - A Survey", 
Proceedings of the FJCC, 1963. 
Carnap, R., Introduction to Symbolic Logic and its Applications. 
New York: Dover, 1958. 
Chomsky, N., Syntactic Structures. 's-Gravenhage: Mouton, 1957. 
Green, B. F., Jr., Wolf, A. K., Chomsky, C., and Laughery, K., "Baseball: 
an Automatic Question-Answerer'. Proceedings, Western Joint Computer 
Conference. May, 1961, pp. 219-224. 
Krulee, G. K., Kuck, D. J., Landi, D. M., and Manelski, D. M., "Natural 
Language Inputs for a Problem-Solving System". Behavioral Science? 
July, 1964, pp. 281-288. 
? "A Proolem Solver with Formal Descriptive Kuck, D. J , and Krulee, G. K., 
Inputs". Computers and Information Science. Baltimore: Spartan, 
1964, pp. 344-374. 
Manelski, D. M., "A Heuristic Approach to Natural Language Processing", 
Unpublished Ph.D. thesis, Northwestern University, 1964. 
Newell, A. (Ed.), Information Processing Language-V Manual. Englewood 
Cliffs: Prentice-Hall, 1961. 
Newell, A., and Shaw, J. C., '!Programming the Logic Theory Machine". 
Proceedings~ Western Joint Computer Conference. February, 1957, 
pp. 23O-24O. 
Reichenbach, H., Elements of Symbolic Logic. New York: MacMillan, 1938. 
Manelski & Krulee 
45 
Sledd, J.~ A Short Introduction to English Grammar, Chicago: Scott, 
Fore smart, 1959. 
Stoll, R. R., Sets Logic and Axiomatic Theories. San Francisco: W. H. 
Freeman, 1961. 
Walker, D. E., and Bartlett, J. M., "The Structure of Language for Man 
and Computer: Problems in Formalization"~ I nformati.on System 
Science and Engineering. New York: McGraw-Hill, 1963. 
