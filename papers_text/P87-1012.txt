A Lazy Way to Chart-Parse with Categorial Grammars 
Ill 
Remo Pareschi  and Mark  Steedman ? 
Dept. of AI and Centre for Cognitive Science, Univ. of Edinburgh, *?
and Dept. of Computer and Information Science, Univ. of Pennsylvania ? 
ABSTRACT 
There has recendy been a revival of interest in Categorial 
Grammars (CG) among computational linguists. The various 
versions noted below which extend pure CG by including 
operations such as functional composition have been claimed 
to offer simple and uniform accounts of a wide range of natural 
language (NL) constructions involving bounded and 
unbounded "movement" and coordination "reduction" in a 
number of languages. Such grammars have obvious advan- 
tages for computational applications, provided that they can be 
parsed efficiently. However, many of the proposed extensions 
engender proliferating semantically equivalent surface syntac- 
tic analyses. These "spurious analyses" have been claimed to 
compromise their efficient parseability. 
The present paper descn~oes a simple parsing algorithm for our 
own "combinatory" extension of CG. This algorithm offers a 
uniform treatment for "spurious" syntactic ambiguities and the 
"genuine" structural ambiguities which any processor must 
cope with, by exploiting the assodativRy of functional compo- 
sition and the procedural neutrality of the combinatory rules 
of grammar in a bottom-up, left-to-fight parser which delivers 
all semantically distinct analyses via a novel unification-based 
extension of chart-parsing. 
1. Combinatory Categorial Grammars 
"Pure" categorial grammar (CG) is a grammatical notation, 
equivalent in power to context-free grammars, which puts all 
syntactic information in the lexicon, via the specification of all 
grammatical entities as either functions or arguments. For 
example, such a grammar might capture the obvious intuitions 
concerning constituency in a sentence like John must leave by 
identifying the VP leave and the NP John as the arguments of 
the tensed verb must, and the verb itself as a function combin- 
ing to its right with a VP, to yield a predicate -- that is, a 
leftward-combining function-from-NPs-into-sentences. One
common "slash" notation for the types of such functions 
expresses them as triples of the for~ <result, direction, argu. 
merit>, where result and argument are themselves syntactic 
types, and direction is indicated by "/" (for rightward- 
combining functions) or '~," (for leftward). Must then gets the 
following type-assignment: 
(I) must : -  (SkNP)/VP 
In pure categorial grammar, the only other element is a single 
"combinatory" rule of Functional Application. which gives 
rise to the following two instances: 1 
1 All combinatory roles are written as productions in the 
present paper, in contrast with the reduction rule notation used in the 
earlier papers. The change is intended to aid comparison with other 
tmification-based grammars, and has no theoretical significance. 
~) a. R ightward Appl icat ion: 
X --> X/Y Y 
b. Leftward Appl icat ion: 
X --> Y X\Y 
These rules allow functions to combine with inunediam~ adja- 
cent a~uments in the obv~us way, to ~dd the obv~ sur- 
face su'ucmres and interpretations, a  in: 
~) John must leave 
NP (S\NP)/VP VP 
. . . . . . . . . . . . .  >apply 
S\NP 
<apply 
S 
Combinatory Categorial Grammar (CCG) (Ades and Steedman 
1982, Smedman 1985, Smedman 1986) adds a number of 
further elementary operations on fimcfions and arguments m 
the combinatory component These operadons conespond to 
certain of the primitive combinamrs used by Curry and Feys 
(1958) to define the foundations of the ~calculus, notably 
including functional composition and "type raising". For 
example: 
(4) a. Subject Type Raising: 
S/(S\NP) B> NP 
b. R ightward Composit ion: 
X/Z --> X/Y Y/Z 
These combin-tory operations allow additional, non-standard 
"surface structures" like the following, which arises from the 
type-raising of the subject John into a function over predicates, 
which composes with the verb, which is of course a function 
/no predicates: 
(5) John must leave 
NP (S\NP)/VP VP 
>raise 
S/(S\NP) 
. . . . . . . . . . . . . . . . . .  >compose 
S/VP 
>apply 
S 
In general, wherever orthodox surface structure posits a right 
branching slructure like (a) below, these new operations will 
allow not only the left branching structure (b), but every mix- 
lure of right- and left- branching in between: 
(6) a.  s 
A / B "/... C" ~D 
81 
b. y , /X '~~ 
A s ~'B ...~ C ~D 
The linguistic motivation for including such operations, (and 
the grounds for contesting the standard linguists' view of sur- 
face constituency), for details of which the reader is referred to 
the bibliography, sterns from the possibility of extracting over, 
and also coordinating, a wide range of such non-standard com- 
posed structures. A crucial feature of this theory of grammar is
that the novel operation of functional composition is assoc/a- 
tire so that all the novel analyses like (5)are semantically 
equivalent to the relevant canonical analysis, like O). On the 
other hand, roles of type raising simply map arguments into 
functions over the functions of which they are argument, pro- 
ducing the same result, and thus are by themselves responsible 
for no change in generative capacity;, indeed, they can simply 
be regarded as tools which enable functional composition to 
operate in circumstances where one or both the constituents 
which need to be combined initially are not associated with a 
functional type, as when combining a subject NP with the verb 
which follows it. 
Grammars of this kind, and the related variety proposed by 
Karmrmen (1986), achieve simplicity in the grammar of move- 
ment and coordination at the expense of multiplying the 
number of derivations according to which an unambiguous 
suing such as the sentence above can be parsed. While we 
have suggested in earlier papers (Ades and Steedman 1982, 
Pareschi 1986) that this property can be exploited for incre- 
mental semantic interpretation and evaluation, a suggestion 
which has been explored further by Haddock (1987) and Hin- 
richs and Polanyi (1986), two potentially serious problems 
arise from these spurious ambiguities. The fast is the possibil- 
ity of producing a whole set of semantically equivalent ana- 
lyses for each reading of a given siring. The second more 
serious problem is that of efficiently coping with non- 
determinism in the face of such proliferating ambiguity in sur- 
face analyses. 
The problem of avoiding equivalent derivations i common to 
parsers of all grammars, even context-flee phrase-structure 
grammars. Since all the spurious derivations are by clef'tuition 
semantically equivalent, he solution seems obvious: just find 
one of them, say via a "reduce rast" strategy of the kind pro- 
posed by Ades and Steedman (1982). The problem with this 
proposal arises from the fact that, assuming left-to-right pro- 
cessing, Rightward Composition may preempt the construction 
of constituents which are needed as arguments by leftward 
combining functional types. 2 Such a depth-fast processor can- 
not take advantage of standard techniques for eliminating 
backtracking, such as chart-parsing (Kay, 1980), because the 
subconstituents for the alternative analysis will not in general 
have been built. For example, if we have produced a left- 
branching analysis like (b) above, and then rind that we need 
the constituent X in analysis (a) (say to attach a modifier), we 
will be forced to redo the entire analysis, since not one of the 
subcoustituents of X (such as Y) was a constituent under the 
previous analysis. Nor of course can we afford a standard 
breadth-fast trategy. Karttunen (1986a) has pointed out that a 
parser which associates a canonical interpretation structure 
2 If we had chosen to prc~Js fight-to-left, hen an identical 
problem would arise from the involvement ofLeftward Composition. 
with substzings in a chart can always distinguish a spurious 
new analysis of the same string from a genuinely different 
analysis: spurious analyses produce results that are the same 
as one already installed on the chart. However, the spurious 
ambiguity problem remains acute. In order to produce only the 
genuinely distinct readings, it seems that all of the spurious 
analyses must be explored, even if they can be discarded gain.  
Even for short strings, this can lead to an unmanageable 
enlargement of the search space of the processor. Similarly, 
the problem of reanalysis under backtracking still threatens to 
overwhelm the parser. In the face of this problem Wittonburg 
(1986) has recently argued that massive heuristic guidance by 
strategies quite problematically related to the grammar itself 
may be required to parse at all with acceptable costs in the face 
of spurious ambiguities ( ee also Wittenburg, this conference.) 
The present paper concerns an alternative unification-based 
chart-parsing solution which is grammatically transparent, and 
which we claim to be generally applicable to parsing "genuine" 
attachment ambiguities, under exteusions to CG which involve 
associative operations. 
2. Unification-based Comblnatory Categorlal Grammars 
As Kamunen (1986), Uszkoreit (1986), Wittenburg (1986), 
and Zeevat et al (1986) have noted, unification-based compu- 
tational enviroments (Shieber 1986) offer a natural choice for 
implementing the categories and combination roles of CGs, 
because of their rigorously dermed declarative semantics. We 
describe below a unification-besed realisation of CCG which is 
both transparent to the linguistically motivated properties of 
the theory of granu'nar and can be directly coupled to the pars- 
ing methodology we offer further on. 
2.1. A Restricted Version of Graph-unification 
We assume, like all unification formalisms, that grammatical 
constituents can be represented asfeature-structures, which we 
encode as directed acyclic graphs (dags). A dag can be either:. 
(i) a constant 
(ii) a variable 
(iii) a finite set of label-value pairs (features), where any 
value is itself a dag, and each label is associated with 
one and only one value 
We use round brackets to def'me sets, and we notate features as 
\[label value\]. We refer to variables with symbols tarting with 
capital etters, and to labels and constants with symbols tart- 
ing with lower-case letters. The following is an example of a 
dag: 
(7) ( \[a e\] 
\[b ( \ [ c  x\] 
\[d f\])\]) 
Like other unification based grammars, we adopt degs as the 
data-structures encoding categorial feature information 
because of the conceptual perspicuity of their set-theoretic 
def'mitio~ However, the variety of unification between dags 
that we adopt is more resu'ictive than the one used in standard 
graph-unification formalisms like PATR-2 (Shieber 1986), and 
closely resembles term-unification as adopted in logic- 
programming languages. 
82 
We define unification by first defining a partial ordering of 
subsumption over dags in a similar (albeit more reslricted) way 
to previous work discussed in Shieber (1986). A dag D 1 sub- 
sumes a dag D2 if the information contained in D 1 is a (not 
necessarily proffer ) subset of the information contaified in D 2. 
Thus, variables ubsume all other dags, as they contain no 
information at all. Conversely, a constant subsumes, and is 
subsumed by, itself alone. Finally, subsumptlon between dags 
which are feature-sets is defined as follows. We refer to two 
feature-sets D 1 and D? as variants of each other if there is an 
isomorphism d mapphSg each feature in D 1 onto a feature with 
the same label in D 9. Then a feature-set D1 subsumes a
feature-set D 2 if and oilly if: 
(i) D 1 and D 2 are variants; and 
(ii) if o~ f ), where f i s  a feature in D 1 and f is a feature in 
D 2, then the value o f f  subsumes tile value o f f .  
The unification of two dags D 1 and D,~ is then def'med as the 
most general dag D which is subsume?d by beth D 1 and D 2. 
Like most other unification-based approaches, we assume that 
from a procedural point of view, the process of obtaining the 
unification of two dags D 1 and D 9 requires that they be des- 
tructively modified to becfime the-same dag D. (We also use 
the term unification to refer to this process.) 
For example let D 1 and D 2 be the two following dags: 
(g) ( \ [a  ( \ [b c \ ] ) \ ]  ( \ [a  Y\] 
\[d g\] \[d z\] 
\[e X\]) \[e z\]) 
Then the following dag is the unification of D 1 and D2: 
(9) ( \[a ( \['b c\] ) \] 
\[d g\] 
\[e g\] ) 
However, under the present definition of unification, as 
opposed to the more general PATR-2 def'mition" the above is 
not the unification of the following pair of dags: 
(10) (\[a (\[b c \ ] ) \ ]  (\[d Z\] 
\[d g\]) \[e z\]) 
These two dags are not unifiable in present erms, because 
under the above clef'tuition of suhsumption" unification of two 
feature sets can only succeed if they are variants. It follows 
that a dag resulting from unification must have the same 
feature population as the two feature su-uctures that it unifies. 
The present clef'tuition of unification thus resembles term unifi- 
cation in invariably yielding a feature-set with exactly the 
same structure as both of the input feature-sets, via the insten- 
tiation of variables. The only difference from standard term 
unification is that it is defined over dags, rather than standard 
terms. By contrast, standard graph-unification can yield a 
feature-set containing features initially entirely missing from 
one or other of the unified feature-sets. The significance of this 
point will emerge later on, in the discussions of the procedural 
neutrality of combinatory rules in section 2.4, and of the 
related transparency property of functional categories in sec- 
tion 2.3. Since the properties in question inhere to the gram- 
mar itself, to which unification is merely transparent, there is 
nothing in our approach that is incompatible with the more 
general definition of graph unification offered by PATR-2. 
However, in order to establish the correctness of our proposal 
for efficient parsing of extended categorial grammars using the 
more general definition" we would have had to neutralise its 
greater power with more laborious constraints on the encoding 
of entries in the categorial lexicon as dags than those we actu- 
ally require below. The more restricted version we propose 
preserves most of the advantages of gjraph over term data- 
su'uctures pointed out in Shieber (1986)/ 
2.2. Categories as Features Structures 
We encode constituents corresponding to non-functional 
categories, such as the noun-phrases below, as feature-sets 
defining the three major attributes yraax, phonology and 
senmntics, abbreviated for reasons of space to syn, pho, and 
son (the examples of feature-based categories given below are 
of course simplified for the purposes of concise exposition -- 
for instance, we omit any specification of agreement informa- 
tion in the value associated with the syn(tax) label): 
(II) John:- (\[syn np\] 
\[pho john\] 
\[sem john' \] ) 
(12) Mary:- ( \[syn np\] 
\[pho mary\] 
\[sem mary' \] ) 
Constituents corresponding to functional categories are 
feature-sets characterized by a triple of am-ibutes, result, direc. 
t/on, end argument, abbreviated tores, dir, and ar 8. The value 
associated with dir(ection) can be instantiated to one of the 
constants / and \ and the values associated with res(ult) and 
arg(ument) can be associated with any functional or non- 
functional category. (Thus our functions are "curried", and 
may be higher order.) 
We impose the simple but crucial requirement of transparency 
over the well-formedness of functional categories in fcamre- 
based CCG. Intuitively, this requirement corresponds to the 
idea that any change to the structure of the value of arg(ument) 
caused by unification must be reflected in the value of res(ult). 
Given the definition of unification in the section above, this 
requirement can be simply stated as follows: 
(13) Functional categories must be transparent, in the sense 
that every uninstantiated feature in the value of a 
function's arg(ument) feature - that is, every feature 
whose value is a variable -- must share that variable 
value with some feature in the value of the function's 
res( ult) feature. 
Thus, whenever a feature in a function's arg(ument) is instan- 
tiated by unification, some other feature in its res(uh) will be 
iastantiated i entically, as a side-effect of the destructive 
replacement of structures imposed by unification. Variables in 
the value of the arg(ument) of a functional category therefore 
have the sole effect of increasing the specificity of the informa- 
tion contained in the value of its res(uh). As the combinatory 
rules of CCG build new constituents exclusively in terms of 
information already contained in the categories that they com- 
bine, a requirement that all the functional categories in the lex- 
icon be transparent in mm guarantees the transparency of any 
functional category assigned to complex constituents generated 
by the grammar. 
3 Calder (1987) and Thompson (1987) have independently 
motivated similar approaches to constraining unification in encoding 
83 
The fotlowing feature-based functional category for a lexical 
=ansitive tensed verb obeys the ~ransparency requiremem (the 
operator * indicates suing concatenation): 
(14) loves :- 
(\[res (\[res (\[syn s\] 
\[pho Pl*loves*P2\] 
\[sem ( \[act loving\] 
\[agent S1 \] 
\[patient $2\] ) \] } \] 
\[air \ \ ]  
\[arg ( \ [ syn  np\] 
\[pho P1 \] 
\[sem SI\])\] )\] 
\[dir / \ ]  
\[arg (\[syn np\] 
\[pho P2\] 
\[sem $2\] ) \] ) 
When two adjacent feamre-su~ctures corresponding toa func- 
tion category X 1 and an argument X9 are combined by func- 
tional application, a new feature-strucfin'e X 0 is constructed by 
unifying the argument feature-su'ucture X 2 with the value of 
the arg(ument) in the function feature s~'ucture X 1. The result 
X n is then unified with the res(~dt) of the function. For exam- 
pl~., Rightward Application can be expressed in a notation 
adapted from PATR-2 as follows. We use the notation <I 1 ... 
1~> for a path of feature labels of length n, and we identif\]7 as 
Xn(<11 ... I_>) the value associated with the feature identified 
by-the-path"<11 ... 1.> in the dag corresponding to a category 
X_. We indicate udification with the equality sign, =. Right- 
w~rd Application can then be written as: 
(15) Rightward Application: 
X 0 --> X 1 X 2 
X 1 (<direction>) - / 
X 1 (<arg>) : X 2 
X 1 (<result>) X 0 
Application of this rule to the functional feature-set (14) for the 
transitive verb loves and the feature-set (12)for the noun- 
phrase Mary yields the following structure for the verb.phrase 
loves Mary: 
(16) loves Mary:-  
(\[res (\[syn s\] 
\[pho Pl*loves*mary\] 
\[sem ( \[act loving\] 
\[agent S1 \] 
\[patient mary' \] ) \]) \] 
\[dir \\] 
\[arg (\[syn np\] 
\[pho PI\] 
\[sem Sl\] ) \] ) 
To rightward-compose two functional categories according m 
rule (4b), we similarly unify the appropriate ar&(ument) and 
res(ult) features of the input functions according to the follow- 
ing rule: 
linguistic theories. 
(17) Rightward Composition: 
X 0 --> X 1 X 2 
X 1 (<direction>) - / 
X 2 (<direction>) i / 
X 1 (<arg>) X 2 (<result>) 
X 2 (<direction>) X 0 (<direction>) 
X 1 (<result>) X 0 (<result>) 
X 2 (<arg>) X 0 (<arg>) 
For example, suppose that the non-functional feature-set 
( I I )  for the noun-phrase John is type-raised into the following 
functional feature-set, according to rule (4a), whose 
unification-based version we omit here: 
(is) John : -- 
(Ires (\[syn s\] 
\[pho P\] 
\[sem S\])\] 
\[air / \ ]  
\[arg (\[res ( \[syn s\] 
\[pho P\] 
\[sem S\] ) \] 
\[dir \\] 
\[arg (\[syn np\] 
\[pho john\] 
\[sem john'\]) \]) 1) 
Thin (18)can be combined by Rightward Composition with 
(14) to obtain the following feature structure for the functional 
category corresponding to John love~. 
(19) John loves :- 
(\[res (\[syn s\] 
\[pho john*loves*P2\] 
\[sem (\[act loving\] 
\[agent john'\] 
\[patient $2\])\])\] 
\[dir /\] 
\[arg (\[syn np\] 
\[pho P2 \] 
\[sem $2\])1) 
Leftward-combining rules are defined analogously to the 
rightward-combining rules above. 
2.3. Derivational Equivalence Modulo Composition 
Let us denote the operations of applying and composing 
categories by writing apply(X, Y) and comp(X, Y) respec- 
tively. Then by the definition of the operations themselves, 
and in particular because of the associativity of functional 
composition, the following equivalences hold across type- 
derivations: 
(20) app ly  (comp (X 1, X2), X3) 
apply (X I, apply~X 2, X 3) ) 
(21) comp(comp(X4, X5) , X6) 
- comp(X4, comp(X 5, X6)) 
More formally, the left-hand side and right-hand side of both 
equations define equivalent terms in the combinatory logic of 
84 
Curry and Feys (1958). 4 It follows that all alternative deriva- 
tions of an arbitrary sequence of functions and arguments hat 
are allowed by different orders of application and composition 
in which a composition is merely traded for an,~pplication also 
define quivalent terms of Combinatory Logic." 
So. for instance, a type for the sentence John loves Mary can 
be assigned either by rightward-composing the type-raised 
function John, (18), with loves. (14), to obtain the feature- 
structure (19)for John loves, and then rightward applying 
(19) to Mary, (12). to obtain a feature-structure for the whole 
sentence; or. conversely, it can be assigned by rightward- 
applying loves. (14), to Mary, (12), to obtain the feature- 
structure (16)for loves Mary, and then rightward-applying 
John. (18). to (16) to obtain the final feamre-su'ucmre. In both 
cases, as the reader may care to verify, the type-assignment we 
get is the following: 
(22) John loves Mary:- 
(\[syn s\] 
\[pho john*loves*mary\] 
\[sem (\[act loving\] 
\[agent john' \] 
\[patient mary' \] ) \] ) 
An important property of CCO is that it unites syntactic and 
semantic combination i  uniform operations of application and 
composition. Unification-based CCG makes this identification 
explicit by uniting the syntactic type of a constituent and its 
interpretation in a single feature-based type. It follows that all 
derivations for a given suing induced by functional composi- 
tion correspond to the same unique feature-based type, whic~ 
cannot be assigned to any other constituent in the grammar." 
This property, which we characterize formally elsewhere, is a 
direct consequence of the fact that unification is itself an asso- 
ciative operation. 
It follows in turn that a feature-based category like (22) associ- 
ated with a given constituent ot only contains all the informa- 
tion necessary for its grammatical interpretation, but also 
determines an equivalence lass of derivations for that consti- 
tuent, a point which is related to Karttunen's (1986) proposal 
for the spurious ambiguity problem (cf. secn. 1 above), but 
which we exploit differently, as follows. 
2.4. Procedural Neutrality of Combinatory Rules 
The rules of combinatory eategorial grammar are purely 
declarative, and unification preserves this property, so that, as 
with other unification-based grammatical formalisms (cf. 
Shieber 1986). there is no procedural constraint on their use. 
So far. we have only considered examples in which such rules 
are applied "bottom-up", as in example (16). in which the rule 
of application (15) is used to define the feature structure X 0 on 
the left-hand side of the rule in terms of the feature structures 
4 The terms are equivalent in the technical sense that they 
reduce to an identical normal form. 
5 The inclusion of certain higher-order function catesories in
the lexicon (of which "modifiers of modifiers" Hkeformerly would be 
an example in English) means that composition may affect he argu- 
ment structure itself, thereby changing me.~ning and giving rise to 
non-equivalent terms. This possibility does not affect he present pro- 
posal, ~d can be ignored. 
o If there is genuine ambiguity, a constitoent will of course he 
assigned more than one type. 
X 1 and X 2 on the fight, respectively instantiated asthe func- 
tion loves (14)and its argument Mary ~12). However, other 
procedural realizations are equally viable.' In particular, it is a 
property of rules (15)and (17), (and of all the cumbinatory 
rules permitted in the theory -- of. Steedman 1986) that if any 
two out of the three lements hat hey relate are specified, then 
the third is entirely and uniquely determined. This property, 
which we call procedural neutrality follows from the form of 
the rules themselves and from the transparency property 
(13) of functional categories, t~ier the definition of unifica- 
tion given in section 2.1 above." 
This property of the grammar offers a way to short-circuit the 
entire problem of non-determinism in a chart-based parser for 
grammars characterised by spurious analyses engendered by 
associative rules such as composition. The procedural neutral- 
ity of the combinatory ules allows a processor to recover con- 
stituents which are "implicit" in analysed constituents in the 
sense that they would have been built if some other equivalent 
analysis had happened to have been the one followed by the 
processor. For example, consider the situation where, faced 
with the suing John loves Mary dealt with in the last section, 
the processor has avoided multiple analyses by composing 
John, (18), with loves, (14), to obtain John loves, (19), and has 
then applied that to Mary, (12), to obtain John loves Mary 
(22), ignoring the other analysis. If the parser ams out to 
need the constituent loves Mary, (16), (as it will ff it is to find a 
sensible analysis when the sentence turns out to be John loves 
Mary mad/y), then it can recover that constituent by clef'ruing it
via the rule of Rightward Application in terms of the feature 
structures for John loves Mary, (22), and John, (18). These two 
feature structures can be used to respectively instantiate X 0 
and X I in the rule as stated at (15). The reader may verify tl~t 
instanttating the rule in this way determines the required con- 
stituent to be exactly the same category as (16). 
This particular procedural lternative tothe bottom-up invoca- 
tion of combinatery ules will be central to the parsing algo- 
rithm which we present in the following section, so it will be 
convenient togive it a name. Since it is the "parent" category 
X 0 and the "left-constituent" category X l that are instantiated, 
it seems natural to call this alternative l~ft-branch instantla- 
tlon of a combinatory ule, a term which we contrast with the 
bottom-up instantlatlon invoked in earlier examples. 
The significance of this point is as follows. Let us suppose 
that we can guarantee that a parser will always make available, 
say in a chart, the constituent that could have combined under 
7 There is an obvious analogy here with the fact that 
unification-based programming languages like Prolog do not have any 
predefmed distinction between the input and the output parameters of ?
given l~r~uw- 
From a formal point of view, procedural neutrality is ? conse- 
quence of the fact that unification-based combinatory roles, as charac- 
terised above, are e.xJens/ona/. Thus, we follow Pereira nd Shieher 
(1984) in claiming that he "bottom-up" realization of a unification- 
based rule ? corresponds to the unification of a structure E? encoding 
the equational constraints of r, and a structure D r corresponding to the 
merging of the structures instentiating the elemcnu of the right-hand 
side of r. A stmcmreN r is consequently assigned as the insumtiation f 
the left-hand side of ? by individuating a relevant substructure of the 
unification of the pair <D. E >. If ? is a rule of unification-based 
f -  ? . . . CCG, then the fact that N_ ts the mstanuauon f the left-hand side of ? 
? r , beth m terms of <D_ Er> and <D E ? guarantees that D and D ' 
? . . F r '  ? ? ? are tdenucal (m the sense that hey subsume each other). 
85 
bottom-up instantiation as a left-cenatiment with an implicit 
fight-constituent to yield the same result as the analysis that 
was actually followed. In that case, the processor will be able 
to recover the implicit right-constituent by left-branch instan- 
tiation of a single combinatory ule, without restarting syntac- 
tic analysis and without backtracking or search of any kind. 
The following algorithm does just that. 
3. A Lazy Chart Parsing Methodology 
Derivafional equivalence modulo composition, together with 
the procedural neutrality of unification-based combinatory 
rules, allows us to def'me a novel generalisadon f the classic 
chart parsing technique for extended CGs, which is "lazy" in 
the sense that: 
a) only edges corresponding to one of the set of semanti- 
cally equivalent analyses are installed on the chart; 
b) surface constituents of already parsed parts of the input 
which are not on the chart are directly generated from 
the structures which are, rather than being built from 
scratch via syntactic reanalysis. 
3.1. A Bottom-up Left-to-Right Algorithm 
The algorithm we decribe here implements a bottom-up, left- 
to-right parser which delivers all semantically distinct ana- 
lyses. Other algorithms based on alternative control strategies 
are equally feas~le. In this specific algorithm, the distinction 
between active and inactive dges is drawn in a rather diffeae+Lt 
way from the standard one. For an edge E to be active does not 
meanthat it is associated with an incomplete constituent 
(indeed, the distinction between complete and incomplete con- 
stituents is eliminated in CCG); it simply means that E can 
Irigger new actions of the parser to install other edges, after 
which E itself becomes inactive. By contrast, inactive edges 
cannot initiate modifications tothe state of the parser. 
Active edges can be added to the chart according to the three 
following actions: 
Scanning: if a is a word in the input string then, for 
each lexical entry X associated with a, add an active 
edge labeled X spanning the vertices corresponding to
the position of a on the chart. 
Lifting: if E is an active edge labeled X 1. then for 
every unary lrule of type raising which can-be instan- 
tiated as X O ~> X 1 add an active edge E 0 labeled X0 
and spannifig the sanie vertices of E 1. 
Reducing: if an edge E 9 labeled X9 has a left-adjacent 
edge E 1 labeled X I aKd there is ~ combinatory rule 
which c-an be instanfiated as X 0 --~---> X 1 X~ then add 
an active edge E 0 labeled X n spanning fife sr3rting ver- 
tex of E 1 and the ending ver~x F.. 2. 
The operational meaning of Scanning and Lifting should be 
clear enough. The Reducing action is the workhorse of the 
parser, building new constituents by invoking combinatory 
rules via bottom-up instantiadon. Whenever Reducing is 
effected over two edges E 1 and E 2 to obtain a new edge E 0 we 
ensure that: 
E l is marked as a left-generator f E N. If the rule in the 
gr'~mmar which was used is RightWard Composition, 
then E 2 is marked as a right-generator of E 0. 
The intuition behind this move is that right.generators are 
rightward functional categories which have been composed 
into, and will therefore give rise to spurious analyses ff they 
take part in further ightward combinations, as a consequence 
of the property of derivational equivalence modulo composi- 
tion, discussed in section 2.3. Left-generators correspond 
instead to choice points from where it would have been possi- 
ble to obtain a derivationally different but semantically 
equivalent constituent analysis of some part of the input string. 
They thus constitute suitable constituents for use in recovering 
/mpl/c/t right-constituents of other constituents in the chart via 
the invocation of combinatory rules under the procedure of 
left-branch instantiation discussed in the last section. 
In order to state exactly how this is done, we need to introduce 
the left-starter relation, corresponding to the lransitive closure 
of the left-generator relation: 
(i) A left-generator L of an edge E is a left-starter of E. 
(ii) If  L is a left-sterter of E, then any left-starter of L is a 
left-stsrter ofE. 
The parser can now add inactive dges cones~nding to impli- 
c/t right-constituents according to the fonowing action: 
Revealing:. if an edge E is labeled by a leftward-looking 
functional type X and there is a combinatory ule which 
can be instantiated sX'  ~> X2Xthen i f  
(i) there is an edge E 0 labeled Xn left-adjacent to E 
(ii) E 0 has a left-starter E 1 labele~ X 1 
(iii) there is a combinatory'rule which'can be instantiated 
esX 0 ~ X IX  2 
then add to the chart an inactive edge E 2 labeled X~ 
spanning the ending vertex of E 1 and the starting vertex 
of E, unless there is already an e~ige labelled in the same 
way and spanning the same vertices. Mark E?as  a 
right-generator of E 0 if the rule used in (iii) was'Righi- 
ward Composition. 
To summarise the section so far:. if the parser is devised so as 
to avoid putting on the chart subeonsfiments which would lead 
to redundant equivalent derivations, non-determiuism in the 
grammar will always give rise to cases which require some of 
the excluded constituents. In a left-to-right processor this typi- 
cally happens when the argument required by a leftward- 
looking fimctional type has been mistakenly combined in the 
analysis of a substring left-adjacent to that leftward-looking 
type. However, such an implicit or hidden constituent could 
have only been obtained through an equivalent derivation path 
for the left-adjacent substring. It follows that we can "reveal" 
it on the chart by invoking a combinatory ule in terms of left- 
branch instantiation. 
We can now informally characterize the algorithm itself as fol- 
lows: 
the parser does Scanning for each word in the input 
string going left-to-right 
moreover, whenever an active edge A is added to the 
chart, then the following actions are taken in order. 
(i) the parser does Lifting over A 
(ii) if A is labeled by a leftward-looking type, then 
for every edge E left-adjacant toA the parser does 
Revealing over E with respect to A 
86 
(iii) for every edge E left-adjacent to A the parser does 
Reducing over E and A, with the constraint that 
ff A is not labeled by a leftward-looking type then 
E must not be a right-generator of any edge E' 
the parser eturns the set of categories associated with 
edges spanning the whole input, if such a set is not 
empty; it fails otherwise,. 
3.2. An Example 
In the interests of brevity and simplicity, we eschew all details 
to do with unifieafion itself in the following examples of the 
workings of the parser, reverting to the original categorial 
notation for CCG of section 1, bearing in mind that the 
categories are now to be read strictly as a shorthand for the 
fuller notation of un/fication-based CCG. For similar easons 
of simplicity in exposition, we assume for the present purpose 
that the only type-raising rule in the grammar is the subject 
rule (4a). 
The algorithm analy~es the sentence John loves Mary madly as 
follows. First, the parser Scans the first word John, ed~g to 
the chart an active NP edge corresponding to its sole lexical 
entry, and spanning the word in question, thus: 
(23) ? Jo.. .Z~._~ ? 
NP 
(We adopt the convention that active edges are indicated by 
upper-case categories, while inactive edges will be indicated 
with lower-easo categories.) Since the edge in question is 
active, it fails under the second clause of the algorithm. The 
Lifting condition (i) of this clause applies, since there is a rule 
which type raises over NP, so a new active edge of type 
S/(S~rP) is added, spanning the same word, John (no other 
conditions apply to the NP active edge, and it becomes inac- 
tive): 
(24) . ,~!  (S\NP) 
np 
Neither Lifting. Revealing, nor Reducing yield any new edges, 
so the new active edge merely becomes inactive. The next 
word is Scanned to add a new lexical active edge of type 
(S~NP)/NP spanning loves:. 
(25) s/(s\np) 
~ ~  loves . 
The new lexical edge Reduces with the type-raised subject o 
yield a new active edge of type S/NP. The subject category is 
marked as the new edge's left-generator, and (because the 
combinatory rule was Rightward Composition) the verb 
category is marked as its right-generator. Nothing more 
results from loves, and neither Lifting, Revealing nor Reducing 
yield anything from the new edge, so it too becomes inactive, 
and the next word is Sc~rmed to add a new lexical active NP 
edge corresponding to Mary: 
(26) ~ / n p  
np ( s \n~/np  NP 
This edge yields two new active edges before becoming inac- 
five, one of type S/(S~P) via Lifting and the subject rule, and 
one of type S, via Reducing with the s/np edge to its left by the 
Forward application rule (we omit the former from the illustra- 
lion, because nothing further happens to it, but it is there 
nonetheless): ~ 
The s/np edge is in addition marked as the left generator f the 
S. Note that Reducing would potentially have allowed a third 
new active edge corresponding to loves Mary to be added by 
Reducing the new active NP edge corresponding toMary with 
the left-adjacent (s~np)/np edge, loves. However. this edge has 
been marked as a right generator, and is therefore not allowed 
to Reduce by the algorithm. 
Nothing new results from the new active S edge, so it becomes 
inactive and the next word mad/y is scanned to add a new 
active e d g ~  
(28) ~__~/~~/np  
:~ohpg~ loves ~. ~. . .~  madly . 
( s \np~--/np ~ (S \ N-~\[~--~S \NP ) 
This active edge, being a leftward=looking functional type, pre- 
cipitates Revealing. Since there is a rule (Backward Applica- 
tion. 2a) which would allow madly, (S~IP)~(S~IP) tocombine 
with a left-adjacent s~np, and there is a rule (Forwards Appli- 
cation, 2a) which would allow a left-starter John . . . .  
~hine  with ~h en ,~p  to yield the s which is le~-~ 
to madly, (and since there is no left-adjacent s~np there 
already), the rule of Forward Application can be invoked via 
Left-branch Instantiation to Reveal the inactive edge loves 
Mary, s ~ p . ~ ~ ' ~ , ~  
..- ~ , .~- , .  .o , , . , , , .  ~- , ,  ,. ~a .~._~. .~._ .~.  
~ ( S \ N P )  \ (S\NP) 
The (still) active backward modier mad/y can now Reduce 
with the newly introduced s~mp, to yield a new active edge 
S~P corresponding to loves Mary madly, before becoming 
inactive: ~
(30) ///~/,/cs\~p~ ~',,o/np ",~ 
.'/John TM.~ loves~._ Marg~..._Lmadly ~.  
The new active edge potentially gives rise to two semantically 
equivalent Reductions with the subject John to yield S -- one 
with its ground np type, and one with its raised type, s/(s~np). 
Only one of these is effected, because of a detail dealt with in 
the next section, and the algorithm terminates with a single S 
edge spanning the str/n~" ~. 
np ~np l /np  np_/(s\np) \ (s\npJ/ 
In an attachment-ambiguous sentence like the following, which 
we leave as an exercise, two predicates, believes John loves 
Mary and loves Mary. are revealed in the penultimate stage of 
the analysis, and two semantically distinct analyses result" 
(32) Fred believes John loves Mary passionately 
Space permits us no more than to note that this procedure will 
87 
also cope with another class of constructions which constitute 
a major source of non-determinism in natural language pars- 
ing, namely the diverse coordinate constructions whose 
categorial analysis is discussed by Dowty (1985) and Steed- 
man (1985, 1987). 
4. Type Raising and Spurious Ambiguity 
As noted at example (30) above, type raising rules introduce a 
second kind of spurious ambiguity connected to the interac- 
tions of such rules with functional application rather than func- 
tional composition. If the processor can Reduce via a rule of 
application on a type.raised category, then it can also always 
invoke the opposite rule of appHcaton to the u~aised version 
of the same category to yield the same result. Spurious ambi- 
guity of this kind is trivially easy to avoided, as (u~l~e the 
kind associated with composition), it can always be detected 
locally by the following redundancy check on attachment of
new edges to the chart in Reducing: when Reducing creates an 
edge via functional application, then it is only added to the 
chart if there is no edge associated with the same feature 
structure and spanning the same vertices already on the chart. 
5. Alternative Control Strategies and Grammatical For- 
mailsms 
The algorithm described above is a pure bottom-up arsing 
procedure which has a close relative in the Cocke-Kasami- 
Younger algorithm for context-free phrase-strucnne grammars. 
However, our chart-parsing methodology is completely open to 
alternative control options. In particular, Pareschi (forthcom- 
ing) describes an adaptation of the Farley algorithm, which, in 
virtue of its top-down prediction stage, allows for efficient 
application of more genera\] type-raising rules than are con- 
sidered here. Formal proofs of the correcmess of both these 
algorithms wili be presented in the same reference. 
The possibility of exploiting this methodology for improving 
processing of other unification-based xtensions of CG involv- 
ing spurious ambiguity, like the one reported in Kartmnen 
(1986a), is also under exploration. 
6. Conclusion 
The above approach to chart-parsing with extensions to CGs 
characterised by spurious ambiguities allows us to def'me algo- 
rithms which do not build significantly more edges than chart 
parsers for more standard theories of grammar. Our technique 
is fully transparent with respect to our grammatical formalism, 
since it is based on properties of associativity and procedural 
neutrality inherent in the grammar itself. 9 
ACKNOWLEDGEMENTS 
We thank Inge Bethke, Kit F'me, Ellen Hays, Aravind Joshi, Dale 
Miller, Henry Thompson, Bonnie Lynn Webher, and Kent Wittenberg 
for help and advice. Parts of the research were supported by: an Edin- 
burgh Univeni W Research Studentship; anESPRIT grant (project 393) 
to CCS, Univ. Edinburgh; a Sloan Foundation grant o the Cognitive 
Science Program, Univ. Pennsylvania; and NSF grant IRI-10413 A02. 
ARO grant DAA6-29- 84K-0061 and DARPA grant N0014-85-K0018 
to CIS, Univ. Pennsylvania. 
9 Chart parsers based on the methodology described here and 
written in Quintus Prolog have been developed ona Sun workstation. 
REFERENCES 
Ades, A. and Steedman, M. J. (1982) On the Order of Words. 
Linguistics and Philosophy, 44, 517-518. 
Calder, J. (1987) Typed Unification for Natural Language 
Processing. Ms, Univ. of Edinburgh 
Curry, H. B. and Feys, R. (1958) Combinatory Logic, 
Volume I. Amsterdam: North Holland. 
Dowry, D. (1985). Type raising, functional composition and 
non-constituent coordination. In R. Oehrle et al (eds.), 
Categorial Grammars and Natural Language Structures, 
Durdrecht, Reidel. (In press). 
Haddock, N. J. (1987) Incremental Interpretation and 
Combinatory Categorial Grammar. In Proceedings of 
the Tenth International Joint Conference on Artifi- 
cial Intelligence, Milan, Italy, August, 1987. 
Hinrichs, E. and Polanyi, L. (1986) Pointing the Way. Papers 
from the Parasession on Pragrnatics and Grammatical 
Theory at the Twenty-Second Regional Meeting of the 
Chicago Linguistic Society, pp.298-314. 
Karttunen, L. (1986) Radical Lexicalism. Paper presented at
the Conference on Alternative Conceptions of Phrase 
Structure, July 1986, New York. 
Kay, M. (1980) Algorithm Schemata and Data Structures in 
Syntactic Processing. Technical Report No. CSL-80- 12, 
XEROX Palo Alto Research Centre. 
Pareschi, Remo. 1986. Combinatory Categorial Grammar, 
Logic Programming, and the Parsing of Natural 
Language. DAI Working Paper, University of Edinburgh. 
Pareschi, R. (forthcoming) PhD Thesis, Univ. Edinburgh. 
Pereint, F. C. N. and Shieber, S. M. (1984) The Semantics of 
Grammar Formalisms Seen as Computer Languages. In 
Proceedings of the 22rid Annual Meeting of the ACL, 
Stanford, July 1984, pp.123-129. 
Shieber, S. M. (1986) An Introduction to Unification-based 
Approaches to Grammar, Chicago: Univ. Chicago Press. 
Stcedman, M. (1985) Dependency and Coordination in the 
Grammar of Dutch end English. Language, 61,523-568. 
Steedmen,M. (1986) Combinatory Grammars and Parasitic 
Gaps. Natural Language and Linguistic Theory, to 
appear. 
Steedman, M. (1987) Coordination and Constituency in a 
Combinatory Grammar. In Mark Baltin and Tony Kroch. 
(eds.), Alternative Conceptions of Phrase Structure, 
University of Chicago Press: Chicago. (To appear.) 
Thompson. H. (1987) FBF- An Alternative to PATR as a 
Grammatical Assembly Language. Research Paper, 
Department of A.I, Univ. Edinburgh. 
Uszkoreit, H. (1986) Categorial Unification Grammars. In 
Proceedings of the l lth International Conference on 
Computational Linguistics, Bonn, August. 1986, pp187- 
194. 
Wittenburg, K. W. (1986) Natural Language Parsing with 
Combinatory Categorial Grammar in a Graph- 
Unification-Based Formalism. PhD Thesis, Deparunem 
of Linguistics, University of Texas. 
Zeevat, H., Klein, E. and Calder, J. (1987) An Introduction to 
Unification Categorial Grammar. In N. Haddock et al 
(eds.), Edinburgh Working Papers in Cognitive Science, 
1: Categorial Grammar, Unification Grammar, and Pars- 
ing. 
88 
