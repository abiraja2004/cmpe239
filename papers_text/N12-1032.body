2012 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pages 315?326,
Montre?al, Canada, June 3-8, 2012. c?2012 Association for Computational Linguistics
Getting More from Morphology in Multilingual Dependency Parsing
Matt Hohensee and Emily M. Bender
University of Washington
Department of Linguistics
Box 354340
Seattle WA 98195-4340, USA
{hohensee, ebender}@uw.edu
Abstract
We propose a linguistically motivated set of
features to capture morphological agreement
and add them to the MSTParser dependency
parser. Compared to the built-in morphologi-
cal feature set, ours is both much smaller and
more accurate across a sample of 20 morpho-
logically annotated treebanks. We find in-
creases in accuracy of up to 5.3% absolute.
While some of this results from the feature set
capturing information unrelated to morphol-
ogy, there is still significant improvement, up
to 4.6% absolute, due to the agreement model.
1 Introduction
Most data-driven dependency parsers are meant to
be language-independent. They do not use any
information that is specific to the language being
parsed, and they often rely heavily on n-grams, or
sequences of words and POS tags, to make parsing
decisions. However, designing a parser without in-
corporating any specific linguistic details does not
guarantee its language-independence; even linguis-
tically na??ve systems can involve design decisions
which in fact bias the system towards languages with
certain properties (Bender, 2011).
It is often taken for granted that using linguistic
information necessarily makes a system language-
dependent. But it is possible to design a linguisti-
cally intelligent parser without tuning it to a specific
language, by modeling at a high level phenomena
which appear cross-linguistically. Such a system is
still language-independent; it does not require any
knowledge or modeling of specific languages, but
it does use linguistic knowledge to make the most
of the available data. We present modifications to
an existing system, MSTParser (McDonald et al.,
2006), to incorporate a very simple model of mor-
phological agreement. These modifications improve
parsing performance across a variety of languages
by making better use of morphological annotations.
2 Background and related work
2.1 Morphological marking of agreement
Most languages show some morphological agree-
ment via inflected noun, adjective, verb, and deter-
miner forms, although the degree to which this hap-
pens varies. At one end of the spectrum are analytic,
or ?morphologically impoverished?, languages. An
extreme example is Chinese, which shows no inflec-
tion at all; words do not take different forms de-
pending on features such as person or gender. En-
glish has some inflection, but is relatively morpho-
logically poor.
At the other end are synthetic or ?morphologi-
cally rich? languages such as Czech, which has, inter
alia, four genders and seven cases. In synthetic lan-
guages, words which are syntactically related in cer-
tain ways must agree: e.g., subject-verb agreement
for gender or determiner-noun agreement for case
(Corbett, 2006). Words participating in agreement
may be marked explicitly for the property in ques-
tion (via affixing or other morphological changes),
or may possess it inherently (with no specific affix
encoding the property). Treebanks are often anno-
tated to reflect some or all of these properties; the
level of detail depends on the annotation guidelines.
315
zahranic?n?? investice rostou
foreign investment grow
.F.PL.NOM .F.3RD.PL.NOM .3RD.PL.PRES
foreign investments grow
foreign investment grow
.3RD.PL .PL
Table 1: Sentence in Czech (Hajic?, 1998) and English
A sample sentence in English and Czech (Table 1)
demonstrates this contrast. In Czech, the adjective
and noun agree for gender, number, and case, and
the noun and verb agree for person and number. In
the English version, only the noun and verb agree.
Agreement can be very useful for data-driven de-
pendency parsing. A statistical parser can learn from
training data that, for example, a third-person singu-
lar noun is a likely dependent of a verb marked as
third-person singular. Similarly, it can learn that a
determiner showing genitive case and a noun show-
ing dative case are often not syntactically related.
It is often assumed that morphological complex-
ity correlates with degree of variation in word order.
This is because synthetic languages use inflection to
mark the roles of constituents, while analytic lan-
guages generally assign these roles to specific phrase
structural locations. Siewierska (1998) investigated
this empirically and found that it holds to a certain
extent: the absence of agreement and/or case mark-
ing predicts rigid word order, though their presence
is not particularly predictive of flexible word order.
Many parsers rely on word order to establish de-
pendencies, so they often perform best on languages
with more rigid word order. Making use of mor-
phological agreement could compensate for greater
variation in word order and help to bring parsing per-
formance on flexible-word-order languages up to par
with that on rigid-word-order languages.
2.2 MSTParser
The CoNLL-X (Buchholz and Marsi, 2006) and
CoNLL 2007 (Nivre et al., 2007) shared tasks fo-
cused on multilingual dependency parsing. Each
system was trained on treebanks in a variety of lan-
guages and predicted dependency arcs and labels for
POS-tagged data. The best performers in 2006 were
MSTParser (McDonald et al., 2006), which we use
here, and MaltParser (Nivre et al., 2006a).
MSTParser is a data-driven, graph-based parser
which creates a model from training data by learn-
ing weights for arc-level features. The feature set in-
cludes combinations of the word and POS tag of the
parent and child of each dependency arc; POS tags
of words between the parent and child; and POS tags
of the parent and child along with those of the pre-
ceding and following words. A similar feature set is
conjoined with arc labels in order to perform label-
ing, and an optional set of ?second-order? features
includes analogous information about siblings.
Morphological features for an arc are generated
by iterating over each pair in the cross product of
the parent and child tokens? lists of attributes. For
every such pair, thirteen groups of four features each
are generated. The thirteen groups represent combi-
nations of the head and child word forms/lemmas
and attributes. Each group contains subgroups dis-
tinguished by whether they use word forms or lem-
mas and by whether or not they encode the direc-
tion and distance of the dependency. These features
are summarized in Table 2. At run time, MSTParser
finds the highest-scoring parse for each sentence ac-
cording to the learned feature weights.
Decoding can be performed in projective or non-
projective mode, depending on the type of trees de-
sired. Projective trees are those in which every con-
stituent (head plus all dependents) forms a complete
subtree; non-projective parsing lacks this limitation.
2.3 Related work
The organizers of the CoNLL 2007 shared task
noted that languages with free word order and high
morphological complexity are the most difficult for
dependency parsing (Nivre et al., 2007). Most of the
participants took language-independent approaches
toward leveraging this complexity into better perfor-
mance: generating machine learning features based
on each item in a token?s list of morphological at-
tributes (Nivre et al., 2006b; Carreras et al., 2006);
using the entire list as an atomic feature (Chang et
al., 2006; Titov and Henderson, 2007); or generat-
ing features based on each pair of attributes in the
cross-product of the lists of a potential head and de-
pendent (McDonald et al., 2006; Nakagawa, 2007).
Language-specific uses of morphological infor-
mation have included using it to disambiguate func-
tion words (Bick, 2006) or to pick out finite verbs
316
<hdIdx>*<dpIdx>=<{hdForm|hdLemma}>(<dir+dist>)
<hdIdx>*<dpIdx>=<{dpForm|dpLemma}>(<dir+dist>)
<hdIdx>*<dpIdx>=<hdAtt>(<dir+dist>)
<hdIdx>*<dpIdx>=<dpAtt>(<dir+dist>)
<hdIdx>*<dpIdx>=<{hdForm|hdLemma}><{dpForm|dpLemma}>(<dir+dist>)
<hdIdx>*<dpIdx>=<{hdForm|hdLemma}><hdAtt>(<dir+dist>)
<hdIdx>*<dpIdx>=<{hdForm|hdLemma}><dpAtt>(<dir+dist>)
<hdIdx>*<dpIdx>=<{dpForm|dpLemma}><dpAtt>(<dir+dist>)
<hdIdx>*<dpIdx>=<{dpForm|dpLemma}><hdAtt>(<dir+dist>)
<hdIdx>*<dpIdx>=<hdAtt><dpAtt>(<dir+dist>)
<hdIdx>*<dpIdx>=<{hdForm|hdLemma}><hdAtt><dpAtt>(<dir+dist>)
<hdIdx>*<dpIdx>=<{dpForm|dpLemma}><hdAtt><dpAtt>(<dir+dist>)
<hdIdx>*<dpIdx>=<{hdForm|hdLemma}><{dpForm|dpLemma}><hdAtt><dpAtt>(<dir+dist>)
Table 2: Original MSTParser feature templates. hdForm and dpForm are the head and dependent word forms;
hdLemma and dpLemma are the lemmas. hdAtt and dpAtt are the morphological attributes; hdIdx and dpIdx
are their indices. dir+dist is a string encoding the direction and length of the arc. Each line represents one feature.
Unlabeled
<attr>_agrees,head=<headPOS>,dep=<depPOS>
<attr>_disagrees,head=<headPOS>,dep=<depPOS>
head_<attr=value>,head=<headPOS>,dep=<depPOS>
dep_<attr=value>,head=<headPOS>,dep=<depPOS>
Labeled
<attr>_agrees&label=<label>,head=<headPOS>,dep=<depPOS>
<attr>_disagrees&label=<label>,head=<headPOS>,dep=<depPOS>
head_<attr=value>&label=<label>,head=<headPOS>,dep=<depPOS>
dep_<attr=value>&label=<label>,head=<headPOS>,dep=<depPOS>
Table 3: Agreement feature templates. headPOS and depPOS are the head and dependent coarse POS tags.
(Carreras et al., 2006). Schiehlen and Spranger
(2007) used language-specific rules to add detail to
other features, such as fine-grained POS tags or lem-
mas. Attardi et al. (2007) modeled agreement ex-
plicitly, generating a morphological agreement fea-
ture whenever two tokens possess the same value
for the same linguistic attribute. The authors note
accuracy improvements of up to 0.5% for Italian
and 0.8% for Catalan using a transition-based parser.
A similar approach was used by Goldberg and El-
hadad (2010), who improved the accuracy of their
transition-based Hebrew parser by adding features
for gender and number agreement in noun phrases.
The potential of morphological information to im-
prove parsing performance has been documented in
numerous experiments using MaltParser and with
various morphological attributes as machine learn-
ing features, on several morphologically rich lan-
guages, including: Russian (Nivre et al., 2008);
Swedish (?vrelid and Nivre, 2007); Bangla, Tel-
ugu, and Hindi (Nivre, 2009); Turkish (Eryig?it et
al., 2008); and Basque (Bengoetxea and Gojenola,
2010). These experiments, however, did not include
any higher-level features such as agreement.
Goldberg and Elhadad (2009) found that using
morphological features increased the accuracy of
MSTParser on Hebrew only when the morpholog-
ical annotations were gold-standard; automatic an-
notations decreased accuracy, although MaltParser
showed improvement with both gold and automatic
annotations. The accuracy of MaltParser on Arabic
was improved by different types of morphological
features depending on whether gold or automatic an-
notations were used (Marton et al., 2010).
As far as we can tell, no language-independent
approaches to utilizing morphological data thus far
have taken advantage of agreement specifically. We
take a linguistically informed approach, maintain-
ing language-independence, by explicitly modeling
agreement between head and dependent morphol-
ogy.
3 Methodology
3.1 Modifications to parser
Our approach builds on the observation that there
are two kinds of information marked in morphol-
ogy: symmetric, recorded on both head and depen-
317
ID TOKEN CPOS MORPH HEAD REL Gloss
1 Vznikaj?? VERB num=PL|per=3 0 ROOT arise.3RD.PL
2 zbytec?ne? ADJ num=PL|gen=I|case=NOM 3 ATR unnecessary.PL.INAN.NOM
3 konflikty NOUN num=PL|gen=I|case=NOM 1 SBJ conflicts.PL.INAN.NOM
num_agrees,head=NOUN,dep=ADJ num_agrees,head=VERB,dep=NOUN
num_agrees&label=ATR,head=NOUN,dep=ADJ num_agrees&label=SBJ,head=VERB,dep=NOUN
gen_agrees,head=NOUN,dep=ADJ head_per=3,head=VERB,dep=NOUN
gen_agrees&label=ATR,head=NOUN,dep=ADJ head_per=3&label=SBJ,head=VERB,dep=NOUN
case_agrees,head=NOUN,dep=ADJ dep_gen=I,head=VERB,dep=NOUN
case_agrees&label=ATR,head=NOUN,dep=ADJ dep_gen=I&label=SBJ,head=VERB,dep=NOUN
dep_case=NOM,head=VERB,dep=NOUN
dep_case=NOM&label=SBJ,head=VERB,dep=NOUN
Table 4: Sample sentence (Hajic?, 1998) and agreement features generated
dent, and asymmetric, marked on only one or the
other. Symmetric information provides a natural,
effectively non-lossy type of back-off that parsers
can take advantage of; all that matters is whether
the information on the head and dependent match.1
Furthermore, we don?t need to know ahead of time
which types of morphological information are sym-
metric. This is extracted from the annotations.
In order to take advantage of this property of nat-
ural language, we devised a set of features which
model agreement. These allow the learner to op-
erate at a higher level, using agreement itself as a
feature rather than having to discover agreement and
forming generalizations about whether tokens which
agree (or disagree) in various ways are related. Since
agreement appears cross-linguistically, such features
are applicable to a diverse set of languages.
Since MSTParser breaks down every parse into a
set of arcs, our features are defined at the arc level.
Each arc is a head and dependent pair, and each of
those tokens has a list of morphological features in
the normalized form attribute=value. We com-
pare these lists and add, for every attribute which
is present in both, either an agreement or a disagree-
ment feature, depending on whether the head and de-
pendent have the same value for that attribute. This
feature encapsulates the attribute, but not the value,
as well as the coarse POS tags of the head and the
dependent. If an attribute is present in only one of
1If an attribute is marked on both head and dependent and
the value matches, the specific value should not affect the prob-
ability or possibility of the dependency relationship. If the same
attribute is marked on both elements but is independent (not a
matter of agreement) we risk losing information, but we hypoth-
esize that such information is unlikely to be very predictive.
the lists, we add a feature encapsulating whether the
token is the head or the dependent, the single mor-
phological feature (attribute and value), and the two
coarse POS tags. We also generate both types of fea-
tures conjoined with the arc label. Like the original
feature set, we include only first-order morphologi-
cal features. See Table 3 for a summary. A sample
sentence in a simplified CoNLL format and the fea-
tures it would trigger are shown in Table 4.2
We hypothesize that these agreement features will
function as a type of back-off, allowing the parser
to extract more information from the morphological
marking. For instance, they can capture case agree-
ment between a determiner and noun. We expect
that this would lead to higher parsing accuracy, espe-
cially when training on smaller datasets, where mor-
phological data might be sparse.
We made a slight modification to the parser so that
underscores used in the treebanks to indicate the ab-
sence of morphological annotation for a token were
not themselves treated as morphological informa-
tion. This was necessary to ensure that all feature
configurations performed identically on treebanks
with no morphological information. Depending on
the treebank, this increased or decreased the perfor-
mance of the system slightly (by less than 0.5%).
3.2 Data collection and preparation
We gathered a range of dependency treebanks, rep-
resenting as many language families as possible (Ta-
ble 5). Many of these used the CoNLL shared task
treebank format, so we adopted it as well, and con-
2A more complete description of the system, as well as
source code, can be found in (Hohensee, 2012).
318
Language ISO Treebank Num.
sents.
Ref.
size
Avg.
atts.
Reference
Hindi-Urdu hin HUTB 3,855 2,800 3.6 (Bhatt et al., 2009)
Hungarian hun Szeged DTB 92,176 9,000 3.3 (Vincze et al., 2010)
Czech ces PDT 1.0 73,068 9,000 2.8 (Hajic?, 1998)
Tamil tam TamilTB v0.1 600 600 2.8 (Ramasamy and Z?abokrtsky?, 2011)
Slovene slv SDT 1,998 1,500 2.6 (Dz?eroski et al., 2006)
Danish dan DDT 5,512 5,500 2.4 (Kromann, 2003)
Basque eus 3LB* 3,175 2,800 2.4 (Aduriz et al., 2003)
Dutch nld Alpino 13,735 9,000 2.4 (Van der Beek et al., 2002)
Latin lat LDT 3,423 2,800 2.4 (Bamman and Crane, 2006)
Bulgarian bul BulTreeBank 13,221 9,000 2.1 (Simov et al., 2004)
Greek (ancient) grc AGDT 21,104 9,000 2.1 (Bamman et al., 2009)
Finnish fin Turku 4,307 2,800 2.0 (Haverinen et al., 2010)
German deu NEGRA 3,427 2,800 2.0 (Brants et al., 1999)
Turkish tur METU-Sabanci 5,620 5,500 1.6 (Oflazer et al., 2003)
Catalan cat CESS-ECE* 3,512 2,800 1.5 (Mart? et al., 2007)
Arabic ara PADT 1.0 2,367 2,300 1.2 (Hajic et al., 2004)
Italian ita TUT 2,858 2,800 1.1 (Bosco et al., 2000)
Portuguese por Floresta 9,359 9,000 1.0 (Afonso et al., 2002)
Hebrew (modern) heb DepTB 6,214 5,500 0.9 (Goldberg, 2011)
English eng Penn* 49,208 9,000 0.4 (Marcus et al., 1993)
Chinese cmn Penn Chinese 28,035 9,000 0.0 (Xue et al., 2005)
*Acquired as part of NLTK (Bird et al., 2009)
Table 5: Language, ISO 639-2 code, treebank name, total number of sentences, reference size, average number of
morphological attributes per token, and reference for each treebank used, ordered by average number of attributes.
verted the other treebanks to the same. It includes
for each token: position in the sentence; the token
itself; a lemma (not present in all datasets); a coarse
POS tag; a fine POS tag; a list of morphological fea-
tures; the token?s head; and the label for the depen-
dency relation to that head.3 We retained all punctu-
ation and other tokens in the treebanks.
The POS tagsets used in the treebanks varied
widely. We normalized the coarse tags to the univer-
sal twelve-tag set suggested by Petrov et al. (2011),
in order to ensure that every treebank had coarse tags
for use in the agreement features, and to make the
features easier to interpret. It is unlikely that infor-
mation was lost in this process: for treebanks with
one set of tags, information was added, and for those
with two, the universal tags aligned closely with the
coarse tags already in the data.
Two of the treebanks we used included no mor-
phological information. We included the Penn Chi-
nese Treebank as a representative of analytic lan-
guages.4 We also included part of the (English) Penn
3The original format also included two more fields, projec-
tive head and label; neither is used by MSTParser.
4Dependency trees were generated from the Penn Chinese
Treebank, converted to dependency trees. For this
data we generated morphological annotations based
on fine POS tags, consisting of person and number
information for nouns and verbs, and person, num-
ber, and case information for pronouns. The German
NEGRA corpus includes detailed morphological an-
notations for about 3,400 sentences (of 20,600), and
we used only that portion.
Note that the amount of morphological informa-
tion present in any given treebank is a function of the
morphological properties of the language as well as
the annotation guidelines: annotations do not nec-
essarily encode all of the morphological informa-
tion which is actually marked in a language. Fur-
thermore, the presence of a morphological feature
does not imply that it participates in an agreement
relationship; it merely encodes some piece of mor-
phological information about the token. Finally, an-
notation guidelines vary as to whether they provide
for the explicit marking of morphological proper-
ties which are inherent to a lemma (e.g., gender on
nouns) and not marked by separate affixes.
Treebank using the Penn2Malt converter: http://w3.msi.
vxu.se/?nivre/research/Penn2Malt.html.
319
We normalized all morphological annotations to
the form attribute=value (e.g., case=NOM). For
treebanks that provided values only, this involved
adding attribute names, obtained from the annota-
tion guidelines. The attributes person, number, gen-
der, and case appeared often; also included in some
data were verb tense, adjective degree, and pronoun
type (e.g., personal, possessive, or reflexive). We
normalized all features in the data, regardless of
whether they participate in any agreement relations.
Many of the treebanks include data from multiple
domains; to minimize the effects of this, we random-
ized the order of sentences in each treebank.
3.3 Experimental setup
All experiments were performed using 5-fold cross-
validation. Reported accuracies, run times, and fea-
ture counts are averages over all five folds. We
ran experiments on multiple cross-validation dataset
sizes in order to assess the performance of our model
when trained on different amounts of data. For each
treebank, we report results on a ?reference size?:
9,000 sentences or the largest size available (for tree-
banks of less than 9,000 sentences).
For evaluation, we used the module built into
MSTParser. We focused on the unlabeled accu-
racy score (percentage of tokens with correctly as-
signed heads, ignoring labels). We also looked at
labeled accuracies, but found they displayed trends
very similar, if not identical, to the unlabeled scores.
4 Results
We ran the system on each treebank at all dataset
sizes in projective and non-projective modes, using
no morphological features. For each language, sub-
sequent tests used the algorithm which performed
better (or non-projective in the case of a tie).
4.1 Overall results
We ran the parser on each treebank with each of
four feature configurations: one with no morpho-
logical features (no-morph); one with the original
morphological features (orig; Table 2); one using
the agreement features (agr; Table 3); and one us-
ing both feature sets (agr+orig).
Table 6 displays the unlabeled accuracy, run time,
and feature counts when parsing each treebank using
each feature configuration at the reference size, with
the highest accuracy highlighted. Excluding Chi-
nese, agr generated the best performance in all but
two cases, outperforming orig by margins ranging
from 0.8% (Arabic) to 5.3% (Latin) absolute. In the
other cases, agr+orig outperformed agr slightly.
In all cases, the total number of machine learning
features was approximately the same for no-morph
and agr, and for orig and agr+orig, because
the number of morphological features generated by
orig is very large compared to the number gener-
ated by agr. Performance was noticeably faster for
the two smaller feature configurations.
Figure 1 shows the error reduction of orig, agr,
and agr+orig relative to no-morph, at the refer-
ence size. Despite its relative lack of morphological
inflection, English shows a fairly high error reduc-
tion, because parsing performance on English was
already high. Similarly, error reduction on some of
the morphologically rich languages is lower because
baseline performance was low. Calculating the cor-
relation coefficient (Pearson?s r) between average
morphological attributes per token and error reduc-
tion gives r = 0.608 for orig, r = 0.560 for agr,
and r = 0.428 for agr+orig, with p < 0.01 for
the first two and p < 0.10 for the last, indicating
moderate correlations for all feature sets.
The strength of these correlations depends on sev-
eral factors. Languages differ in what information is
marked morphologically, and in number of agree-
ment relationships. Annotation schemes vary in
what morphological information they encode, and in
how relevant that information is to agreement. Some
morphologically complex languages have rigid word
order, leading to better performance with no mor-
phological features at all, and limiting the amount
of improvement that is possible. Finally, it is pos-
sible that a stronger correlation is obscured by other
effects due to feature set design, as we will find later.
4.2 Performance vs. dataset size
Figures 2 presents unlabeled accuracy when parsing
Czech with the orig and agr configurations. Im-
provement with agr is roughly uniform across all
dataset sizes; this was the general trend for all tree-
banks. This is somewhat unexpected; we had pre-
dicted that the agreement features would be more
helpful at smaller dataset sizes.
320
no-morph orig agr agr+orig
Lang. UAC time feats UAC ?time ?feats UAC ?time ?feats UAC ?time ?feats
hin 90.0 1.4k 1.6m 92.0 116% 893% 93.8 50% 1% 93.0 144% 893%
hun 87.9 4.6k 5.3m 88.7 201% 687% 90.3 10% 0% 89.9 159% 687%
ces 80.9 3.3k 4.8m 81.6 71% 454% 85.5 27% 0% 84.5 114% 454%
tam 79.0 0.1k 0.5m 79.7 237% 329% 82.1 64% 1% 81.1 279% 330%
slv 80.8 0.8k 1.0m 80.4 103% 352% 81.9 21% 1% 80.8 129% 353%
dan 87.7 2.0k 1.6m 88.4 71% 256% 89.3 24% 0% 89.3 86% 256%
lat 61.7 1.8k 1.6m 65.0 54% 306% 70.3 91% 0% 68.6 119% 306%
nld 88.2 2.0k 3.6m 89.0 83% 270% 90.5 16% 0% 90.3 98% 270%
eus 78.7 0.7k 1.7m 80.2 80% 229% 82.3 10% 0% 82.3 78% 230%
bul 89.9 1.7k 2.6m 90.1 60% 221% 93.0 14% 0% 92.5 54% 222%
grc 74.9 8.6k 3.8m 76.9 36% 314% 80.7 45% 0% 79.5 70% 314%
deu 90.0 0.9k 1.3m 90.8 33% 189% 92.0 1% 0% 91.7 50% 186%
fin 73.3 0.7k 2.4m 76.3 74% 244% 79.1 23% 1% 78.7 84% 245%
tur 80.2 1.2k 2.1m 81.5 13% 178% 81.6 ?2% 0% 81.7 29% 178%
cat 81.8 3.0k 2.5m 81.9 2% 142% 84.9 -9% 0% 84.0 ?2% 143%
ara 78.0 3.2k 2.0m 78.1 65% 94% 78.9 23% 0% 78.7 20% 94%
ita 88.3 4.2k 1.8m 88.9 ?3% 59% 90.2 9% 0% 90.3 6% 59%
por 88.1 6.4k 5.0m 88.1 18% 46% 89.0 ?3% 0% 88.9 27% 46%
heb 87.4 4.3k 3.1m 87.4 ?18% 31% 89.2 ?16% 0% 89.1 ?5% 31%
eng 88.1 5.2k 3.1m 88.0 5% 7% 90.6 3% 0% 90.6 ?9% 8%
cmn 82.4 7.5k 6.0m 82.4 37% 0% 82.4 16% 0% 82.4 23% 0%
Table 6: Unlabeled accuracy, run time in seconds, and number of features for all treebanks and feature configurations.
Run time and number of features for orig, agr, and agr+orig are given as percent change relative to no-morph
4.3 Gold vs. automatic tags
The Hebrew treebank includes both automatically
generated and gold standard POS and morphological
annotations. In order to test how sensitive the agree-
ment features are to automatically predicted mor-
phological information, tests were run on both ver-
sions at the reference size. These results are not di-
rectly comparable to those of Goldberg and Elhadad
(2009), because of the parser modifications, POS tag
normalization, and cross-validation described ear-
lier. Comparing results qualitatively, we find less
sensitivity to the automatic tags overall, and that the
orig features improve accuracy even when using
automatic tags.
Results appear in Table 7. Using the automatic
data affects all feature sets negatively by 2.1% to
2.9%. Since the no-morph parser was affected the
most, it appears that this decrease is due largely
to errors in the POS tags, rather than the morpho-
logical annotations. The orig features compensate
for this slightly (0.2%), and the agr features more
(0.8%); this indicates that including even automatic
morphological information can compensate for in-
correct POS tags, and that the agr feature configu-
ration is the most robust when given predicted tags.
Feature
configuration
Acc. on
gold data
Acc. on
auto data
Difference
no-morph 87.4 84.5 ?2.9
orig 87.4 84.7 ?2.7
agr 89.3 87.2 ?2.1
agr+orig 89.1 86.9 ?2.2
Table 7: Unlabeled accuracy on Hebrew dataset, with
gold and automatic POS and morphological annotations
4.4 PPL feature
Examining the feature weights from the first cross-
validation fold when running the agr feature config-
uration on the Czech dataset indicated that 323 of the
1,000 highest-weighted features are agreement fea-
tures. Of these, 79 are symmetric (?agrees? or ?dis-
agrees?) agr features, and 244 asymmetric. This
was unexpected, as the symmetric features would
seem to be more useful, and it suggested that the la-
beled asymmetric agr features might be important
for reasons other than their modeling of morpholog-
ical information. Careful analysis of the MSTParser
feature set revealed that it does not include a fea-
ture which incorporates head POS, dependent POS,
and dependency label. We hypothesized that the la-
beled asymmetric agr features were highly ranked
321
Figure 1: Error reduction relative to no-morph vs. language
Figure 2: Unlabeled accuracy vs. num. sentences, Czech
because they capture these three arc features, not be-
cause they include with morphological information.
To test this, we added a single feature template
to MSTParser which encapsulates head POS, de-
pendent POS, and dependency label (the POS-POS-
label, or PPL, feature). Running a subsequent ex-
periment on the Czech data and looking at feature
weights from the same cross-validation fold, 278 of
the 1,000 highest-weighted features were PPL fea-
tures, and 187 were asymmetric agr features. This
indicated that the improvement seen with agr fea-
tures was indeed due partly to their inclusion of fea-
tures combining label and head and dependent POS.
All feature configurations were run on all tree-
banks with the PPL feature included; results appear
in Table 8. Performance increases from orig to
agr are generally smaller, with a maximum of 4.6%
absolute. This is seen especially on languages with
less morphological information, such as English and
Hebrew; this indicates that for those languages, most
of the previous improvement was due not to agree-
ment modeling, but to the PPL effect.
Calculating Pearson?s r between morphological
features per token and the new error reduction data
gives a stronger correlation coefficient of 0.748 for
agr, with p < 0.01, demonstrating that improve-
ment due solely to agreement modeling correlates
strongly with quantity of morphological informa-
tion. The earlier error reduction data were likely
polluted by improvement due to capturing the PPL
information. Correlation for the other feature con-
figurations is still moderate (0.506 with p < 0.02
for orig and 0.621 with p < 0.01 for agr+orig).
5 Future work
In future work, we plan to experiment with more
careful normalization of treebanks. For instance,
if an adjective can agree with either a masculine
or a feminine noun, annotating it with both gen=M
322
no-morph orig agr agr+orig
Lang. UAC time feats UAC ?time ?feats UAC ?time ?feats UAC ?time ?feats
hin 90.0 1.4k 1.6 92.0 116% 893% 93.8 50% 1% 93.0 144% 893%
hun 87.9 4.6k 5.3 88.7 201% 687% 90.3 10% 0% 89.9 159% 687%
ces 80.9 3.3k 4.8 81.6 71% 454% 85.5 27% 0% 84.5 114% 454%
tam 79.0 0.1k 0.5 79.7 237% 329% 82.1 64% 1% 81.1 279% 330%
slv 80.8 0.8k 1.0 80.4 102% 352% 81.8 21% 0% 80.8 129% 353%
dan 87.8 2.0k 1.6 88.4 71% 256% 89.3 24% 0% 89.3 86% 256%
lat 61.7 1.8k 1.6 65.0 54% 306% 70.3 91% 0% 68.6 119% 306%
nld 88.2 2.0k 3.6 89.0 83% 270% 90.5 16% 0% 90.3 98% 270%
eus 78.7 0.7k 1.7 80.2 80% 229% 82.3 10% 0% 82.3 78% 230%
bul 89.9 1.7k 2.6 90.2 60% 221% 93.0 14% 0% 92.5 54% 222%
grc 74.9 8.6k 3.8 77.0 36% 314% 80.7 45% 0% 79.5 70% 314%
deu 90.0 0.9k 1.3 90.8 33% 189% 92.0 1% 0% 91.7 50% 186%
fin 73.3 0.7k 2.4 76.3 74% 244% 79.1 23% 0% 78.7 84% 245%
tur 80.2 1.2k 2.1 81.5 13% 178% 81.6 -2% 0% 81.7 29% 178%
cat 81.8 3.0k 2.5 81.9 1% 142% 84.9 -9% 0% 84.0 -2% 143%
ara 77.6 5.4k 1.8 77.7 20% 100% 78.2 -8% 0% 78.0 4% 100%
ita 88.4 4.2k 1.8 88.9 -2% 59% 90.2 9% 0% 90.3 6% 59%
por 88.1 6.4k 5.0 88.2 18% 46% 89.0 -3% 0% 88.9 27% 46%
heb 87.4 4.3k 3.1 87.4 -18% 31% 89.2 -16% 0% 89.1 -5% 31%
eng 88.1 5.2k 3.1 88.0 5% 7% 90.6 3% 0% 90.6 -9% 7%
cmn 82.4 7.5k 6.0 82.4 37% 0% 82.4 16% 0% 82.4 23% 0%
Table 8: Unlabeled accuracy, run time in seconds, and number of features with PPL feature included. Run time and
number of features for orig, agr, and agr+orig are given as percent change relative to no-morph.
and gen=F (rather than gen=X) would ensure that
agreement with a noun of either gender would be
captured by our features. Furthermore, we may ex-
periment with filtering morphological information
based on part-of-speech, on attribute, or on whether
the attribute participates in any agreement relation-
ships. We also intend to perform feature selection on
the original feature set, and investigate the impor-
tance of labeled morphological features, which are
included in agr but not in orig. Finally, we plan to
develop metrics to measure the degree of word or-
der flexibility in a treebank, in order to explore the
extent to which it correlates with the degree of im-
provement achieved by our system.
6 Conclusions
We developed a simple, language-independent
model of agreement to better leverage morphologi-
cal data in dependency parsing. Testing on treebanks
containing varying amounts of morphological infor-
mation resulted in substantial improvements in pars-
ing accuracy while reducing feature counts and run
times significantly. Although originally intended to
compensate for lower accuracy on morphologically
rich languages, the model improved performance on
all treebanks with any morphological information.
We acknowledge that because our model was
tested on treebanks which differ widely in annota-
tion guidelines, variables such as the amount of mor-
phological information included and the treatment
of non-projective parses and coordination could af-
fect parsing performance. We did not delve into
these factors. However, we believe this is part of the
strength of the approach: we were able to achieve
performance gains without any detailed knowledge
of the languages and treebanks used.
We hope these results will encourage similarly
linguistically motivated design in future systems.
This case study provides strong evidence that in-
corporating linguistic knowledge into NLP systems
does not preclude language independence, and in-
deed may enhance it, by leveling performance across
typologically differing languages.
Acknowledgments
We would like to thank everyone who assisted us in
gathering treebanks, particularly Maite Oronoz and
her colleagues at the University of the Basque Coun-
try and Yoav Goldberg, as well as three anonymous
reviewers for their comments.
323
References
