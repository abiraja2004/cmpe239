Reversible Unification Based Machm. Franslatlon 
Gertjan van Noord 
OTS RUU Trans 10 
3,512 JK Utrecht 
Valmoord~hutruu59.BH~net 
March 28, 1990 
Abstract 
\[n this paper it will be shown how unification grammars 
can be used to build a reversible machine translation 
system. 
Unification grammars are often used to define the re- 
lation between strings and meaning representations in 
a declarative way. Such grammars are sometimes used 
in a bidirecLional way, thus the same grammar is used 
for both parsing and generation, in this paper 1 will 
show how ~.o use bidirectional unification grammars to 
dethle reversible relations between language dependent 
meaning representations. Furthermore it is shown how 
to obtain a completely reversible MT system using a 
series of (bidirectional) unification grammars. 
l Introduction 
The notion of a rew:rsible MT system was first ex- 
pressed by Landsbergen \[11\]. Such a system will in 
principle produce a set of possible translations, by em- 
ploying linguistic knowledge only. Choosing the best 
iranslation from the set. of linguistically possible trans- 
lations will rsually require other sources of knowledge, 
either incorporated in the systenl or provided (interac- 
tively) by the. user. The relation 'possible translation' is
symmetric whereas the relation 'best translation' is not. 
Thus an MT system may consist of a reversible core, 
implementi~:g the symmetric relation ~possible transla- 
tion', and additional components (not necessarily re- 
versible) to select tile best translation. 
Not only is it pos.siblc to build reversible (modules of) 
MT systems; it has also been claimed that reversible 
systems are preferable. For example Isabelle \[6\] clahns 
that reversible MT systems are to be preferred to oth- 
(:rs be(:~nlse in reversible MT systems a better under- 
standing of the translation re.lation is achieved; such 
systems will eventually exhibit better practicM perfor- 
mance. Moreover, the arguments in favour of using 
bidirectional grammars in NL1 ), such as those given in 
\[1, 8\] carry over to translation as well. 
Because o\[ tile declarative nature of unification- and 
logic grammar formMisms grammars written in these 
formalisms are increasingly used in a bidirectional way, 
thus the sa.me grammar is used for both parsing and 
generation. Some recent developments are reported in 
\[3, 24, 16, 21, 2, 18, 19, 22, 20\]. 
In this paper I will show how to use such bidirec- 
tional unification grammars to build a completely re- 
versible, multi l ingual, MT system. For each language 
there is a unification grammar that defines a reversible 
relation between strings and language dependent lnean- 
ing representations (logical forms ). Moreover, for each 
language pair (or set of languages) there is a unifica- 
tion grammar that defines a reversible relation between 
such language dependent logicM forms. Translation is 
thus detined by a series of three unification granrmars. 
A specific version of the system that is described 
here is implemented as the (:ore of the experiments! 
MiMo2 translation system \[23\]. This system aims at 
translating international news items on fe lctext .  Apart 
from unification grammars the system rises a bidirec- 
tional two-level orthography component.  Langu age de.- 
pendent meanings are represented as simple predicate 
argument structures with some extra labels indicating 
'universal'  meaning such as tense and aspect. The cur.- 
rent system (November 1989) includes grammars for 
Dutch, Spanish and English. 
The paper is set up as follows. In section 2, I will 
give some examples that show how bidirectional uni- 
tication grammars can be used t.o define relation~ be  
tween logical forms of diiferent languages. In section 3, 
reversibility is detined in terms of symmetry and con> 
patability. Possible approaches to obtedu reversibility 
are discussed. In section 4, I wilt compare the current 
approach with some other approaches in tile unification 
based translation paradigm and discuss some problems 
and future directions. 
2 Unif ication-based Transfer 
in this section 1 wilt give some exan@les of the use of 
a unification grammar (in PATR II \[17\] notation) to 
define the relation between language dependent logi- 
cal forms. For i l lustrative purposes I will assume log- 
ical fl)rms are represented by feature structures con- 
sisting of the attr ibutes pred, ar.ql, art2 together with 
some attribu tes representing 'universM' meanings uch 
as tense, aspect, munber and person; I will not touch 
upon issues such a~s quantif ication and modification. 
The logical forlns of English and Spanish are labeled by 
the attr ibutes 9 b and sp respectively. As an example 
299 
the logical form of 'The army opened fire at the civil- 
ians' is represented as in figure 1. Such feature struc- 
Figure 1: An example of a logical form 
gb = 
pred = open_fire_at 
?~ult tber  : .  sg  
\ [wed=c iv i l i an \ ]  
arg2 = number -- pl 
tures will often be related ill a straightforward way to 
a Spanish equivalent., except for the value of the prod 
attributes. A very simple rule in PATR II style may 
look as in figure 2. This rule simply states that the 
Figure 2: A simple rule 
0 - -+123 
(0 gb pred) = (1 gb) 
(0 gb argl) = (2 gb) 
(0 gb arg2> = (3 gb) 
(0 sp pred) = <1 sp) 
(0 sp  gl) = (2 sp> 
(0 sp arg2) = (3 sp) 
translation of a logical form is composed of the transla- 
tion of its arguments. If the rule applies to the feature 
structure in 1 tile three daughters of the rule will be 
instantiated as in figure 3, and the value of sp will be 
bound to the sp values of these daughters. An example 
Figure 3: Three instantiat ions 
\[ gb = open_fire_at \] 
\[ 1 gb = namber = pl 
'~umber  ~- sg  
of the rule for the first daughter will be a lexical entry 
and looks as iu figure 4. The simple English expression 
'army' has to be translated as a complex expression i  
Spanish: 'Nerza militar'. The rule will look a.s in 5 
where it is assumed that the construction is analyzed 
in Spanish as an ordinary noun-adjective construction, 
and where the logical form of the adjective takes the 
logical form of the noun as its argument. The transla- 
tion for 'civilian' is defined in a similar rule (although 
the translation of 'number' is different). Note that this 
example of complex transfer is similar to the famous 
'schimmel - grey horse' cases. As a result of the rule 
Figure 4: A lexical entry 
0 --~ 
<0 gb) = open_fire_at 
(0 sp> = romper_el_fuego_a 
Figure 5: A rule for 'fuerza rnil itar' 
0 ---~ 
(0 gb pred) = ,army 
(0 ap pred pred) = mi l i ta r  
(0 sp argl  pred) = fuerza 
(0 sp argl  nmnber) = (0 gb number} 
applications the feature structure in figure 1 will get 
instantiated to tile feature structure in 6, from which 
the generator generates the strir~g 'La fllerza militar 
rompio el fuego a la poblacion civil'. 
Figure 6: The feature structure after transfer 
9b = 
sp 
pred  = open_ f i re_at  
\[ p red  . . . . . . .  y \ ]  
a rg l  :-x n.ur~zbe,  = s 9 
pred  = c iv i l i an  
arg2 =: t~umber  ---- pl 
p red  = romper_e l _ fuego_a  
ar 9 1 = 
at92  = 
\] 
ar91 pred = \ ]uerza  
,zttrllbev ~. sff 
p red  = poblacioI~ 
at9!  L ,;.,arnber = s 9 
In the foregoing examples the relation between Iogi- 
car forms is rather straightforward. Note however that 
tile full power of a unification grammar can be used to 
settle more difficult translation cases, because differellt 
attributes can be used to represent the 'translational 
syntax'. For instance we can build a tree as value of 
the attribute tree to represetlt tile derivational history 
of the translation process. Or we can %hread'informa- 
tion through different nodes to be able to make transla- 
tions dependent on each other. Translation parameters 
such as style and subject field can be percolated as at- 
tributes of nodes to obtain consistent translations; but 
these attributes themselves need not be translated. 
3 Revers ib le  Un i t i ca t ion  
Grammars  
A unification grammar defined in formalisms uch as 
PATR II and 1)CG \[12\] usually defines a relation be- 
tween a string of words and a logical form. In sign- 
based approaches such as UCG \[26\] and flPSG \[14\] this 
string of words is not assigned a privileged status but 
is the value of one of the attributes of a feature struc- 
ture. I will assume a formalism similar to PATR II, 
300 
but without the context-free ba~e; the string is repre- 
sented as the value of one of the attributes of a feature 
structure. Thus more generally, unification grammars 
define relations between the values of two (or more 1) 
attributes - for example the relation between the value 
of the attributes string and If, or between the value of 
the attributes sp and gb; these relations are all relations 
between feature structures. 
3.1 \]Reversibility 
I will call a binary relation reversible if the relation is 
symmetric and computable. Both symmetry and com- 
putability will be explained in the following subsec- 
tions. A grammar G is reversible for a relation R iff R 
is reversible and defined by G. For example, a grammar 
that relates trings to logical forms is reversible if both 
the parsing and generation problem is computable, and 
the relation between strings and logical forms is sym- 
metric; the parsing problem is computable if for a given 
string all corresponding logical forms can be enumer- 
ated by some terminating procedure; such a procedure 
should halt if the given string does not have a corre- 
sponding logical form. Thus: reversible -- symmetric +
computable. Note that reversibility as defined here is 
different from bidirectionality. The latter merely says 
that grammars are to be used in two directions, but 
does not state how the two directions relate. 
It is easy to see that a composition of reversible re- 
lations is a a reversible relation too; i.e. if some fea- 
ture structure fl is related to some feature structure 
f~ via the reversible relations .Ri(fi,fi+l), each de- 
fined by some reversible grammar Gi, then R'(f l ,  fn) 
is reversible. Thus an MT system that defines a rela- 
tion R(,%, st) via the relations t~ ( s~, 5), Ry ( l~, lt ) and 
Ra(lt, st) is reversible if R1,2,3 are reversible. 
3.1.1 Symmetry  
A relation R C A x B is symmetric iff R(a, b) implies 
R(b, a ~) where a and a' are equivalent. For an MT sys- 
tem we want to define 'equivalence' in such a way that 
the translation relation is a symmetric relation between 
strings, ttowever, strings are feature structures thus wc 
must define equivalence for feature structures to obtain 
this effect. 
Unification grammars as they are commonly used 
implement a rather weak notion of equivalence between 
feature structures: feature structures a and b are equiv- 
Ment if they ca~ ~if>.: 
Def in i t ion I (Weak equivalence)  
Two feature structures fl, f2 are weakly equivalent iff 
fl U f2 exists. 
if feature structures are taken to stand for all their 
grouml iustances this yields an acceptable version 
of sym ;~e.try. Moreover, under the assumption that 
1 Note that it is possible to define a unification gra~nmar 
that relates everal language dependent logical forms; in this 
approach a multilingual transfer system consists of only one 
transfer gramm,'m 
feature structures which represent strings are always 
ground (i.e. these feature structures cannot be ex- 
tended), this results in a symmetric relation between 
(feature structures that represent) strings. 
It is also possible to define a 'strong' notion of equiv- 
alence for feature structures that does not rely on this 
assumption. 
Def in i t ion 2 (St rong equivalence)  Two feature 
structures f l , f2 are strongly equivalent (fl =-- f2) iff 
/2 E A and A E f2. 
A grammar that defines a computable r lation between 
two attributes under the strong definition of equiva- 
lence might be cMled strongly reversible. Similarly a 
weakly reversible grammar is reversible under a weak 
definition of equivalence. Again these results can be 
generMized to a series of unification grammars. The 
strong version of equivalence can be motivated on the 
ground that it may be easier to obtain computability; 
this is the topic of the next subsection. In section 3.2 
I will discuss possible relaxations of the strong version 
of equivalence to obtain 'mildly' reversible grammars. 
3.1.2 Computab i l i ty  
A relation R C A x B is computable iff for a given 
a E A the set {b C B\]R(a,b)} can be enumerated by 
some terminating procedure. To discuss cornputabil- 
ity it is useful to look a bit more careful at the re- 
lations we are interested in. These relations are all 
binary relations between feature structures, ttowever, 
in tile case of the relation between strings and logical 
forms, strings will always be related to logical forms and 
logical forms will be related to strings. Similarly for 
the relation between l)utch and Spanish logical forms. 
Clearly, the domain and range of the relation is struc- 
tured and can be partioned into two sets A and \]3, 
\[or example the set of feature structures representing 
strings and the set of feature structures representing 
logical forms. The relation R C A U B x A U B can be 
partitioned similarly into the relations r C A x I\] and 
its inverse, r -~ C B x A. The problem to compute R 
is now replaced by two problems: the computation of
r and r -1. For example the problem to compute the 
relation between logical forms and strings consists of 
the parsing- and generation problem. It is now possi- 
ble to incorporate the notion of equivalence, to obtain 
a definition of a parser, generator and translator. For 
example, an Mgorithm that computes the foregoing re- 
lation r will enumerate for a given features tructure 
fl all feature strnctures fy, such that r(fa, fy) and f~ 
and f3 are equivalent. In the case of strong equivalence 
this implies that f l~  f3 (completeness), and fa U fl 
(coherence). In other words, the input should not be 
extended (coherence) and should completely be derived 
(completeness). This usage of the terms completeness 
and coherence was introduced in \[24\]. In the following 
I will discuss ways to obtain computability of one such 
partition. 
It is well known that relations defined by unrestricted 
unification grammars are not computable in general a~s 
301 
such grammars have Turing power \[13\]; it is thus not 
decidable whether the relation is defined for some given 
input. Usually some constraint on grammars i defined 
to remedy this. For example the off-line-parsability 
constraint \[13, 5\] ensures that the recognition problem 
is solvable. Moreover this constraint also implies that 
the parsing problem as defined here is computable; i.e. 
the proof procedure will always terminate (because the 
constraint implies that there is a limit to the depth of 
possible parse trees for all strings of a given length). 
llowever the off-line-parsability constraint assumes 
a context-free base of the formalism. A generalization 
of the off-line-parsability constraint for any binary re- 
lation defined by unification grammars will consist of 
three parts; the first and third of these parts are usually 
implicit in the case of parsing. 
Pirst, the value of the input must be built in a well- 
behaved compositional way. For example in the case of 
parsing: each daughter of a rule dominates part of the 
string dominated by the mother of that rule. Similarly 
for transfer and generation: each daughter of a rule 
has a value for I f  that is part of the value of If of the 
mother. 
Second, a special condition is defined for rules where 
the input vMue of the mother is the same as the in- 
put value of one of the daughters. \[:or parsing such 
rules have exactly one daughter. A chain of applica- 
tions of such rules is disallowed by some constraint or 
other; this is the core of most definitions of the off- 
line parsabilityoconstraint. For example in \[13\] such a 
chain is disMlowed as the principal functor of a term 
may only occur once in a chain. For a slightly more 
general definition, cf. \[5\]. For generation and transfer 
a similar constraint can be defined. In the terminology 
of \[18, 19\] the 'head' of a rule is a daughter with the 
same logical form as its mother. A chain of these heads 
must be disallowed. 
Third, the input should not get extended uring the 
proof procedure. In the case of parsing this is achieved 
eaMly because the input is ground 2. For generation 
and transfer this is not necessarily the case. This is the 
point where the usefulness of the coherence condition 
comes in; the coherence requirement explicitly states 
that extension of the input is not allowed. For this 
reason strong reversiblity may be easier to obtain than 
weak reversibility. In the next subsection I will discuss 
two relaxations of strong symmetry that will not affect 
the computability properties discussed here. 
Generalizing the terminology introduced by \[13\] a 
proof procedure is strongly stable iff it always termi- 
nates for grammars that adhere to a generalized off-line 
parsability constrMnt. In \[15\] a general proof procedure 
for DCG based on head-driven generation \[18, 19, 22\] 
is defined that is strongly stable for a specific instanti- 
ation of the generalized off-line parsability constraint. 
?'Note that this is the reason that most DCG parsers 
expect that the input value of the string has an atomic 
tail, i.e. parse(\[john, kisses,mary\], ~)will work fine, but 
parse(\[john, kisses, mary\]X\], X) will cause problenas. 
3 .2  Poss ib le  re laxat ions  
It is easy to see that the completeness and coherence 
requirenrents make life hard for the rulewriter as she/he 
needs to know exactly what the possible values of in- 
puts are for some component. It is possible to relax the 
completeness and coherence requirement in two ways 
that will not affect the reversibility properties between 
strings. The useflfiness of these relaxations depends on 
the analyses a user wishes to define. 
3.2.1 Cyc l i c  and  non-cyc l i c  a t t r ibutes  
The first relaxation assumes that there is a sort sys- 
tem defined for feature structures that makes it pos- 
sible to make a distinction between cyclic and non- 
cyclic attributes (cf. \[5\]). For the moment a non- 
cyclic attribute may be defined a.s an attribute with 
a finite number of possible values (i.e. it is not recur- 
sive). For example the attributes argl and arg2 will 
be cyclic whereas number will be non-cyclic. The com- 
pleteness and coherence condition is restricted to cyclic 
attributes. As the proof procedure can only further in- 
stantiate non-cyclic attributes no termination problems 
occur because there are only a finite number of possi- 
bilities to do this. The definition of 'equivalence' for 
feature structures is now slightly changed. \[\[b define 
this properly it is necessary to define the notion non- 
cyclic extension. A non-cyclic extension of a feature 
structure only instantiates non-cyclic attributes. This 
results in the following definition of equivalence: 
Def in i t ion 3 (Non-cycl ic  equ iva lent )  Two feature 
structures f:, f2 are non.cyclic equivalent iff f~ _=__ f~ 
where f~ are non-cyclic extensions of f,~. 
It will be clear that the usefulness of this definition 
depends heavily on the style of grammar writing that 
is used. Note that it is of course also possible to declare 
for each non-cyclic attribute whether the completeness 
and coherence requirements hold. 
3.2.2 Reent ranc les  
The second relaxation is not without ramifications for 
the organization of a transfer grammar. Tlfis relax- 
ation has to do with reentrancies in feature structures. 
Some constructions such as control verbs and relative 
clauses may be represented using reentrancies; for ex- 
ample 'the soldiers tried to shoot the president' may 
be represented by a feature structure where the first 
argument of 'try' is reentrant with the first argument 
of 'shoot', cf. figure 7. The translation of such logical 
forms to Dutch equivalents can be defined as in rule 8. 
In this rule the reentrancy is explicitly mentioned for 
two reasons. The first reason is simply that in the 
case of different possible translations of ar91 we want 
the same translation for both argl and the embedded 
argl. Note that the translation of 'soldier' into Dutch 
can be both 'soldaat' or 'militair'. If the reentrancy is
not mentioned the system has to try to generate from 
four different Dutch logical forms, two of which without 
matching argl's. 
302 
Figure 7: A logical form containing reentrancy 
gb= 
pred = try 
argl = \[\] \[ pred = soldier 
number = pl \] 
ar.q2 = argl = \[\] pred = president 
arg2 = nu'mber = sg 
Figure 8: Translat ing subject control 
0 - - .123  
(0 gb pred) = (1 gb) 
<0 nl pred} = <~ ~p> 
(0 n l  argl) = (0 nl arg2 argl) 
<o gb ~rg1> = <2 gb) 
(0 nl ~rg1> = <2 ~p> 
<0 gb arg2} = (3 gb> 
<o n:L ~g2} = <3 ~p> 
The reentrancy is also mentioned because this is re- 
quired by the completeness condition. It is possible to 
relax the completeness and coherence condition with 
respect to these reentrancies, again without directing 
the reversibility properties of the system by slightly 
changing the definition of equiva\]ence. There is a trade- 
off between simplicity of the transfer grammar (in the 
presence of this relaxation) and the efficiency of the 
system. In the case of this relaxation the system will 
eventually lind the good translations, but it may take a 
while. On the other hand, if we are to mention all (pos- 
sibly unbounded) reentrancies xplicitly then the trans- 
fer grammar will have to be complicated by a threading 
mechanism to derive such reen trancies. Again, the spe- 
cific use o:\[ reentrancies in the logical forms that are de- 
fined will deterlnine whether this relaxation is desired 
or not. 
4 F ina l  remarks  
The objective to build a reversible MT system using 
a series of unification grammars is similar to the ob- 
jective of the CRITTER system as expressed in \[3, 7\], 
and the work of Zajac in \[25\]. Instead of using unifica- 
tion grammars CRITTER uses logic grammars; Zajac 
uses a type system including an inheritance mechanism 
to define transfer-like rules. In these two approaches 
less attention is being paid to an exact definition of re- 
versibility; although our work may be compatible with 
these approaches. 
A somewhat different approach is advocated in \[9\]. 
In that approach a system is described where an I, FG 
grammar for some source language is augnlented with 
equations that define (part of) the target level repre- 
sentations. A generator derives from this partial de- 
scription a string according to some LFG grammar of 
the target language. Instead of a series of three gram- 
mars this architecture thus assumes two grammars, one 
of which both defines the source language and the rela- 
tion with the target language. The translation relation 
is not only defined between logical forms but may relate 
~ll levels of representation ( c.structure, f-structure, 
a-structure). Although in this approach monolingual 
grammars may be used in a bidirectional way it is un- 
clear whether the translation equations can be used 
bidirectionally 3 
An important problem for the approach advocated 
here is the problem of logical form equivalence. Shieber 
\[16\] noted that unification grammars usually define 
a relation between strings and some canonical ogical 
form. Depending on the nature of logical forms that 
are being used, severM representations of a logical form 
may have the same 'meaning'; just as in first order 
predicate calculus the formulas p v q and q v p are logi- 
cally equivalent; a unification grammar will not know of 
these equivalences and, consequently, all equivalences 
have to be defined separately (if such equivalents are 
thought of as being translational equiwdents); for ex- 
ample in a transfer grammar two rules may be defined 
to translate p V q into both p' V q' and q' V p' if these 
formulas arc thought of ,~ being equivalent. Of course 
this technique can only be applied if the number of 
equivalences is finite, it is not possible to define that p 
is equivalent with . . . . .  p for any even number of --'s. 
The approach discussed so far can be extended just 
as unification grammars for parsing and generation 
have been extended. Apart from equationM constraints 
it will be useful to add others such as disjunction and 
negation. Moreover it seems useful to allow some ver- 
sion of universal constraints or some inheritance mech- 
anisrn to be able to express generalizations and excep- 
tions more easily. 
Acknowledgements  
I want to thank Joke Dorrepaal, Pim van der Eijk, 
Maria Florenza, Dirk Iteylen, Steven Krauwer, Jan 
Landsbergen, Michael Moortgat, IIerbert Ruessink and 
Louis des Tornbe. I was supported by the Euro- 
pean Community and the NBBI through the Eurotra 
project. 
References  
\[1\] Douglas E. Appelt. Bidirectional gr~nmars and the 
design of natm'al language generation systems. In The- 
oretical Issues in Natural Language Processing 3, 1987. 
\[2\] Jonathaal Calder, Mike Rcape, and tlenk Zeevat. An 
algorittma for generation i unification catcgorial gram- 
mar. In Fourth Con.ference of the European Chapter of 
the Association for Computational Linguistics, 1989. 
\[3\] Marc Dymetman ~ld PielTe Isabellc. Reversible logic 
grannnars for machine translation. In Proceedings of 
the Second International Conference on Theoretical 
3Although parsing of LFG's is decidable no such result 
is available for generation; ote furthermore that according 
to \[9\] extension is Mlowed dm'ing generation. 
303  
and Methodological issues in Machine Translation of 
Natural Languages, 1988. 
\[4\] Barbara Qrosz, Karen Sparek Jones, and Bonny Lynn 
Webber, editors. Readings in Natural Language Pro- 
cessing. Morgan Kaufinann, 1986. 
\[5\] Andrew Haas. A generalization of the offline parsable 
grammars. In '27th Annual Meeting oJ the Association 
for Computational Linguislies, 1989. 
\[6\] Pien'e Isabelle. Towards reversible MT systems. In MT 
Summit \]I, 1989. 
\[7\] Pien'e Isabelle, Marc Dymetman, and Elliott Macldo- 
vitch. CRITTER: a translation system for a~'ieulturM 
market reports. In Proceedings o/ the 12th Interna- 
tional Conference on Computational Linguistics, Bu- 
dapest, 1988. 
\[8\] Paul S. Jacobs. Achieving bidirection'Mity. In Proceed- 
ings o\] the 12th International Conference on Compu- 
tational Linguistics, 1988. 
\[9\] Ronald Kaplan, Klaus Netter, Jiirgen Wedekind, and 
Annie Zaenen. Translation by structural correspon- 
dences. In Fourth Conference o\] the European Chap- 
ter of the Association for Computational Linguistics, 
1989. 
\[10\] Margaret King, editor. Machine Translation, the State 
o\] the .4 ft. Edinburgh University Press, 1987. 
\[11\] Jan Landsbergen. Isomorphic grammars and their use 
in the Rosetta translation system, 1984. paper pre- 
sented at the tutorial on Machine Translation, Lugano 
t984, Also appears in \[10\]. 
\[12\] Femando C.N, Pereira and David WaITen. Definite 
clause grammars for language analysis - a survey of the 
formMism and a comparison with augmented transition 
networks. Artificial Intelligence, 13, 1980. reprinted in 
114\]. 
\[13\] Femando C.N. Pereira and David Wan'ca. Parsing as 
deduction. In 21st Annual Meeting of the Association 
/or Computational Linguistics, 1983. 
\[14\] Carl Pollard and Ivan Sag. In.formation Based Syntax 
and Semantics. Center for the Study of Langalage and 
Information Stanford, 1987. 
\[15\] Herbert Ruessink attd Gertjan van Noord, Remarks on 
the bottom-up generation Mgorithm. Technical report, 
Department of Linguistics, OTS RUU Utrecht, 1989. 
\[16\] Stuart M. Stfieber. A mfiform architecture for parsing 
and generation. In Proceedings o/ the 12th Interna- 
tional Conference on Computational Linguistics, 1988. 
\[17\] Stuart M. SIfieber, Hans Uszkoreit, Fernando C.N. 
Pereira, J. Robinson, and M. Tyson. Tile formalism 
and implementation of PATR-II. In B. J. Grosz and 
M. E. Stickel, editors, Research on Interactive Acqui- 
sition and Use o\] Knowledge. SRI report, 1983. 
\[18\] Stuart M. Shieber, Gertjan van Noord, Robert C. 
Moore, and Fernando C.N. Pereira. A semantic-head- 
driven generation Mgorithm for unification based for- 
mMisms. In 27th Annual Meeting of the Association 
.for Computational Linguistics, 1989. 
\[19\] Stuart M. Shieber, Gertjan van Noord, Robert C. 
Moore, and Fernando C.N. Pereira. Semantic-head- 
driven generation. Computational Linguistics, 1990. 
To appear. 
\[20\] Tomek Strzalkowsld. Automated inversiot) of a unifica- 
tion parser into a unification generator. Technical re- 
port, Courant Institute of Mathematical Sciences, New 
York University, 1989. technical report 465. 
\[21\] Gertjau van Noord. BUG: A directed lmttom-up gen- 
erator for unification ba~sed fonnMisms. Working Pa- 
persia Natural Language Processing, Katholieke Uni- 
versiteit Leuven, Stichting Taaltechnologie Utrecht, 4, 
1989. 
\[22\] Gertjan van Noord. An overview of head-driven 
bottom-up generation. In Robert Dale, Chris Mellish, 
and Michael Zock, editors, Current Research in Natu- 
ral Language Generation. 1990. 
\[23\] Gertjan vail Noord, Joke DorrepaM, Louis des Tombe, 
and Pim van der Eijk. The MiMo2 research system. 
OTS RUU Utrecht. 
\[24\] Jiirgen Wedekind. Generation as structure driven 
derivation. In Proceedings o/ the 12th International 
Conference on Computational Linguistics, 1988. 
\[25\] Rdmi Zajac. A transfer model using a typed feature 
structure rewriting system with inheritcnce, In 27th 
Annual Meeting of the Association for Computational 
Linguistics, 1989. 
\[26\] \[leak Zeevat, Ewau Klein, and Jo Calder. Unification 
categorial grammar. In Nicholas tIaddock, Ewan Klein, 
and Glyn Morrill, editors, Categorial Grammar, Uni- 
fication Grammar and Parsing. Centre for Cognitive 
Science, 1987. Volume 1 of Working Papel.'s in Cogni- 
tive Science. 
304 
