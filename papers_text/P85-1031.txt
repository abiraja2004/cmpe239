AN ECLECTIC APPROACH TO 
BUILDING NATURAL LANGUAGE INTERFACES 
Brian Phillips. Michael J. Freiling, James H. Alexander, 
Steven L. M essick, Steve Rehfu~, Sheldon N ichollt 
Tektronix, Inc. 
P.O. Box 500, M/S 50-662 
Beavertoa, OR 97077 
ABSTRACT 
INKA is a natural language interface to facilitate 
knowledge acquisition during expert system development for 
electronic instrument rouble-thooting. The expert system 
design methodology develops a domain definition, called 
GLIB, in the form of a semantic grammar. This grammar for- 
mat enables GLIB to be used with the INGLISH interface, 
which constrains users to create statements within a subset of 
English. Incremental patting in INGLISH allows immediate 
remedial information to be generated if a user deviates from 
the sublanguage. Sentences are translated into production rules 
using the methodology of lexical-functional grammar. The sys- 
tem is written in Sms/ltalk and, in INK,A, produces rides for a 
Prolog inference ngine. 
INTRODUCTION 
The ides/ natural anguage interface would let any user, 
without any prior training, interact with a computer. Such an 
interface would be useful in the knowledge acquisition phase 
of expert system development where the diagnostic knowledge 
of a Hilled practitioner has to be elicited. As technicians are 
not farnifiar with formal knowledge representation schemes, a
trained intermediary, a knowledge ngineer, is generally 
employed to handcraft he interns/ format. This process is 
time-consuming and expensive. 
INKA (INglish Knowledge Acquisition) permits task 
experts to express their knowledge in a subset of English, and 
have it automatically translated into the appropriate represen- 
tational formalism. In particular, the version of INKA to be 
discussed here accepts input in a sublanguage called GLIB 
which permits the statement of facts and rules relevant o the 
troubleshooting of electronic systems (Freiling et al, 1984), 
and translates these statements into Prolog unit clauses for later 
proce~ng by a specialized inference mechanism. Experiments 
with INKA to date have enabled us to construct mfflcient 
troubleshooting rules to build a localizing troubleshooter for a 
simple circuit. 
INKA is designed as one of the tools of DETEKTR, an 
environment for building knowledge based electronic instru. 
ment troubleshooters (Freiling & Alexander, 1984). 
DETEKTR supports an expert system development methodol- 
ogy which is outlined below. The design goal of INKA is that 
it serve as a natural anguage input system to facilitate transfer 
of knowledge during the knowledge acquisition phase of expert 
system development. IIqKA is not intended to stand alone as 
the sole mechanism for knowledge transfer, but to be sup- 
t A summer intern at Tektronix, currently at the Univer- 
sity of llfinois, Champs/gn-Urbana. 
ported by components capable of managing a coherent dis/o- 
gue with the task expert. McKeown (1984) has po/nted out a 
number of important aspec~ of the pragmatics that relate to 
the usage phase of an expert system. Similar pragmatics are 
required to insure adequate construction of the system's 
knowledge base during the knowledge ac~n phase of an 
expert system's development. The most important pragmatic 
facility is one to estimate the degree of epistemi? coverage of 
the knowledge acquired so far, and to prompt he task expert 
for more knowledge in areas where the coverage is weak. It is 
unfeasible to assume that any task expert can simply perform a 
~memory dump" of expertise into some natural language 
interface and be done with it. 
This paper discusses the natural anguage technology used 
in building INKA. The system incorporates a diverse collec- 
tion of natural language technologies in its construction. 
Specifically, INKA utilizes a semam/c grammar (Burton, 1976) 
to characterize the domain sublanguage, lexical-functional 
sem~aics (Kaplan & Bresnan, 1982) to translate to the internal 
form of representation, and an interface that includes left- 
corner parsitlg with in-line guidance to address the Linguistic 
coverage problem that aris~ with sublanguages. We feel this 
eclectic approach is a useful for building application-oriented 
natural language interfaces. Although we are describing a 
knowledge acquisition application, the methodology can be 
used for any application whose sublanguage can be stated in 
the prescribed grammar formalism. 
Tereisias (Davis, 1977) provides a natural language 
environment for debugging a knowledge base. INKA at 
present contains no facilities to modify an existing rule or to 
test the evolving knowledge base for some level of integr/ty; 
these are to be future additions. 
INKA is written in Smalltalk (Goidberg & Robson, 1983) 
and runs on both the Tekuroulx Magnolia Workstation and the 
4404 Artificial Intelligence System. INKA makes extensive 
use of the bit-mapped isplay and three-button mouse on these 
systems. 
LANGUAGE AS A KNOWLEDGE ENGINEERING TOOL 
The major bottlenecks in building knowledge based sys- 
tems have proven to be related to the definition and acquisi- 
tion of knowledge to be processed. 
The first bottleneck occurs in the knowledge definition 
phase of system development, where symbolic structures are 
defined that represent the knowledge necessary to accomplish 
a particular task. A bottleneck arises because of the ~ortage 
of knowledge ngineers, who are skilled in defining these struc- 
tures and using them to express relevant knowledge. 
254 
The second bottleneck occurs in the knowledge acquisition 
phase, which involves the codification of the knowledge neces- 
sary for a system to function correctly. A bottleneck arises 
here because in current practice, the presence of the 
knowledge engineer is required throughout this time- 
consuming process. 
In the course of defining a viable methodology for the 
construction of expert systems (Frelling & Alexander 1984; 
Alexander et al 1985), we have identified cermia classes of 
problems where the task of definin$ the knowledge structures 
and the task of actually building them can be effectively 
separated, with only the former being performed by a trained 
knowledge engineer. The problem of building a large collec- 
tion of knowledge-based troubleshooters for electronic instru- 
meats is an example. In order to support he construct/on of a 
large class of such systems, it makes sense to perform the 
knowledge definition step for the overall domain initially, and 
to build domain-specific developmera tools, which include 
problem-oriented mbsets of Enghsh and special purpose graph- 
ical displays, that can be reused in the development of each 
individual knowledge-based system. 
Even in the context of such an approach, we have found 
that there is usually a shortage of capable knowledge ngineers 
to carry out the knowledge deflnltioa phase, and that a well- 
defined methodology can be of great value here in aiding non- 
linguistically oriented computer scientists to carry out this ver- 
bal elicitation task. The major issue is how to gee started 
defining the forms into which knowledge is to be cast. 
We have found it an effect/ve technique tO begin this pro- 
cem by recording statements made by task experts on tape, and 
transcribing these to fairly natural En~)i~. When enough 
recording has been done, the statements begin to take on 
recognizable patterns. It is then pom/ble to build a formal 
grammar for much of the relevant utterances, using linguistic 
engineering techniques uch as semantic grammars The sym- 
bols of this grammar and the task specific vocabulary provide 
convenient points for defining formal sub-structures, which are 
pieced together to define a complete symbolic representation. 
Once the grammar is reasonably well-defined, the mapping to 
symbolic representation can be carried out with mapping tenh- 
niques such as the f-structure constraints of lexical-fuactioaal 
grammar. 
Up to this point, we can imagine that the entire task has 
been carried out on paper, or some machine-readable 
equivalent. Even in such a rudimentary form, the exercise is 
useful, because it provides a conveniently formal documenta- 
tion for the knowledge representation decisions that have been 
made. However, it is also the case that these formal defini- 
tions, if appropriately constructed, provide all that is necessary 
to construct a problem specific interface for acquiring utter- 
antes expressed in this sublanguage. In fact, the idea of using 
this technique to build acquisition interfaces, using INGLISH, 
actually occurred as a result of wondering what to do with a 
grammar we had constructed simply in order to document our 
representation structures (Freiling et al 1984). 
We do not intend to imply that it is possible in complex 
knowledge based system applications to simply build a gram. 
mar and immediately begin acquirin~ knowledge. Often the 
process leading to construction of the grammar can be quite 
complex. In our case, it even involved building a simple proto- 
type troubleshooting system before we had gained sufficient 
confidence in our representation structures to attempt a 
knowledge acquis/tion interface. 
Nor do we intend to claim that all the knowledge neces- 
sary to build a complete expert system need be computed in 
this fashion. Systems such as INKA can be justified on an 
economic bash if they make pom/ble only the transfer of a ~'~ 
nificam fraction of the relevant knowledge. 
GLIB  - A PROBLEM SPECHrIC SUBLANGUAGE 
The knowledge acquisition language developed for elec- 
tron/c devine troubleshooting is called GLIB (General 
Language for Insumneat Behavior), and is aimed primarily at 
describing observations of the static and dynamic behavior of 
electrical signals as measured with oscilloscopes, voltmeters, 
and other standard electronic test instruments (Freiling et al 
1984). The grammatical structure of GLIB is that of a seman- 
tic grammar, where non-terminal symbols represent units of 
interest to the problem domain rather than recognizable 
linguistic categories. 
This semantic grammar formalism is an important part of 
the DETEKTR methodology because the construction of 
semantic grammars is a technique that is easily learned by the 
apprentice knowledge engineer. It also ma~es possible the 
establishment of very strong constraints on the formal language 
developed by this process. Two of the design constraints we 
find it advisable to impose are that the language be unambigu- 
ous (in the formal sense of a unique derivation for each legal 
sentence) and that it be context-free. These constraints, as will 
be seen, make pom/ble features of the interface which cannot 
normally be delivered in other contexts, such as menus from 
which to select all legal next terminal tokens. While increasing 
complexity of the acquisition sublanguage may make these 
goals unfeas/ble past a certain point, in simple systems they are 
features to be cherished. 
Figure I shows a fragment of the GLIB grammar. In the 
DETEKTR version of INKA, sentences in this language are 
accepted, and mapped into Proiog terms for proceming by a 
Prolog based diagnostic inference ngine. At present, the eric/- 
ration is unguided: responsibility res/des with the user to ensure 
that all relevant statements are generated. We are still studying 
the issues involved ia determining completeness of a 
knowledge base and assimilating new knowledge. One out- 
come of these studies should be means of guiding the user to 
areas of the knowledge base that are incomplete and warrant 
further elaboration. Future enhancements o the system will 
include explanation and modification facilities, so that 
knowledge may be added or changed after testing the infer- 
ence engine. 
THE NATURAL LANGUAGE INTERFACE DESIGN 
INGLISH - INterface enGLISH (Ph/Ilips & Nicholl, 
1984) - allows a user to create sentences either by menu selec- 
tion, by typing, or by a mixture of the two. This allows the 
self-paced transition from menu-driven to a typed mode of 
interact/on. In-line help is available. To assist the v/pist, 
automatic spelling correction, word completion, and automatic 
phrase completion are provided. INGLISH constrains users to 
create statements within a subset of English, here GLIB. 
A statement can be entered as a sequence of menu- 
selections using only the mouse. A mouse-click brings up a 
menu of words and phrases that are valid extensions of the 
255 
<:rttl*'~> ::I= 
I F  <condit ion> THEN <?on?lmma> 
<condifiou> ::', 
<?otltl=n independeln predicate> I 
<context independent predicate> WHEN ~'-.m~-tund coatext> 
<conclusion> ::!, 
<fuectionaJ context> 
<atonfi? funct~nal context> ::- 
<device> HAS FAILED I 
<device> B OK 
< f ~  conner> ::1. 
<atomic functional context> ! 
<atomic functional context> AND <functional context> I 
<atomic functio~taJ context> OR <f,,r~tionaI context> 
<atOtUiC stt~tetugaJ contexL> ::~, 
<device> IS REMOVED 
~-JtfttCtttt~l COtlteXt> ::1= 
<atomi? structm'aJ context> I
<atomic structural context> AND <structural context> 
<context independent prostate> ::= 
<value predicate> 
<value predicatc> ::= 
<value xpre~on> IS <value xpreslion> I 
<value xpt~mou> <comparator> <value c~im:smon> 
<coml~tralOf> ::~ 
IS EQUAL TO I = I 
IS GREATER THAN I > I 
IS LESS THAN I < ! 
IS LESS THAN OR EQUAL TO I <= I 
IS GREATER THAN OR EQUAL TO I >-  I 
IS NOT EQUAL TO I !:, 
Figure 1: A fragment of GLIB 
current sentence fragment. Once a selection is made from the 
menu using the mouse, the fragment is extended. This 
sequence can be repeated until the sentence is completed. 
Creating a sentence in this manner compares with the 
NLMENU system (Tennant e ta l . ,  1983). Unlike NLMENU,  
keyboard entry is also possible with IHGLISH. Gilfoil (1982) 
found that users prefer a command form of entry to menu- 
driven dialogue as their experience increases. When typing, a 
user who is unsure of the coverage can invoke a menu, either 
by a mouse-click or by typing a second space character, to find 
out what INGLISH expects next without aborting the current 
statement. Similarly, any unacceptable word causes the menu 
to appear, giving immediate feedback of a deviation and 
suggestions for correct continuation. A choice from the menu 
can be typed or selected u~ng the mouse. |NGLISH in fact 
allows all actions to be performed from the keyboard or with 
the mouse and for them to be freely intermingled. As only 
valid words are accepted, all completed sentences are well- 
formed and can be translated into the internal representation. 
Figure 5, in the " INGLISH" window, shows a complete 
sentence and its translation, and a partial sentence with a menu 
of continuations. The numbers associated with each menu 
item provide a shorthand for entry, i.e., "~12" can be typed 
instead of "RESISTANCE". As menu entries can be phrases, 
this can save significant typing effort. 
Input is processed on a word-by-word basis. Single spaces 
and punctuation characters erve as word terminators. Words 
are echoed as typed and overwritten in uppercase when 
accepted. Thus, if lowercase is used for typing, the progress of 
the sentence is easily followed. An invalid entry remains visi- 
ble along with the menu of acceptable continuations then is 
replaced when a selection is made. 
The spelling corrector (a Smalltalk system routine is used) 
only corrects to words that would be acceptable in the current 
syntactic/semantic context. As Carbonell and Hayes (1983) 
point out, this is more efficient and accurate than attempting 
to correct against he whole application dictionary. 
Word completion is provided with the "escape" character 
(cf. DEC, 1971). When this is used, INGLISH attempts to 
complete the word on the basis of the characters o far typed. 
If there are several possibilities, they are displayed in a menu. 
Automatic phrase completion occurs whenever the con- 
text permits no choice. The completion will extend as far as 
poss/ble In an extreme case a dngle word could yield a whole 
sentence! The system will "soak-up" any words in the comple- 
tion that have also been typed. 
The spelling cot'rector and automatic phrase completion 
can interact in a disturbing manner. Any  word that is outside 
the coverage will be treated ~s an error and an attempt will be 
made to correct it. If there \[s a viable correction, it will be 
made. Should phrase completion then be possible, a portion of 
a sentence could be constructed that is quite different from the 
one intended by the user. Such behavior will probably be less 
evident in large gramman.  Nevertheless, it may be necessary 
to have a "cautious" and "trusting" mode, as in Interlisp's 
DWIM (Xerox, 1983), for users who resent the precocious 
impat/ence of the interface. 
The system does not support anaphora, and ellipsis is 
offe:ed indirectly. The interface has two modes: "ENTRY"  
and "EDIT" (Figure 5). These are selected by clicking the 
mouse while in the pane at the top right of the interface win- 
dow. Rules are normally entered in the Enter mode. When in 
Edit mode, the window gives access to the SmalltaLk editor. 
This allows any text in the window to be modified to create a 
new statement. After editing, a menu command is used to 
pass the sentence to the paner  as if it were being typed. Any 
errc;" in the constructed sentence causes a remedial menu to be 
displayed and the tail of the edited sentence to be thrown 
away. 
The 1HGLISH interface alleviates the problem of linguis- 
tic coverage for designers and users of natural language inter- 
faces. A natural language interface user composes his entries 
bearing in mind a model of the interface's capabilities. If his 
model is not accurate, his interactions will be error-prone. He 
may excerd the coverage of the system and have his entry 
rejected. If this happens frequently, use of the interface may 
be abandoned in frustration. On the other hand he may form 
an overly conservative model of the system and fail to ur~ize 
the full capabifities of the interface (Tennant, 1980). An inter- 
face designer is confronted by many linguistic phenomena, 
e.g., noun groups, retative rlauses, ambiguity, reference, 
ellipsis, anaphora, and paraphrases. On account of perfor- 
mance requirements or on a lack of a theoretical understand- 
ing, many of these constructions will not be in the interface. 
INGLISH allows designers to rest more comfortably with the 
compromises they have made, knowing that users can sys- 
tematically discover the coverage of the interface. 
256 
THE IMPLEMENTATION OF  INGL ISH 
INGLISH parses incrementally from left to right and per- 
forms all checking on each word as it is entered. The parser 
follows the Left-Corner Algorithm (Gr/ffiths & Petrick, 1965), 
modified to a pseudo-parallel format so that it can follow all 
parses simultaneously (Phillips, 1984). Th/s algorithm builds 
phrases bottom-up from the left-comer, i.e., rules are selected 
by the first symbol of their r/ght-hand-s/des. For example, 
given a phrase initial category e, a rule of the form X --e - -  
wi l l  be chosen. The remaining rule segments of the right-hand 
s/de are predictions about the structure of the remainder of the 
phrase and are processed left-to-right. Subsequent inputs will 
directly match success/ve rule segments ff the latter are term/- 
aal symbols of the grammar. When a non-terminal symbol is 
encountered, a subparse is initiated. The subparse is also con- 
structed bottom-up from the left-corner, following the rule 
selection process just described. When an embedded rule is 
completed, the phrase formed may have the structure of the 
non-terminal category that or/ginated the subparse and so com- 
plete the subparse. If there is no match, it will become the 
left-corner of a phrase that will eventually match the originat- 
ing category. 
The parser includes a Re,whabiliry Mmriz (Griffiths & 
Petrick, 1965) to provide top-down filtering of rule selection. 
The mntrix indicates when a category A can have a category B 
as a left-most descendant in a passe tree. The matrix is static 
and can be derived from the grammar in advance of any pan. 
ing. It is computable as the transitive closure under multiplica- 
tion of the boolean matrix of left daughters of non-terminal 
categories in the grammar. It is used as a further constraint on 
rule selection. For example, when the goal is to construct a 
sentence and the category of the lust word of input is e, then 
rule selection, giving X - c --, will also be constrained to have 
the property S * X -- The filtering is applicable whenever a
rule is selected: during subparses the constraint is to reach the 
category originating the subparse. 
A semantic grammar formalism is used in INGLISH, 
which make the grammar application dependent. As was men- 
tioned earlier, this format was independently chosen as pan of 
the knowledge engineering methodology for describing the 
avplication domain. The rationale for the choice for 
INGLISH was that the simultaneous yntactic and semantic 
checking assists in achieving real-time processing. A fragment 
of the grammar is shown in Figure 1. 
Pre-processing on the grammar coasu'uc:s the terminal 
and non-terminal vocabularies of the grammar, the reachabllity 
matrix, and an inverse dictionary. The set of all possible initia/ 
words and phrases for sentences can also be precomputed. 
The Smafltalk system contnin~ controllers that manage 
activity on a variety of input devices and from these a con- 
troller was readily constructed" to coordinate mouse and key- 
? Smalltalk is an object-oriented language. Instead of 
creating a procedure that controls system operation, the 
user creates an object (usually a data structure), and a 
set of methods (operations that transform, and commun- 
icate with the object). Smalitalk programs create objects 
or send messages to other objects. Once received, mes- 
sages result in the execution of a method. 
Programmers do not create each object and its 
methods individually. Instead, classes of objects are de- 
board activity in INGLISH. Either form of entry increments 
an intermediate buffer which is inspected by the parser. When 
a complete word is found in the buffer it is parsed. 
Every phra~ in an on-going analys/s is contained in a 
Smalltalk object. The final parse is a tree of objects. The 
intermediate state of a parse is represented by a set of objects 
containing partially instantiated phrases. After the first word 
has established an initial set of phrase objects, they are Dolled 
by the pa~er for their next segments. From these and the 
rever~; dictionary, a "lookahead ictionary" is estabfished that 
assoc/ates expected words with the phrasal objects that would 
accept hem. Using this dictionary an incoming word will only 
be sent to those ob~'ts  that will accept it. If the word in not 
in the set of expected words, the dict/onary keys sre used to 
attempt spelling correction and, iI correction fails, to make the 
menu to be displayed. If the dictionary contains only a single 
word, this indicates that automatic phrase completion should 
take place. A new lookahead ictionary is then formed from 
the updated phrase objects, and so On. 
KNOWLEDGE TRANSLATION 
The internal form of a diagnostic role is a clause in Pro- 
log. Sentences are translated using functional stigmata, as in 
lexicai-functioaal grammar. The functional schemata are 
attached to the phrase structure rules of GLIB (Figure 2). 
(t F o a ~ 0  COND roItM), 0 CNCI. FORM))> 
(t COND)-. (t CNCL)-. 
<ride> -> IF <condition> THEN <conclus/on> 
(. r-OaMl--<.~.((t a~). (, SYAI"B)}.~ 
(, ~ *  (t SYAI"R)-. 
<condition> -> <indicator> IS ~ >  
(. e'OltM)--<.umn((, oev), ~m')> 
(, OnV)-, 
<conclus/on>--> <device> HAS FAILED 
Figure 2: GL/B rules with attached schemata 
Unlike lex/cal-functional grammar, the schemata do not set up 
constraint equations as the interface and the semant/c grammar 
ensure the well-formedne~ and unamhigu/ty of the sentence. 
As a result, propagation of functional structure is handled very 
quickly in a post-proce~ng step since the appficable grammati- 
ca/ rules have already been chosen by the parsing process. 
Further, by restricting the input to strictly prescribed sub- 
language GLIB, not Engl~h in general, the Ur~n~Intioa process 
is s/mplified. 
fined. A clam definition describes an object and the 
methods that it understands. Classes are structured 
h/erarehically, and any class automaticaUy /nherits 
methods from its superclass. 
As a result of this hierarchy and code inher/tance, 
applications may be wr/tten by adap~ng previously con- 
? strutted code to the ~k  at hand. Much of the appUca- 
t/on code can be inherited from prev/ously defined 
SmaIitalk code. The programmer need only redefine 
differences by overriding the inappropriate code with 
custom/zed code. (Alexander & Freiling, 1985). 
257 
The parser constzvcts a par~ tree with attached sche- 
mata, referred to as a constituent-structure, or c -s t ructure .  
Translation proceeds by instantiatinS the meta-vatiablns of the 
schemata of the c-structm~ created by INGLISH to form func- 
tional equations which ate solved to produce a functional struc- 
ture ( f -~e) .  The final rule form is obtained from the f- 
structure of the sentence when its sub.structures are recursively 
trandormed according to the contents of each f-structure. 
As an example, given the lexical-functioaal form of the 
semantic grammar in Figure 2 and the following sentence: 
IF LED-2 IS ON THEN TRANSISTOR-17 HAS FAILED 
the' c-structure in Figure 3 would be produced. This shows 
that a rule has a condition part, COND, and a conclus/on part, 
CNCL, that should become a clausal-form ~Ule(COND, 
CNCL). ~ The meta-symbol t refers to the parent node and t 
to the node to which the schema is attached. 
The final phase of INKA interprets the f-structures to 
produce Pmlog clauses. All of the information required to 
produce the clauses is contained in the FORM property in this 
example. The FORM property is printed, with all variables 
instantiated, to produce the f'mal rule in the form of a Prolog 
clause. The f-strucntre of Figure 4 produces the Prolog clause 
rule(state(led-2, on), ~tatus(transistor-17, failed) 
KNOWLEDGE USE 
Translated rules are sent to a diagnostic engine that has 
been implemented ia Pmiog. The diagnosdc engine uses 
GLIB statements about he hierarchical structure of the device 
to build a strategy for successive localization of failures. Start- 
ing at the highest level ('the circuit" in GLIB terminology), 
named sub-cimults are examined in turn, and diagnostic rules 
retrieved to determine correctness or failure of the sub-circuit 
<rule> 
IF <condition.:> THEN 
(taqD~/t \] (t ~nl,A~)~. (t STA~))=~ 
<indicator> IS <state> 
LED-2 ON 
<conclusion> 
(* FOItMl--qmm~(* bey). 
(, cev)-. 
<device>. HAS FAILED 
I 
TR.ANSISTOR- 17 
Figure 3: C-structure 
The functional specifications of the example may be 
solved by instantiating the recta-symbols with actual nodes and 
assigning properties and values to the nodes according to the 
specifications. In the example given, most specifications are of 
the form "(t pmpert'y)=value" where "value" is most often *. 
This form indicates that the node graphically indicated by t in 
? the c-structure is the specified property of the parent node 
(pointed to by *). Specifications are left-= _~:o?_ lative and have a 
functional semantic interpretation. A specification of (t 
COND FORM) refers to the FORM property of the parent 
node's COND property. The f-~mcture for the example is 
given in Figure 4. 
in question. If no specific determination can be made, the 
sub-circuit sa.mumed to be functioning properly. 
A sample session including acquisition of a rule and ato- 
ning of a test diagnosis i  shown in Figure 5. The circuit used 
in this example consists of an oscillator wh/ch drives a light 
emitting diode (LED-2 in the schematic) and a power supply 
(LED-1 indicates when the power supply is on). The 
schematic diagram of the circuit is in the upper pane of the 
"Insu'ument Data" window; the circuit board layout is in the 
lower pane. Rules for diagnosing problems in the circuit 
| IND led-2 
COND\[ STATE on 
\[ FORM <sta~(O IND FORM), (t STATE FORM))> 
CNCL \[ DEV tr~i,~torol7 
t FORM <s~u.?((, DEV), fa~ed)> 
t FORM <rule(O COND), (, CNCL))> 
Figure 4". F-structure 
258 
GUll Knowledge Acquisition Entry 
IF NODE 4 VOLTAGE IS EQUAL TO NODE 5 VOLTAGE THEN RESISTOR 2 HAS FAILED . "PARSED 
rula(comp(aq.voltage(nods(4)).voltags(nods(5 ))).status(componsnt(r ssistor(2))0 f ailed),-) 
IF lOWER SURLY 1.  
CURRENT ($3) 
FREQUENCY (#4) 
HAS FAILED (#5) 
IMPEDANCE (#6) 
IS (ltT~ 
POWER (#111 
RESISTANCE (#12 
VOLTAGE (#13) 
"'ABORT 1#14) 
Is led number 2 not flashing? yes 
What is the voltage of node number 2? 15 
IS led numl:)ef 1 dim? no 
Is it true that the voltage of node number 4 is equal to the 
voltage of node number .5? yes 
Oscillator number 1 is failing. 
Resistor number 2 iS failing. 
Instrument (3ate 
I. No,. 
555 I ~ ~4 
.oo~-, ~ .~.~ : I ,J,,,i", ~=' '  
c= I 
nnnnnnann nnnnnE 
I l n n n n n n n n n n n ~ ~ '  ', ,. ~',;_~ ?.V.~ n n n nE 
I ID l=e~l=l= l i l=~~, , , - . -~ .  ,.-, ' . , . . , i i l l~ l= l= i i |  
I l n n n n n n n ~ n n n n n n n n = ~ . ~  nn  n n= 
~I=IOI I i iD  rrll. l,,~ .... ~,~.'~ = ~ = I= = l= I= n Q" '~ =131=0\ [  
I l nnnnnnn~ ~n~n~nnnqnvt  ~nnn?~l  
l l=nnnnnni!: - .+~'i .  ,! ;'::,,.~ n | i  .,..:.~i~n n l iq  nli=.,'t~= n nn  nql 
l lnn anna  nilii.;.~ ::~..i.,.,~ n B~,:~.~i~!>.,,~ a n i l  n i l  n n n n n n n , l  
I l nnnnann~. , '~ ,~n~nnn lu innn  an  nnql  
Figure 5: An \[\]gKA ===/on 
('troubleshooting" rules) are added to the system in the win- 
dow labeled "INGLISH." The interface to the diagnnszi? 
engine is in the "Prolog" window. The " INGLISI I"  window 
shows a recently added rule, with its Prolog translation 
immediately below it. It also shows a partially completed rule 
along with a menu of acceptable sentence continuations. The 
user may select one of the menu items (either a word or 
phrase) to be appendcd to the current sentence. The "Pmlog" 
window displays the results of a recent est diagnosis. This test 
was run after the first rule in the ~NGLISH"  window was 
added, but before the addition of the second rule was begun. 
The last question asked during the diagnosis corresponds to the 
first rule. Resistor 2, in both the schematic and board 
diagrams of the =Instrument Data" window, is highlighted as a 
result of running the diagnos/s: whenever the diagnnstic engine 
selects a specific component for consideration that component 
is highlighted on the display. Some 20 statements and rules 
have been col lected '.'or diagnosing the circuit; Figure 6 lists a 
portion of them with their Prolog translation. 
259 
THE CIRCUIT CONTAINS OSCILLATOR-1 AND POWERSUPPLY-1. 
has_cemponent(block(circult), block(oscillator(1))). 
has_component(block(c/rcuit), block(powetlupply(1))). 
RESISTOR-1 IS PART OF OSCILLATOR-1. 
has.xomponent(block(o~-fllator(I)), component(resistor(l))). 
IF LED-2 IS NOT FLASHING AND THE VOLTAGE OF NODE-2  IS EQUAL 
TO 15 VOLTS THEN OSCILLATOR-1 HAS FAILED. 
rule(and(not(state(led(2), flashing))), 
comp(voltage(node(2)), If)), 
status(block(oscillator(I)), fa/led), 
\[\]). 
IIF \[..,ED-,1 IS DIM AND LED-2 IS OFF THEN ~ISTOR-1  HAS FAILED. 
rule(and(state(led(l), dim), 
state(led(2), off)), 
status(component(resistor(1)), failed), 
\[\]). 
Figure 6: GLIB rules with Pmlog translations 
DISCUSSION 
Informal observations show that subjects generally need 
only a few minutes of instruction to start using INGLISH. Ini- 
tially there is a preference to tt~ the mouse to explore the cov- 
erage and then to begin to incorporate some typing. We have 
not had any long-term use~ to observe their trends. 
Use~ could react negatively to limited language systems; 
even when the coverage is well-engineered users will occasion- 
ally encounter the boundaries. Fortunately, Headier & 
Michaelis (1983) found that subjects were able to adapt o lim- 
ited language systems. 
INGLISH does not let the designer off the hookl A umr 
can still have a statement in mind and not easily f'md a way to 
expre~ it through the grammar. Diligent engineering is still 
needed to prepare a grammar that will allow a user to be 
guided to a paraphrase of his or/ginal thoughL Nevertheless, 
the grammar design problem is simplified: when guidance is 
provided fewer paraphrases need be incorporated. 
The use of a semantic grammar to define the fragment of 
English to be processed oes impose limitations on the com- 
plexity of acceptable input. In the INKA system as it is 
currently cen.mxtcted, however, them are two distinct ways in 
which the semantic orrectness of an input can be enforced, 
tint in the parsing of the of the semantically ceRstralned 
grammar, and second in the tran.qat/on process, as the ftmc- 
donal structures are built. 
In short, the our approach to building practical natural 
language inte~.-ees does not depend on a semantic grammar to 
?oastra/n input. In the future we intend to explore the u~ of 
a wider class of grammars that include a domain-independent 
kernel and a domain-specific component, like GLIB. In this 
approach we are in substantial agreement with Winograd 
(1984) who advocates a similar approach as an effective diroc. 
finn for further naturul language resea~h. 
REFERENCES 
Alexander, J.H., & Freiling, MJ.  Building an Expert System 
in SmalRalk-80 (R). Systems and Software, 1985, 4, 111-118, 
Alexander, J.H., Freiling, MJ., Messick, S.L., & Reh/uss, S. 
Efficient Expert System Development Through Domain- 
Specific Tools. Proceedings of the F~fth International WorkJhop 
on Expert Systems and their Applications, Avignon, France, 
Burton, R.R. Semamic Grammar: los Eng~ncering Tecb, n i~  for 
Consmac:ing Natural lamgaage UnderstmTding System.v (Techni. 
caJ Report No. 3453). Cambridge, MA: Bolt, Beranek, & 
Newman Inc., 1976. 
Carbonell, J.G., & Hayes, PJ. Recovery Strate~es for Pars- 
ing Extragrammatical Language. American Journal of Computa- 
tional Linguimics, 1983, 3-4, 123.146. 
Davis, R. Interactive Transfer of Expertise: Acquisition of 
New Inference Rules. Proceedings of the Fifth International 
Joint Colrference on Art~iciai intelligence, Cambridge, MA, 
1977, 321-328. 
\[DEC\] TOPS-20 Reference MammL Maynard, MAt Digital 
Equipment Corporation, 1971. 
Freiling, MJ., & Alexander, J.H. Diagrams and Grammar: 
Tools for the Mass Production of Expert Systems. 1EEE First 
Conference on Ar~ficial Intelligence Applications. Denver, 
Colorado, 1984. 
Freiiing, M., Alexander, J., Feucht, D., & Stubbs, D. GL/B - 
A LAnguage for gepreeentmg the Behavior of Electronic Devices 
(Technical Report CR-&t-12). Beaverton, OR: Tektronix, 
Inc., 1984. 
Gilfoil, D.M. Warming up to Computers: A Study of Cogni- 
five and Affective Interaction over Time. Proceedings of the 
Haman Fncterx in Computer 5y~ema Conference, Gaithersburg, 
MD, 1982, 245-250. 
Goldberg, A. & Robson, D. Smalltaik 80: The l,a~guage and 
its lmpiemamtmiom. Re-dlng, MA: Addison-Wesley, 1983. 
260 
Griffiths, T., & Petr/ck, $.R. "On the relative efficiency of 
coatext.free grammar recoe, niT~ru. ? Comm. ACM,  1965, 8, 
289-300. 
Headier, J.A., & Michnefis, P.R. The Effects of Limited 
Grammar on Interactive Natural Language. ProceEdings of tha 
Human Factors in Computer Systems Conference, Bo~a,  MA,  
1983, 190.192. 
Kaplan, R.M., & Bre, mnn, J.W. Lex/cal-Funct/onal Grammar:. 
A Formal System for Grammatical Representat/oa. In J. 
Brecmm (Ed.), T~ Ment~ Representation f O r ~  Rein. 
r/ore. Cambridge, MA: MIT  Press, 1982. 
McKeowa, K.R. Natural Language for Expert Sy~ems: Corn- 
par/son with databa~ systems. Proceedings of tha International 
Conference on Computational l, in~rics, Stanford, CA, 1984, 
190-193. 
Phillips, B. Aa Ob~'t-or/ented Parser. la B.G. Barn & G. 
Gnida (Eds.), Computational Models of Natara~ Langaage Pro. 
?Lu/nz. Amsterdam: North-Holland, 1984. 
Phillips, B., & NichoH, S. INGUSH: A Nanwal Language Inter. 
face (Techn/cal Report CR-84-27). Beaverton, OR: Tek- 
tronix, Inc., 1984. 
Tennant, H.R. Evaluation of Natural Language Processors 
(Technical Report 1"-103). Coordinated S?/eace Laboratory, 
University of Illinois, Urbana, IL, 1980. 
Tennaat, H.R., Ross, K.M., & Thompson, C.W. Usable 
Natural Language Interfaces Through Menu-Based Namra/ 
Language Understanding. Proceedings of the Human Factors in 
Computer ~,, ystem.t Conference, Boston, MA, 1983, 190-192. 
Winograd, T. Mov/ng the Semans/? Fu/o'um (Techn/cal Report 
84-17). Center for the Study of Language and laformat/an, 
Stanford, CA, 1984. 
\[Xerox\] Interlixp Reference Manual  Palo Alto, CA: Xerox 
Palo Alto Research Center, 1983. 
261 
