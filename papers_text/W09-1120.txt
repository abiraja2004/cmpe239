Proceedings of the Thirteenth Conference on Computational Natural Language Learning (CoNLL), pages 156?164,
Boulder, Colorado, June 2009. c?2009 Association for Computational Linguistics
Automatic Selection of High Quality Parses Created By a Fully
Unsupervised Parser
Roi Reichart
ICNC
The Hebrew University
roiri@cs.huji.ac.il
Ari Rappoport
Institute of computer science
The Hebrew University
arir@cs.huji.ac.il
Abstract
The average results obtained by unsupervised
statistical parsers have greatly improved in the
last few years, but on many specific sentences
they are of rather low quality. The output of
such parsers is becoming valuable for vari-
ous applications, and it is radically less expen-
sive to create than manually annotated training
data. Hence, automatic selection of high qual-
ity parses created by unsupervised parsers is
an important problem.
In this paper we present PUPA, a POS-based
Unsupervised Parse Assessment algorithm.
The algorithm assesses the quality of a parse
tree using POS sequence statistics collected
from a batch of parsed sentences. We eval-
uate the algorithm by using an unsupervised
POS tagger and an unsupervised parser, se-
lecting high quality parsed sentences from En-
glish (WSJ) and German (NEGRA) corpora.
We show that PUPA outperforms the leading
previous parse assessment algorithm for su-
pervised parsers, as well as a strong unsuper-
vised baseline. Consequently, PUPA allows
obtaining high quality parses without any hu-
man involvement.
1 Introduction
In unsupervised parsing an algorithm should un-
cover the syntactic structure of an input sentence
without using any manually created structural train-
ing data. The last decade has seen significant
progress in this field of research (Klein and Man-
ning, 2002; Klein and Manning, 2004; Bod, 2006a;
Bod, 2006b; Smith and Eisner, 2006; Seginer,
2007).
Many NLP systems use the output of supervised
parsers (e.g., (Kwok et al, 2001) for QA, (Moldovan
et al, 2003) for IE, (Punyakanok et al, 2008) for
SRL, (Srikumar et al, 2008) for Textual Inference
and (Avramidis and Koehn, 2008) for MT). To
achieve good performance, these parsers should be
trained on large amounts of manually created train-
ing data from a domain similar to that of the sen-
tences they parse (Lease and Charniak, 2005; Mc-
Closky and Charniak, 2008). In the highly variable
Web, where many of these systems are used, it is
very difficult to create a representative corpus for
manual annotation. The high cost of manual annota-
tion of training data for supervised parsers imposes
a significant burden on their usage.
A possible answer to this problem can be pro-
vided by high quality parses produced by unsuper-
vised parsers that require little to no manual efforts
for their training. These parses can be used either
as input for applications, or as training material for
modern supervised parsers whose output will in turn
be used by applications.
Although unsupervised parser results improve,
the quality of many of the parses they produce is still
too low for such goals. For example, the Seginer
(2007) parser achieves an F-score of 75.9% on the
WSJ10 corpus and 59% on the NEGRA10 corpus,
but the percentage of individual sentences with an
F-score of 100% is 21.5% for WSJ10 and 11% for
NEGRA10. When requirements are relaxed, only
asking for an F-score higher than 85%, percentage
is still low, 42% for WSJ10 and 15% for NEGRA10.
In this paper we address the task of a fully un-
supervised assessment of high quality parses cre-
156
ated by an unsupervised parser. The assessment
should be unsupervised in order to avoid the prob-
lems mentioned above with manually trained super-
vised parsers. Assessing the quality of a learning al-
gorithm?s output and selecting high quality instances
has been addressed for supervised algorithms (Caru-
ana and Niculescu-Mizil, 2006) and specifically for
supervised parsers (Yates et al, 2006; Reichart and
Rappoport, 2007; Kawahara and Uchimoto, 2008;
Ravi et al, 2008). Moreover, it has been shown
to be valuable for supervised parser adaptation be-
tween domains (Sagae and Tsujii, 2007; Kawahara
and Uchimoto, 2008; Chen et al, 2008). However,
as far as we know the present paper is the first to
address the task of unsupervised assessment of the
quality of parses created by unsupervised parsers.
Our POS-based Unsupervised Parse Assessment
(PUPA) algorithm uses statistics about POS tag se-
quences in a batch of parsed sentences1. The con-
stituents in the batch are represented using the POS
sequences of their yield and of the yields of neigh-
boring constituents. Constituents whose representa-
tion is frequent in the output of the parser are con-
sidered to be of a high quality. A score for each
range of constituent length is calculated, reflecting
the robustness of statistics used for the creation of
the constituents of that length. The final sentence
score is a weighted average of the scores calculated
for each constituent length. The score thus integrates
the quality of short and long constituents into one
score reflecting the quality of the whole parse tree.
PUPA provides a quality score for every sentence
in a parsed sentences set. An NLP application can
then decide if to use a parse or not, according to
its own definition of a high quality parse. For ex-
ample, it can select every sentence whose score is
above some threshold, or the k top scored sentences.
The selection strategy is application dependent and
is beyond the scope of this paper.
The unsupervised parser we use is the Seginer
(2007) incremental parser2, which achieves state-of-
1The algorithm can be used with supervised POS taggers
and parsers, but we focus here on the fully unsupervised sce-
nario, which is novel and more useful. For completeness of
analysis, we experimented with PUPA using a supervised POS
tagger (see Section 5). Using PUPA with supervised parsers is
left for future work.
2www.seggu.net/ccl.
the-art results without using manually created POS
tags. The POS tags we use are induced by the un-
supervised tagger of (Clark, 2003)3. Since both tag-
ger and parser do not require any manual annotation,
PUPA identifies high quality parses without any hu-
man involvement.
The incremental parser of (Seginer, 2007) does
not give any prediction of its output quality, and
extracting such a prediction from its internal data
structures is not straightforward. Such a predic-
tion can be given by supervised parsers in terms
of the parse likelihood, but this was shown to be
of medium quality (Reichart and Rappoport, 2007).
While the algorithms of Yates et al (2006), Kawa-
hara and Uchimoto (2008) and Ravi et al (2008) are
supervised (Section 3), the ensemble based SEPA al-
gorithm (Reichart and Rappoport, 2007) can be ap-
plied to unsupervised parsers in a way that preserves
the unsupervised nature of the selection task.
To compare between two algorithms, we use each
of them to assess the quality of the sentences in En-
glish and German corpora (WSJ and NEGRA)4. We
show that for every sentence length (up to 20) the
quality of the top scored k sentences according to
PUPA is higher than the quality of SEPA?s list (for
every k). As in (Reichart and Rappoport, 2007), the
quality of a set selected from the parser?s output is
evaluated using two measures: constituent F-score5
and average sentence F-score.
Section 2 describes the PUPA algorithm, Sec-
tion 3 discusses previous work, and Sections 4 and
5 present the evaluation setup and results.
2 The POS-based Unsupervised Parse
Assessment (PUPA) Algorithm
In this section we detail our parse assessment algo-
rithm. Its input consists of a set I of parsed sen-
tences, which in our evaluation scenario are pro-
duced by an unsupervised parser. The algorithm
assigns each parsed sentence a score reflecting its
quality.
3www.cs.rhul.ac.uk/home/alexc/RHUL/Downloads.html,
the neyessenmorph model.
4This is in contrast to algorithms for selection from the re-
sults of supervised constituency parsers, which were evaluated
only for English (Yates et al, 2006; Reichart and Rappoport,
2007; Ravi et al, 2008).
5This is the traditional parsing F-score.
157
The algorithm has three steps. First, the words in
I are POS tagged (in our case, using the fully unsu-
pervised POS induction algorithm of Clark (2003)).
Second, POS statistics about the constituents in I
are collected. Finally, a quality score is calculated
for each parsed sentence in I using the POS statis-
tics. In the following we detail the last two steps.
Collecting POS statistics. In its second step, the
algorithm collects statistics about the constituents in
the input set I . Recall that the yield of a constituent
is the set of words covered by it. The PUPA con-
stituent representation (PCR) consists of three fea-
tures: (1) the ordered POS tag sequence of the con-
stituent?s yield, (2) the constituents? right context,
and (3) the constituents? left context.
We define context to be the leftmost and rightmost
POS tags in the yield of the neighbor of the con-
stituent (if there is only one POS tag in the neigh-
bor?s yield, this POS tag is the context). For the
right and left contexts we consider the right and left
neighbors respectively. A constituent C1 is the right
neighbor of a constituent C2 if C1 is the highest level
constituent such that the first word in the yield of C1
comes immediately after the last word in the yield of
C2. A constituent C1 is the left neighbor of a con-
stituent C2 if C1 is the highest level constituent such
that the first word in the yield of C2 comes immedi-
ately after the last word in the yield of C1.
Figure 1 shows an example, an unlabeled tree for
the sentence ?I will give you the ball?. The tree has
6 constituents (C0-C5). C3 and C4 have both right
and left neighbors. For C3, the POS sequence of its
yield is POS2, POS3 , the left neighbor is C1 and thus
the left context is POS1, and the right neighbor is C4
and thus the right context is POS4. Note that the
left and right neighbors of C3 have only one POS
tag in their yield and therefore this POS tag is the
context. For C4 the yield is POS4, the left neighbor
is C3 (and thus the left context is POS2,POS3), and
the right neighbor is C5 (and thus the right context
is POS5,POS6). C1, whose yield is POS1, has only
a right neighbor, C2, and thus its right context is
POS2,POS6 and its left context is NULL. C2 and C5
(whose yields are POS2, POS3, POS4, POS5, POS6 for
C2 and POS5, POS6 for C5) have only a left neigh-
bor. For C2, this is C1 (and the context is POS1)
while for C5 this is C4 (with the context POS4).
0
1
POS1
I
2
3
POS2
will
POS3
give
4
POS4
you
5
POS5
the
POS6
ball
Figure 1: An example parse tree for contexts and neigh-
bors (see text).
The right context of both constituents is NULL. As
all sentence level constituents, C0 has no neighbors,
and thus both its left and right contexts are NULL.
We have also explored other representations of
left and right contexts based on the POS tags of their
yields. In these, we represented the left/right neigh-
bor using only the leftmost/rightmost POS tags of
its yield or other subsets of the yield?s POS tags.
These variations produced lower quality results than
the main variant above in our experiments, which
were for English and German. Exploring the suit-
ability of our representation for other languages is
left for future research.
Score computation. The third and last step of the
algorithm is a second pass over I for computing a
quality score for each parse tree.
Short constituents tend to be more frequent than
long ones. In order not to distort our score due to
parsing errors in short constituents, PUPA computes
the grade using a division into lengths, in three steps.
First, constituents are assigned to bins according to
their length, each bin containing the constituents of
a certain range of lengths. Denote this range by
W (for width), and the number of bins by N(W ).
For example, in our experiments the longest possible
constituent is of length 20, so we can take W = 5,
resulting in N(W ) = 4: bin 1 for constituents of
length 1-5, bin 2 for constituents of length 6-10, and
so on for bins 3, 4.
The score of bini is given by
(1) BinScore(bini) =?t=Xt=2 (X ? t + 2) ? |C
i
t |
|Ci|
Where X is the maximal number of occurrences
of constituents in the bin that we consider as impor-
tant for the score (see below for its selection), |Cit |
is the number of constituents in bin i occurring at
158
least t times in the batch of parsed sentences, and
|Ci| is the number of constituents in bin i. In words,
the score is a weighted average: the fraction of the
constituents in the bin occuring at least 2 times (with
weight X), plus the fraction of the constituents in the
bin occuring at least 3 times (with weight X ? 1),
etc, until the fraction of the constituents in the bin
occuring at least X times (with weight 2).
A score for the division into N bins is given by
(2) Score(N(W )) =
?N(W )
i=1 BinScore(bini)
Z?M
Where Z is the maximum bin score (according to
(1)) and M is the number of bins containing at least
one constituent. If, for example, N(W ) = 4 and
there is no constituent whose length is between 11
and 15 then bin number 3 is empty. If every other
bin contains at least one constituent, M = 3.
To get a final score for the parse tree of sentence
S that is independent of a specific bin division, we
sum the scores of the various bin division:
(3) PupaScore(S) =
?W=Y
W=1 Score(N(W ))
Y
where Y is the length of S (which is also its max-
imum bin width). PupaScore thus takes values in
the [0, 1] range.
In equation (1), if, for example, X = 20 then
the weight of the fraction of the bin?s constituents
occurring at least 2 times is 20 while the weight of
the fraction of the constituents occurring at least 10
times is 12 and of the fraction of constituents occur-
ring at least 20 times is 2. We consider the number
of times a constituent appears in a batch to be an in-
dication of its correctness. The difference between 3
and 2 occurrences is therefore more indicative than
the difference between 20 and 19 occurrences. More
generally, the more times a constituent occurs, the
less indicative any additional appearance is.
In equation (2) we give all bins the same weight.
Short constituents are more frequent and are gener-
ally more likely to be correct. However, the cor-
rectness of long constituents is an indication that the
parser has a correct interpretation of the tree struc-
ture and that it is likely to create a high quality tree.
The usage of equal bin weights was done to balance
the tendency of parse trees to have more short con-
stituents.
Parameters. PUPA has two parameters: X , the
maximal number of occurrences considered in equa-
tion (1), and P , the number of POS tags induced by
the unsupervised POS tagger. In the following we
present the unsupervised technique we used to tune
these parameters.
Figure 2 shows nc(t), the number of constituents
appearing at least t times in WSJ20 (left) and NE-
GRA20 (right). For both corpora, the pattern is
shown when using 5 POS tags (P = 5, solid line)
and 50 POS tags (P = 50, dashed line). The distri-
bution obeys Zipf?s law: many constituents appear a
small number of times while a few constituents ap-
pear a large number of times. We denote the t value
where the slope changes from steep to moderate by
telbow. Practically, we approximate the ?real? elbow
value and define telbow to be the smallest t for which
nc(t + 1) ? nc(t) = 1. When P = 5, telbow is 32
for WSJ and 19 for NEGRA. When P = 50, telbow is
15 for WSJ and 9 for NEGRA.
The number of constituents appearing more than
telbow times is considerably smaller than the number
of constituents appearing telbow times or less. There-
fore, the fact that a constituent appears telbow + S
times (for a positive integer S) is not a better indica-
tion of its quality than the fact that it appears telbow
times. We thus select X to be telbow.
The graphs also demonstrate that for both cor-
pora, telbow for P = 50 is smaller than telbow for
P = 5. Generally, telbow is a monotonically decreas-
ing function of P . Lower telbow values imply that
PUPA would be less distinctive between constituents
quality (see equation (1); recall that X = telbow).
We thus want to select the P value that maximizes
telbow. We therefore minimize P . telbow values for
P ? {3, . . . , 10} are very similar. Indeed, PUPA
achieves its best performance for P ? {3, . . . , 10}
and it is insensitive to the selection of P in this
range. In Section 5 we report results with P = 5.
3 Related Work
Unsupervised parsing has been explored for several
decades (see (Klein, 2005) for a recent review). Re-
cently, unsupervised parsing algorithms have for the
first time outperformed the right branching heuristic
baseline for English. These include CCM (Klein and
Manning, 2002), the DMV and DMV+CCM models
(Klein and Manning, 2004), (U)DOP based mod-
159
0 50 100
0
5000
10000
15000
t
# o
f co
nst
itue
nts
 ap
pea
ring
 at 
lea
st t
 tim
es
 
 
0 50 100
0
1000
2000
3000
4000
5000
6000
7000
8000
t
 
 
P = 5
P = 50
P = 5
P = 50
Figure 2: Number of constituents appearing at least t
times (nc(t)) as a function of t. Shown are WSJ (left)
and NEGRA (right), where constituents are represented
according to PUPA?s PCR with 5 POS tags (P = 5, solid
line) or 50 POS tags (P = 50, dashed line).
els (Bod, 2006a; Bod, 2006b), an exemplar based
approach (Dennis, 2005), guiding EM using con-
trastive estimation (Smith and Eisner, 2006), and the
incremental parser of Seginer (2007) that we use in
this work. To obtain good results, manually created
POS tags are used as input in all of these algorithms
except Seginer?s, which uses plain text.
Quality assessment of a learning algorithm?s out-
put and selection of high quality instances have been
addressed for supervised algorithms (see (Caruana
and Niculescu-Mizil, 2006) for a survey) and specif-
ically for supervised constituency parsers (Yates et
al., 2006; Reichart and Rappoport, 2007; Ravi et al,
2008). For dependency parsing in a corpus adapta-
tion scenario, (Kawahara and Uchimoto, 2008) built
a binary classifier that classifies each parse in the
parser?s output as reliable or not. To do that, they
selected 2500 sentences from the parser?s output,
compared them to their manually created gold stan-
dard, and used accurate (inaccurate) parses as posi-
tive (negative) examples for the classifier. Their ap-
proach is supervised and the features used by the
classifier are dependency motivated .
As far as we know, the present paper is the first to
address the task of selecting high quality parses from
the output of unsupervised parsers. The algorithms
of Yates et al (2006), Kawahara and Uchimoto
(2008) and Ravi et al (2008) are supervised, per-
forming semantic analysis of the parse tree and gold
standard-based calssification, respectively. How-
ever, the SEPA algorithm of Reichart and Rappoport
(2007), an algorithm for supervised constituency
parsers, can be applied to unsupervised parsers in
a way that preserves the unsupervised nature of the
selection task. In Section 5 we provide a detailed
comparison between PUPA and SEPA showing the
first to be superior. Below is a brief description of
the SEPA algorithm.
The input of the SEPA algorithm consists of a
parsing algorithm A, a training set, and a test set
(which in the unsupervised case might be the same
set). The algorithm provides, for each of the test
set?s parses generated by A when trained on the full
training set, a grade assessing the parse quality, on
a continuous scale between 0 to 100. The qual-
ity grade is calculated in the following way: N ran-
dom samples of size S are sampled from the train-
ing data and used for training the parsing algorithm
A. In that way N committee members are created.
Then, each of the test sentences is parsed by each of
the N committee members and an agreement score
ranging from 0 to 100 between the committee mem-
bers is calculated. All unsupervised parsers men-
tioned above (including the Seginer parser), have a
training phase where parameter values are estimated
from unlabeled data. SEPA can thus be applied to the
unsupervised case.
Automatic selection of high quality parses has
been shown to improve parser adaptation. Sagae and
Tsujii (2007) and Kawahara and Uchimoto (2008)
applied a self-training protocol to a parser adaptation
scenario but used only high quality parses to retrain
the parser. In the first work, high quality parses were
selected using an ensemble method, while in the sec-
ond a binary classifier was used (see above). The
first system achieved the highest score in the CoNLL
2007 shared task on domain adaptation of depen-
dency parsers, and the second system improved over
the basic self-training protocol. Chen et al (2008)
parsed target domain sentences and used short de-
pendencies information, which is often accurate, to
adapt a dependency parser to the Chinese language.
Automatic quality assessment has been exten-
sively explored for machine translation (Ueffing and
Ney, 2007) and speech recognition (Koo et al,
2001). Other NLP tasks where it has been explored
include semi-supervised relation extraction (Rosen-
feld and Feldman, 2007), IE (Culotta and McCal-
lum, 2004), QA (Chu-Carroll et al, 2003), and dia-
log systems (Lin and Weng, 2008).
The idea of representing a constituent by its yield
160
and (a different definition of) context is used by the
CCM unsupervised parsing model (Klein and Man-
ning, 2002). As far as we know the current work is
the first to use unsupervised POS tags for the selec-
tion of high quality parses.
4 Evaluation Setup
We experiment with sentences of up to 20 words
from the English WSJ Penn Treebank (WSJ20,
25236 sentences, 225126 constituents) and the Ger-
man NEGRA corpus (Brants, 1997) (NEGRA20,
15610 sentences, 108540 constiteunts), both con-
taining newspaper texts.
The unsupervised parsers of the kind addressed
in this paper output unlabeled parse trees. To eval-
uate the quality of a single parse tree with respect
to another, we use the unlabeled F-score (UF =
2?UR?UP
UR+UP ), where UR and UP are unlabeled recall
and unlabeled precision respectively.
Following the unsupervised parsing literature,
multiple brackets and brackets covering a single
word are not counted, but the sentence level bracket
is. We exclude punctuation and null elements ac-
cording to the scheme of (Klein, 2005).
The performance of unsupervised parsers
markedly degrades as sentence length increases.
For example, the Average sentence F?score for WSJ
sentences of length 10 is 71.4% compared to 58.5
for sentences of length 20 (the numbers for NEGRA
are 48.2% and 36.9%). We therefore evaluate PUPA
(and the baseline) for sentences of a given length.
We do this for every sentence of length 2-20 in
WSJ20 and NEGRA20.
For every sentence length L, we use PUPA and the
baseline algorithm (SEPA) to give a quality score to
each of the sentences of that length in the experi-
mental corpus. We then compare the quality of the
top k parsed sentences according to each algorithm.
We do this for every k from 1 to the number of sen-
tences of length L.
Following Reichart and Rappoport (2007), we use
two measures to evaluate the quality of a set of
parses: the constituent F-score (the traditional F-
score used in the parsing literature), and the average
F-score of the parses in the set. In the first mea-
sure we treat the whole set as a bag of constituents.
Each constituent is marked as correct (if it appears
in the gold standard parses of the set) or erroneous
(if it does not). Then, recall, precision and F-score
are calculated over these constituents. In the sec-
ond measure, the constituent F-score of each of the
parses in the set is computed, and then results are
averaged.
There are applications that use individual con-
stituents from the output of a parser while others
need the whole parse tree. For example, if the se-
lected set is used for training supervised parsers such
as the Collins parser (Collins, 1999), which collects
constituent statistics, the constituent F-score of the
selected set is the important measure. In applica-
tions such as the syntax based machine translation
model of (Yamada and Knight, 2001), a low qual-
ity tree might lead to errorenous translation of the
sentence. For such applications the average F-score
is more indicative. These measures thus represent
complementary aspects of a set quality and we con-
sider both of them.
The parser we use is the incremental parser of
(Seginer, 2007), POS tags are induced using the un-
supervised POS tagger of ((Clark, 2003), neyessen-
morph model). In each experiment, the tagger was
trained with the raw sentences of the experiment cor-
pus, and then the corpus words were POS tagged.
The output of the unsupervised POS tagger de-
pends on a random initialization. We ran the tagger
5 times, each time with a different random initializa-
tion, and then ran PUPA with its output. The results
we report for PUPA are the average over these 5 runs.
Random selection results (given for reference) were
also averages over 5 samples.
PUPA ?s parameter estimation is completely unsu-
pervised (see Section 2). No development data was
used to tune its parameters.
A 200 sentences development set from each cor-
pus was used for calibrating the parameters of the
SEPA algorithm. Based on the analysis of SEPA per-
formance with different assignments of its param-
eters given by Reichart and Rappoport (2007) (see
Section 3), we ran the SEPA algorithm with sam-
ple size (SEPA parameter S) of 30% and 80%, and
with 2 ? 10 committee members (N )6. The optimal
parameters were N = 10,S = 80 for WSJ20, and
6We tried higherN values but observed no improvements in
SEPA?s performance.
161
0 200 400 60070
75
80
85
90
95
100
Number of Sentences
A
ve
ra
ge
 F
 S
co
re
(a) WSJ, length 5
0 500 1000
60
65
70
75
80
85
90
Number of Sentences
A
ve
ra
ge
 F
 S
co
re
(b) WSJ, length 10
0 500 1000 1500
50
55
60
65
70
75
80
Number of Sentences
A
ve
ra
ge
 F
 S
co
re
(c) WSJ, length 15
0 500 1000 1500 2000
48
50
52
54
56
58
60
62
64
Number of Sentences
A
ve
ra
ge
 F
 S
co
re
(d) WSJ, length 20
0 200 400 600 800
50
55
60
65
70
75
80
Number of Sentneces
A
ve
ra
ge
 F
 S
co
re
(e) NEGRA, length5
0 200 400 600 800 1000
40
45
50
55
60
65
Number of Sentences
A
ve
ra
ge
 F
 S
co
re
(f) NEGRA, length 10
0 200 400 600 800
30
35
40
45
50
55
60
Number of Sentences
A
ve
ra
ge
 F
 S
co
re
(g) NEGRA, length 15
0 200 400 600 800
50
55
60
65
70
75
80
Number of Sentneces
A
ve
ra
ge
 F
 S
co
re
(h) NEGRA, length 20
0 500 1000 1500 2000
70
75
80
85
90
95
Number of Constituents
C
on
st
itu
en
ts
 F
 S
co
re
(i) WSJ, length 5
0 2000 4000 6000 8000 10000
60
65
70
75
80
85
Number of Constituents
C
on
st
itu
en
ts
 F
 S
co
re
(j) WSJ, length 10
0 0.5 1 1.5 2
x 104
55
60
65
70
Number of Constituents
C
on
st
itu
en
ts
 F
 S
co
re
(k) WSJ, length 15
0 0.5 1 1.5 2 2.5
x 104
54
56
58
60
62
64
Number of Constituents
C
on
st
itu
en
ts
 F
 S
co
re
(l) WSJ, length 20
0 500 1000 1500 2000 2500 3000
62
63
64
65
66
67
68
69
Number of Constituents
C
on
st
itu
en
ts
 F
 S
co
re
(m) NEGRA, length5
0 1000 2000 3000 4000 5000
44
46
48
50
52
54
56
58
Number of Constituents
C
on
st
itu
en
t F
 S
co
re
(n) NEGRA, length 10
0 2000 4000 6000 8000
40
42
44
46
48
50
Number of Constituents
C
on
st
itu
en
ts
 F
 S
co
re
(o) NEGRA, length 15
0 500 1000 1500 2000 2500 3000
62
63
64
65
66
67
68
69
Number of Constituents
C
on
st
itu
en
ts
 F
 S
co
re
(p) NEGRA, length 20
Figure 3: In all graphs: PUPA: solid line. SEPA: line with triangles. MC: line with circles. Random selection is
presented for reference as a dotted line. Top two rows: Average F-score for PUPA, SEPA and MC for sentences from
WSJ (top row) and NEGRA (bottom row). Bottom two rows: Constituents F-score for PUPA, SEPA and MC for
sentences from WSJ (top row) and NEGRA (bottom row). Results are presented for sentence lengths of 5,10,15 and
20 (patterns for other sentence lengths between 2 and 20 are very similar). PUPA is superior in all cases. The graphs
for PUPA and SEPA show a downward trend because parsed sentences were sorted according to score, which correlates
positively with F-score (unlike MC). The graphs converge because on the extreme right all test sentences were selected.
N = 10, S = 30 for NEGRA20.
We also compare PUPA to a baseline selecting the
sentences with the lowest number of constituents.
Since the number of constituents is an indication of
the complexity of the syntactic structure of a sen-
tence, it is reasonable to assume that selecting the
sentences with the lowest number of constituents is
a good selection strategy. We denote this baseline by
MC (for minimum constituents).
The incremental parser does not give any predic-
tion of its output quality as supervised generative
parsers do. We are thus not able to compare to such
a score.
5 Results
Figure 3 shows Average F-score and Constituents F-
score results for PUPA SEPA and MC, for sentences
162
of lengths 5,10,15 and 20 in WSJ20 and NEGRA20.
The top two rows are for Average F-score (top row:
WSJ, bottom row: NEGRA), while the bottom two
rows are for Constituents F-score (top row: WSJ,
bottom row: NEGRA).
PUPA and SEPA are both better than random selec-
tion for both corpora for every sentence length. The
MC baseline is better than random selection only for
NEGRA (in which case it outperforms SEPA). For
WSJ, however, random selection is a better strategy
than MC.
It is clear from the graphs that PUPA outperforms
SEPA and MC in all experimental conditions. We
observed very similar patterns in all other sentence
lengths in WSJ20 and NEGRA20 for both Average
F-score and Constituent F-score. In other words, for
every sentence length in both corpora, PUPA outper-
forms SEPA and MC in terms of both measures. we
present our results per sentence length to deprive the
possibility that PUPA is useful only for short sen-
tences or that it prefers sentences whose syntactic
structure is not complex (i.e. with a small number of
constituents, like MC).
Table 1 shows that the same pattern of results
holds when evaluating on the whole corpus (WSJ20
or NEGRA20) without any sentence length restric-
tion.
Note that while PUPA is a fully unsupervised al-
gorithm, SEPA requires a few hundreds of sentences
for its parameters tuning.
The main result of this paper is for sentences
whose length is up to 20 words (note that most un-
supervised parser literature reports numbers for sen-
tences up to length 10). We have also ran the exper-
iments for the remaining length range, 20-40. For
NEGRA, PUPA is superior over MC up to length 36,
and both are much better than SEPA. For WSJ, PUPA
and SEPA both outperform MC, but SEPA is a bit bet-
ter than PUPA. When evaluating on the whole corpus
(i.e. without sentence length restriction, like in Ta-
ble 1) PUPA is superior over both SEPA and MC for
WSJ40 and NEGRA40.
For completeness of analysis we also experi-
mented in the condition where PUPA uses gold stan-
dard POS tags as input. The number of these tags is
35 for WSJ and 57 for NEGRA. Interestingly, PUPA
achieves in this condition the same performance as
when using the same number of POS tags induced
by an unsupervised POS tagger. Since PUPA?s per-
formance for a smaller number of POS tags is better
(see our parameter tuning discussion above), the bot-
tom line is that PUPA pefers using induced POS tags
over gold POS tags.
5% 10% 20% 30% 40% 50%
WSJ20
PUPA 82.75 79.34 75.77 73.46 71.68 70.3
SEPA 78.68 75.7 72.64 70.72 69.54 68.58
MC 76.75 74.6 72.1 70.35 68.97 67.77
NEGRA20
PUPA 70.66 67.06 61.89 58.75 56.6 54.73
SEPA 66.19 62.75 59.41 57.16 55.23 53.7
MC 69.41 65.79 60.87 58.08 55.9 54.36
Table 1: Average F?score for the top k% of constituents
selected from WSJ20 (up) and NEGRA20 (down). No sen-
tence length restriction is imposed. Results presented for
PUPA , SEPA and MC. Average F?score of random se-
lection is 66.55 (WSJ20) and 47.05 (NEGRA20). PUPA is
superior over all methods.
6 Conclusions
We introduced PUPA, an algorithm for unsupervised
parse assessment that utilizes POS sequence statis-
tics. PUPA is a fully unsupervised algorithm whose
parameters can be tuned in an unsupervised man-
ner. Experimenting with the Seginer unsupervised
parser and Clark?s unsupervised POS tagger on En-
glish and German corpora, PUPA was shown to out-
perform both the leading parse assessment algorithm
for supervised parsers (SEPA, even when its param-
eters are tuned on manually annotated development
data) and a strong baseline (MC).
Using PUPA, we extracted high quality parses
from the output of a parser which requires raw text
as input, using POS tags induced by an unsupervised
tagger. PUPA thus provides a way of obtaining high
quality parses without any human involvement.
For future work, we intend to use parses selected
by PUPA from the output of unsupervised parsers
as training data for supervised parsers, and in NLP
applications that use parse trees. A challenge for
the first direction is the fact that state of the art su-
pervised parsers require labeled parse trees, while
modern unsupervised parsers create unlabeled trees.
Combining PUPA with algorithms for labeled parse
trees induction (Haghighi and Klein, 2006; Reichart
and Rappoport, 2008) is a one direction to overcome
this challenge. We also intend to use PUPA to assess
the quality of parses created by supervised parsers.
163
References
Eleftherios Avramidis and Philipp Koehn, 2008. En-
riching Morphologically Poor Languages for Statisti-
cal Machine Translation. ACL ?08.
Rens Bod, 2006a. An All-Subtrees Approach to Unsu-
pervised Parsing. ACL ?06.
Rens Bod, 2006b. Unsupervised Parsing with U-DOP.
CoNLL X.
Thorsten Brants, 1997. The NEGRA Export Format.
CLAUS Report, Saarland University.
Rich Caruana and Alexandru Niculescu-Mizil, 2006. An
Empirical Comparison of Supervised Learning Algo-
rithms. ICML ?06.
Jennifer Chu-Carroll, Krzysztof Czuba, John Prager and
Abraham Ittycheriah, 2003. In Question Answering,
Two Heads Are Better Than One. HLT-NAACL ?03.
Wenliang Chen, Youzheng Wu and Hitoshi Isahara,
2008. Learning Reliable Information for Dependency
Parsing Adaptation. Coling ?08.
Alexander Clark, 2003. Combining Distributional and
Morphological Information for Part of Speech Induc-
tion. EACL ?03.
Michael Collins, 1999. Head-driven Statistical Models
for Natural Language Parsing. Ph.D. thesis, Univer-
sity of Pennsylvania.
Aron Culotta and Andrew McCallum, 2004. Confidence
Estimation for Information Extraction. HLT-NAACL
?04.
Simon Dennis, 2005. An Exemplar-based Approach to
Unsupervised Parsing. Proceedings of the 27th Con-
ference of the Cognitive Science Society.
Aria Haghighi and Dan Klein, 2006. Prototype-driven
Grammar Induction. ACL ?06.
Daisuke Kawahara and Kiyotaka Uchimoto 2008.
Learning Reliability of Parses for Domain Adaptation
of Dependency Parsing. IJCNLP ?08.
Dan Klein and Christopher Manning, 2002. A Gener-
ative Constituent-Context Model for Improved Gram-
mar Induction. ACL ?02.
Dan Klein and Christopher Manning, 2004. Corpus-
based Induction of Syntactic Structure: Models of De-
pendency and Constituency. ACL ?04.
Dan Klein, 2005. The Unsupervised Learning of Natural
Language Structure. Ph.D. thesis, Stanford University.
Myoung?Wan Koo, Chin-Hui Lee and Biing?Hwang
Juang 2001. Speech Recognition and Utterance Ver-
ification Based on a Generalized Confidence Score.
IEEE Transactions on Speech and Audio Processing,
9(8):821?832.
Cody Kwok, Oren Etzioni and Daniel S. Weld, 2001.
Scaling Question Answering to the Web. WWW ?01.
Matthew Lease and Eugene Charniak, 2005. Towards a
Syntactic Account of Punctuation. IJCNLP ?05.
Feng Lin and Fuliang Weng, 2008. Computing Confi-
dence Scores for All Sub Parse Trees. ACL ?08, short
paper.
David McClosky and Eugene Charniak, 2008. Self-
Training for Biomedical Parsing. ACL ?08, short pa-
per.
Dan Moldovan, Christine Clark, Sanda Harabagiu and
Steve Maiorano, 2003. Cogex: A Logic Prover for
Question Answering. HLT-NAACL ?03.
Vasin Punyakanok and Dan Roth and Wen-tau Yih, 2008.
The Importance of Syntactic Parsing and Inference in
Semantic Role Labeling. Computational Linguistics,
34(2):257-287.
Sujith Ravi, Kevin Knight and Radu Soricut, 2008. Au-
tomatic Prediction of Parser Accuracy. EMNLP ?08.
Roi Reichart and Ari Rappoport, 2007. An Ensemble
Method for Selection of High Quality Parses. ACL
?07.
Roi Reichart and Ari Rappoport, 2008. Unsupervised
Induction of Labeled Parse Trees by Clustering with
Syntactic Features. COLING ?08.
Benjamin Rosenfeld and Ronen Feldman, 2007. Us-
ing Corpus Statistics on Entities to Improve Semi?
Supervised Relation Extraction From The WEB. ACL
?07.
Kenji Sagae and Junichi Tsujii, 2007. Dependency
Parsing and Domain Adaptation with LR Models and
Parser Ensemble. EMNLP-CoNLL ?07.
Yoav Seginer, 2007. Fast Unsupervised Incremental
Parsing. ACL ?07.
Vivek Srikumar, Roi Reichart, Mark Sammons, Ari Rap-
poport and Dan Roth, 2008. Extraction of Entailed
Semantic Relations Through Syntax-based Comma
Resolution. ACL ?08.
Noah A. Smith and Jason Eisner, 2006. Annealing Struc-
tural Bias in Multilingual Weighted Grammar Induc-
tion. ACL ?06.
Nicola Ueffing and Hermann Ney, 2007. Word-
Level Confidence Estimation for Machine Translation.
Computational Linguistics, 33(1):9?40.
Kenji Yamada and Kevin Knight, 2001. A Syntax-Based
Statistical Translation Model. ACL ?01.
Alexander Yates, Stefan Schoenmackers and Oren Et-
zioni, 2006. Detecting Parser Errors Using Web-
based Semantic Filters . EMNLP ?06.
164
