All Active Bilingual Lexicon for Macldne Translation 
lgal GOLAN,  Shalom I.APPIN*, Mori RIMON 
IBM Israel Scientific Center, 
The Technion City, l laifa 32000, Israel 
(*) Main affiliation: The University of tlaifa 
E-mail address: golan and/or lappin and/or rimon @israearn.bitnet 
Abstract 
An approach to tile Transfer phase of a Machine Translation 
system is presented, where the bilingual lexicon plays an active 
role, guiding Transfer by means of executable descriptions of 
word senses. The means for lexical sense specification are, 
however, general enough and can in principle apply to other 
system arthitectures, e.g. in tile Generation phase if Transfer 
is intentionally kept minimal. The active lexicon is the one and 
only systea~ component which is exposed to users and can 
serve to linguistically control Transfer effects. A unified 
approach to lexicon creation and maintenance is proposed, 
which contains means to gradually refine sense specification 
and tailor the definitions to specific text domains. The under- 
lying linguistic principles, the nature of sense distinction 
required tot translation, and tilt: formal structure of the 
lexicon are discussed. 
I? h t t roduct ion  
While melbods of monolingual Analysis and Generation are 
also treated in other contexts, bilingual Transfer problems are 
hardly inw~stigated outside the context of Machine Translation. 
Research in Machine Translation can, in this case, make a spe- 
cific contribution to Computational l,inguistics. The general 
issue here is tire formal representation f phrase structures and 
lexical units and the  methodology for specifying transf- 
ormations between these representations in two (or more) lan- 
guages. The role of tile bilingual lexicon in the Transfer 
activity, attd its power to assist in the resolution of mapping 
problems, is a key element. 
In tills paper we present an approach to the formal represen- 
tation of bilingual exical knowledge and to the way this know- 
ledge is incorporated into the translation process. In section 2 
we describe the role and place of the bilingual lexicon in the 
translation process, present the concept of executable 
descriptions of word senses as lexical definitions, and discuss 
some aspects of practical usage. Our approach to the sense 
distinction required for translation, which is different from 
monolingual sense distinction, is discussed in section 3. In 
section 4 we make a few methodological comments, arguing 
that wha! is often portrayed as the ideal Transfer-based archi- 
tecture, is not the only, and not necessarily the best way to 
achieve modularity and save work. Section 5 contains a formal 
definition of the lexicon specification language with some dis- 
cussion of its features and the intended restrictions on the 
power given to the lexicographer. Finally, an additional 
example is given in detail in section 6. 
This work has been carried out as part of the MENTOR 
project, where several groups in European IBM Scientific 
Centers are collaborating on M(A)T research. The approach 
presented here has been developed and prototyped by the 
group in Ilaifa, Israel, as part of the proposal for tire design 
of Transfer-related operations. The examples below involve 
translations from English into I lebrew. 
We thank our colleagues Danit Ben-Ari, Esther Bentur and 
Maria Vilkuna for their contributions and comments. 
2. "lhe Role and Content of the Bilingt, al Lexicon 
\[Cullingford 87\] describes an MT system which is purely 
lexicon driven. Ills system follows the Conceptual Processing 
model, and is not Transfer-based, hence the emphasis there is 
on deep Analysis and Generation. Many other systems distin- 
guish between I.exical Transfer and Structural Transfer, but 
they take different approaches to the actual separation of these 
two sub-processes. In the work reported here, an attempt was 
made to strictly separate lexicon-driven selection of target lan- 
guage equivalents from the global mapping of syntactic struc- 
tures in the SIA into those of tile 'I'I~ (cf. \[Biewer 85\]). ' lhe 
lexicon lookup phase, which takes place before phrase struc- 
ture transformations, gets as its input the internal data repre- 
sentation provided by the SL parser (PEG \[Jensen 86\], in out 
prototype). The terminal nodes (leaves of a parse tree) are 
searched in a pre-defined order for certain parts of speech. 
For each word in turn a target equivalent is selected from the 
bilingual exicon and attached to the corresponding node in the 
parse. Features may also be added to other affected nodes. 
f lowever, no structural modifications are made. Structural 
transformations are carried out as an independent sub-process, 
upon completion of tire bilingual exical phase, and are not dis- 
cussed in this paper. 
Since in many cases, and ill fact for most verbs, several alter- 
native translations exist, tile selection is done by texical differ- 
entiation rules. These rules refer to the syntactic environment 
of tile word in the parse tree and to a limited number of 
semantic features. The rules can access any node and attribute 
identified by the parser. Given that the rules are stated in 
terms of the SL phrase structure, it seems more natural to 
apply them as close to Analysis as possible. Nevertheless, the 
sense distinction cannot be done as part of SL Analysis itself, 
as in many cases it depends on factors which may vary from 
one TL to another. 
The sub-process of bilingual lexical substitution proceeds uni- 
directionally. No iterations take place for any given phrase. In 
some cases this may require extensive searching of' the phrase 
The filllowing abbreviation~ are u~ed throughout hi~ pal~er: 
SL =: Source Language ,  BL = BiLingual,  TL  = Target  Language 
205 
structure in a manner determined by the relevant differen- 
tiation rules. 
The differentiation rules which comprise an entry in the bilin- 
gual lexicon are stated in a special language, and are directly 
executable by a set of functions (LISP, in our implementa- 
tion). Although the phrase attributes and features they can 
refer to are similar, to some extent, to what is done in certain 
other systems (see for example \[Nagao 86\]), it seems that 
action rules are more-flexible and powerful than static form- 
oriented structures. In fact, each statement in the set of rules 
which comprises a given lexical entry defines a correspondence 
between a syntactic environment (with semantic decoration) in 
the source language and a translation into the target language. 
Consider, for example, one of the four rules which comprise 
the entry for the verb "avoid" in the English-ilebrew lexicon. 
This particular ule identifies the case where the current verb 
node (CN) has a postmodifier noun phrase and the head noun 
of that noun phrase has the semantic attribute Animate (e.g. 
"She avoids her old father."). In that case the Hebrew trans- 
lation should be "r~ pr3rEn~". In terms of the lexicon specifica- 
tion language and the attributes used by the PEG parser, the 
rule looks as follows: 
If ( CN has Postbrother ((CAT NP)(ANIMATE +)) ) 
Then < Put (HEB "13 p~nnn" ) ;>; 
The put instruction attaches the tlebrew translation as a 
feature on the current node (CN is the default node assumed 
when no explicit node name is specified for put). 
Certain lexical rules can be simply and elegantly formulated in 
terms of functions which identify grammatical relations of 
various kinds. Thus, for example, the rule for translating the 
verb "return" can be specified in terms of the feature Passive, 
and the presence or absence of a direct object. The set of rules 
which follows makes the required istinction between the erga- 
tive (intransitive) sense and the transitive reading of the verb: 
Start RETURN VERB 
1 If (call OBJECT) Then < Put (HEB ""l~tl'l,"l" );end;> ; 
@ Example: Ron returned the book. 
@ Example: The book was returned. 
2 Put (ItEB "'tin" ); 
@ (this is the default ranslation) 
@ Example: Ron returned early. 
Finish 
Ideally, the feature OBJECT could be defined as part of the 
information provided by the parser. However, if for some 
reason the parser does not identify such relations, it can be 
defined as a function, written in the lexicon specification lan- 
guage described in this paper, which will evaluate the parse 
tree during Transfer. An example of such a function, which is 
included as a utility function in the active bilingual lexicon 
system, is given in \[Golan 88\], an extended version of this 
paper. This function tests a tree for the presence of a constit- 
uent which is the direct object of a given verb. If the verb 
appears in the passive voice, it assumes existence of a direct 
object (note that the active voice is selected for the ltebrew 
equivalent even in the passive case; passivization is done later 
in Generation). 
It may be necessary to define functions which identify more 
complex grammatical relations than the direct object of a 
given verb. It is, for example, necessary to refer to the relation 
'head noun argument, with property P, of an adjective', when 
formulating the rule for an adjective like "available": 
Start AVAILABLE ADJ 
If (Call N-of-ADJ (HUMAN)) 
Then < Put ( I tEB"~I~") ;> 
@ Example: The doctor is not available now. 
@ Example: Any available salesperson can help you. 
Else < Put (HEB "~l~lr3" ); > ; 
@ Example: This book is available in every store. 
Finish 
The algorithm N-of-AD.I, given in detail in section 6 below, 
characterizes a parameterized function which identifies the 
head noun argument, with property P, of a given adjective. 
This algorithm is written in the lexicon specification language 
and is also included as a utility function in the lexicon system. 
Rules which employ this function can render the translation of 
an adjective dependent upon the modified noun phrase having 
specific attributes. It should also be noted that the function 
N-of-ADJ identifies the noun when the adjective acts as a pro- 
nominal modifier as well as when it appears in the VP predica- 
tive form. 
It is important o recognize that functions of this kind are 
useful to the extent hat they can be employed in a significant 
number of lexical rules. There are, however, many cases in 
which the translation rules must be formulated directly as 
search procedures on trees. There are no obvious general 
grammatical functions which can be used to define the syn- 
tactic relations that must be tested in order to determine trans- 
lation in these cases. Consider, for example, the set of rules for 
the adverb "precisely": 
Start PRECISELY ADVERB 
1 If (CN has ancestor((CAT NP PP))) 
Then < Put (IIEB "p~,'l't" );end;> ; 
@ Example: This is precisely the question. 
@ Example: Rina spoke precisely to the point. 
2 Put (tlEB "p~rll3a" ); 
@ Example: Ron formulated his answer precisely. 
Finish 
The disjunctive relation of being the descendent of either an 
NP or a PP does not seem to be the sort of grammatical 
relation which one would wish to encode in a general gram- 
matical function. 
Similarly, consider the set of rules below, which are part of the 
definition of the verb "allow". The case where this verb 
appears in an active voice and forms part of the verb-particle 
construction "allow for" are identified by searching the tree for 
the preposition "for" which may be the head of a possibly non- 
adjacent PP: 
1 If ( CN has First Postbrother (name-l((CAT PP)) 
has Son name-2C(CAT PREP)(base "for")))) 
Then < Put (IlEB "l~a'~na np'~" ); 
Put in name-2 (11EB "");end; > ; 
@ Example: Ron allowed for the results. 
2 If ( CN has Postbrother (A((CAT AVP)) 
has Descendent (name-l((CAT PREP)(base "FOR")) 
before B((CAT NP))))) 
Then < Put (HEB "l~a'~na np~" ); 
Put in named (I IEB "");end; >;  
@ Example: Ron allowed reluctantly and cautiously 
@ for the results. 
In fact, the basic need to look for a nonoadjacent particle is 
rather common. It may justify inclusion of generalized 
206 
relations in the lexicon formalism. A generalized notion of 
"postbrother" will enable the statement of the sense distinction 
above as one rule. However, the detailed design of such gener- 
alized relations is very complex and is not yet included in our 
model. 
The "allow for" example presents yet another problem for 
translation. The Ilebrew translation "llaton3. tlptJ " consists of 
two words which have individual verb and noun entries in the 
TL  lexicon. If the target translation is a recognized collocation 
or idiom it can be specified as such in the TL lexicon. But 
there are cases where an SL entry must be rephrased in the 
'FL as an ad-hoc combination of words which does not form a 
lexical entity. In that case the lexical rule must mark words 
with corresponding parts of speech, or provide alternative 
information which will serve later in Generation to properly 
decide on the required morphological manipulation. 
Generally, our experiments with actual lexical entries lead us 
to believe that the most efficient strategy for formulating 
lexical rutes is to use a combination of general functions and 
rule-specific search procedures. A formal description of the 
specification language and a detailed example of its expressive 
power am given in sections 5 and 6 below. 
Tire creation of a large scale full-fledged BL lexicon is a very 
heavy tar;k, impeding development of product level systems. 
There is no way to avoid it, but there are ways to facilitate the 
practical development of the lexicon by making the process 
more modular. The scheme presented in this paper enables the 
system lexicographers - and each individual user - to proceed 
in steps. As a first, rough, approximation, one may sinrply 
define one "default ranslation"; e.g., for the verb "type": 
Start TYPE VERB Put (\[IEB "'o~9"r~" ); Finish 
This will account for the use of "type" in the sense of "type- 
write". Later, other senses can be defined (e.g. "),ll~ro", for 
"classify"), going from the most frequent in a given context to 
the relatively rare ones, thus achieving an increasingly refined 
level of sense specification. The optimal level of detail may 
depend on user needs and on specific text domains. In fact, dif- 
ferent sense distinctions may be required for different domains. 
The user can modify the lexicon accordingly, or define his/her 
own private addenda lexicon, overriding identical entries in the 
main lexicon. 
The lexicon of the system is accessible to revision by users. 
l-lowevel, users cannot modify the global transformations 
which map syntactic structures in tile St. into those of the TL, 
nor can they interfere with morphological aspects of Gener- 
ation (TL values in the bilingual lexicon are given in a canon- 
ical form; e.g. for ttebrew verbs: 3rd person - singular - past 
tense - active voice). Consequently, user influence is con- 
strained in such a way that it cannot disrupt the functioning of 
the large scale architecture of the system, but can at most 
affect lo?al changes of a lexically based nature. 
This is one obvious advantage of the strict separation between 
bilingual lexical transfer and general phrase structure transf- 
ormations. Another benefit of this approach is the restriction 
of the structures that must be considered for transformations 
to standard, non-distorted SL phrase structures, as provided 
by the SL parser. This eliminates complications and loss of 
generality of the structural transformations. Also, from a 
software engineering perspective, it is clearly advantageous to
keep the two sub-processes independent of each other. 
llowew~r, the extent to which this separation can be main- 
tained is not evident. In certain cases, e.g. when there is no 
simple way to preserve tire part of speech in translation, lexi- 
con-driven modifications of the phrase structure could facili- 
tate the process. In such cases, which are fortunately not very 
common, we will consider attachment of "transformation 
triggers" to nodes, based on the bilingual lexicon processing. 
Technically, this can be easily done in our specification for- 
realism. The lexical phase itself will not make any changes in 
phrase structure, and only one pass of structural transf- 
ormations will still be required. 
Indeed, as \[Melby 86\] points out, the whole issue of lexical 
transfer and in particular the effect lexical transfer has on the 
overall quality of translation deserves further study. 
3. Sense  D is t inc t ion  Character i s t i cs  
The highest level of distinction in the bilingual lexicon is the 
part of speech. Within each part of speech one may distinguish 
different senses (and specify lexical rules) as required in light 
of TL sense distinctions. According to one initially plausible 
view, it is possible to make use of the subcategorization infor- 
mation present in standard monoliugual dictionaries to obtain 
the necessary syntactic information for disambiguating dif- 
tcrent senses of words in the SL. In fact, we have found this 
view to be untenable. Thus, for example, among the 13 senses 
that \ [ l .ongman 78\] distinguishes for the verb "hold", many are 
mapped to the ltebrew verb "p~trl,-l", even when they belong 
to diffelent syntactic categories as defined in l .ongmans 
system. On the other hand, consider the different uses of 
"hold" in the following sample sentences: 
- She is holding tile baby 
- We held our breath in fear 
We were holding a meeting 
Although l .ongman makes a distinction between the three 
senses (cases 1,3, and 13, respectively), all of them are classi-- 
tied as TI verbs according to Longman's coding system, which 
is the only feasible instrument for cornputer reference, h-t 
l lebrew, different w.qbs nmst be used ("p~tlnW, " '1t1~",  "t3~rF)" , 
respectively). Moreover, even under the same sense (10), tw~ 
sample sentences are given, which in ltebrew require differc~lt 
verbs: 
What he said still holds ("qprr') 
- Can the good weather hold'? ("'l~Nr3n ") 
As a second example of the inadequacy of standard monolin- 
gual subcategorization, consider l .ongman's class of T3 verbs .- 
verbs which take infintival complements with "to" and NP 
objects. E.g.: 
want Ron to win 
ask Ron to leave 
tell Ron to come 
llowever, each of the corresponding \[lebrew verbs has a dis. 
tinct subeategorization frame: 
- "lnSll~ l~l~ n~2tl ? (want that Ron will win) 
- ":a~tg~ \]Ytt3 ~p:at3" (ask from Ron to leave) 
- "R~ttt~ lrtt~ lrJlR" (tell to Ron to come) 
Note that the form 
-. "a~ty, I13~9 ~par3" (ask that Ron will leave) 
is also valid ill Ilebrew, but as a translation of "ask that Ron 
leaves" rather than "ask Ron to leave". Therefore, Transfel 
and not Generation seems to us the natural place to decide on 
the appropriate form. 
207 
These, examples illustrate the lack of isomorphism between 
subcategorization patterns for specific verbs in English and 
their counterparts in Hebrew. It is reasonable to expect that, 
generally, subcategorization is not invariant under translation 
between most SL-TL pairs (cf e.g. \[Warwick 87\]). As \ [Nagao 
86\] points out, "it is not exceptional, but rather usual, that a 
verb of SL has to be translated into different target lexical 
items, even though the native speakers of SL cannot clearly 
realize the meaning difference". Consequently, we have found 
it useful to construct algorithms which map lexical items, con- 
sidering subcategorization properties and sense distinctions of 
both SL and TL. This is especially useful for verbs, but the 
same specification formalism is used for all other lexical cate- 
gories, making use of syntactic information in different ways. 
We anticipate that the construction of a large scale lexicon will 
be facilitated by the existence in the SL of subclasses of items, 
in each lexical category, which have identical or highly similar 
subcategorization frames, and which correspond to items in 
the TL with similar frames. The entries for the elements of 
such subclasses can be handled by algorithms whose state- 
ments have more or less the same selection conditions. 
In constructing the BL lexicon of our system we have followed 
a lexicalist view of syntax. In particular, our view of the inter- 
action of the syntactic omponent and the lexicon in Transfer 
is inspired by the projection principle \ [Chomsky 1981\]. This 
principle states that the syntactic structure of a phrase (at any 
level of representation) !s a projection of the argument struc- 
ture imposed by the lexical entry of the head of the phrase. 
Mapping of a lexical item in the SL onto a counterpart in the 
TL depends upon a matching of the subcategorization frames 
of the two items. This matching requires recognition of an SL 
item in a tree as the head of a sub-phrase which satisfies the 
argument structure specified by the antecedent conditions of 
one of the statements in its lexical entry. Translation of any 
sub-clause begins with its head, as this determines the argu- 
ment structure of the clause. 
It is necessary to qualify this characterization f our approach 
in an important respect. Although our algorithms are stated 
primarily in terms of the syntactic information provided by the 
parser, we have found it necessary to supplement this informa- 
tion with a restricted list Of general semantic features. For 
example, consider the verb "run". On its intransitive use, it 
translates into l lebrew as "p~", while its transitive use corre- 
sponds to the ttebrew causative verb "~,"1". l lowever, 
intransitive "run" allows certain NP adverb complements, as in 
"run a mile". To identify these NPs as adverbial phrases and 
so preserve the intransitive sense of "run", we attach attributes 
Time or Distance to the entries of nouns like "time" and "mile" 
in the SL lexicon. The algorithm for "run" can then recognize 
it as having its intransitive sense when it takes only one com- 
plement and the head N of this NP contains one of these attri- 
butes. Features such as 1 luman/Non-human,  
Concrete/Abstract, etc., and a small number of domain specific 
features (e.g. hardware device, software component, state, etc., 
for the domain of computer manuals) are also included. 
There is yet another kind of feature marker that we include in 
the SL lexicon, and which we call "list marker". These markers 
assist disambiguation in cases where a few nouns can be 
grouped together, usually for computational efficiency, 
although their common denominator has no obvious name. 
For example, in the sense distinction for the verb "assume", if
the complement is an NP with a noun in the set \[office, chair- 
manship, position,...\], then the ttebrew verb-equivalent is dif- 
ferent from other sub-cases of "assume". We give this group 
of nouns a name and mark the nouns in the group accord- 
ingly. Then one can refer to this name as a feature. Indeed, 
nouns in such groups have semantic similarities, and in prin- 
ciple, they are equivalent to traditional semantic markers. The 
point is that list markers can be formed in an ad-hoc fashion, 
without worrying about the generality of the group, or finding 
an appropriate label for it. 
The different mechanisms presented above provide, in fact, 
various levels of characterization of the relation between a 
given verb and a noun (or an NP) to which it refers: subcat- 
egorization requirement for the very existence of a noun (NP) 
in a given position (e.g. as a direct object); a more constricting 
requi~ement for the existence of a noun with specified 
semantic features (defined as such, or by means of lists, in the 
SL lexicon); and a particular equirement for the existence of a 
specific noun (or group of nouns). 
The sense distinction for multi-sense nouns (homonyms and 
polysemes) and other parts of speech is done according to bas- 
ically the same strategy which we use for verbs; namely appli- 
cation of context-sensitive differentiating rules. Generally, 
nouns and adjectives are less ambiguous for translation, but 
the ambiguity, when it exists, is more difficult to resolve at the 
sentence level without extensive semantic and pragmatic know- 
ledge. Still, many cases can be resolved by rules of the kind 
shown above. For example, although nouns, unlike most 
verbs, do not require complement structures, disambiguation 
in the source language can sometimes be facilitated by rules 
which refer to the presence of optional N complements. Con- 
sider, for example, the noun "statement". When it has a 'that' 
S' complement ("a statement that Rina has been promoted") it 
translates to l lebrew "~9~ra~ " when it occurs with a PP com- 
plement headed by "of" with an NP object headed by an inani- 
mate noun ("statement of the theory"), it translates to "tq~Xg~:l". 
When sense distinction cannot be expressed in terms of our 
system (e.g. for the homonymous noun "bank"), we specify 
only the more common sense in the given text domain. In the 
future, we may mark such cases so that the information about 
the lexical ambiguity can be made available to an interactive 
disambiguation module. 
For adjectives, the characterization is done in most cases by 
reference to semantic features of the noun(s) they modify. In 
some cases different ranslations will be required for an adjec- 
tive when it appears as a prenominal modifier or in the VP 
predicative form: 
- My old friend is not old 
"lpt '0~R ~9~9 p~ln  "1:lrlW 
The syntactic distinction between the two forms of "old", and 
the selection of the different \[lebrew equivalents ("IPt", 
"p~rn'), are easy to specify in our formalism (cf. the definition 
of N-of-ADJ in section 6 below). 
4. Some Methodo log ica l  Aspects  
From the discussion and examples above, it is apparent hat 
our lexicon specifies bilingual information in great detail. This 
may seem to conflict with certain modern approaches to 
Transfer methodology, where the guiding view is "small (and 
simple) is beautiful". \[lsabelle 86\], \[Arnold 87\], and others, 
advocate an approach where the BL lexicon states only facts 
like: 
208 
know -> wissen (in German; or "savoir" in French; 
or "n9~9" in I lebrew, 
when the verb takes a sentential object) 
know -> kennen (ill German; or "conaitre" in French; 
or "'1~3,'19" in t lebrew, 
when the verb takes a nominal object) 
The selection of the correct translation is then done in the 
Generation t/hase, based on restrictions on tile target language. 
We claim that this approach is problematic for the following 
reasons. 
First, the "know" example, although widely quoted in the liter- 
ature, is rather simplistic. Even in the monolingual subcategor- 
ization for "know" in \ [Longman 78\], there are 15 different 
frames, re:my of which require a different verb, or verb-form, 
use of a preposition, or even a completely different syntactic 
structure in I lebrew. Ill addition, there are verb-particle and 
other collocations which would be quite difficult (and unna- 
tural) to handle if decisions were postponed to the monolin- 
gual Generation ("know of", "know better", "know X to be 
Y", are some examples which hold not only for 1 lebrew). It is 
not single words but patterns and structures that must be 
handled sirnuitaneously. 
Second, one should note that the mechanism presented in this 
paper may also, ill principle, be applied to Generation rather 
than TransDr; the conditions will then be stated in terms of 
tile target language. By the same token, certain differentiating 
rules may be also applied as part of Analysis (or post-Ana- 
lysis), t lowever, we feel that the right place for this kind of 
processing is in Transfer. At least when the target and source 
languages are linguistically renlote (as, for example, in the case 
of English and l lehrew), severely restricting the scope of BL 
operatimls may result in loss of information vital for trans- 
lation on the way to Generation; e.g. dependence on tense or 
voice, when tile structural expressions of these properties are 
different irt the SL and TL. Alternatively, such information 
could be carried forward to Generation, but then Generation 
loses its primarily monolingual nature. 
Allowing Transfer to pass forward alternative translations for 
SI~ lexical entries, may result in a large number of possible 
sentence t~anslations which must be handled by Generation. 
Even if conceptually viable, this strategy is computationally 
highly unattractive. A similar comment is often made in other 
contexts (e.g. Analysis - cf. \[Stallard 87\]). 
Finally, it ~&ould be enlphasized that keeping Transfer small is 
not, in itself, the crucial issue. More important, it seems to us, 
is the isolation of bilingual considerations. (Isolation should 
not be mistaken for serialization of SI,-BL-TL operations, 
which is not at all required. Ideally, isolated modules could 
even work in parallel, as suggested by \[Isabelle 86\]). In fact, 
trying to minimize bilingual Transfer at any cost may yield 
unnecessarily complex Generation and/or Analysis, which are 
forced to handle problems that are not inherently within their 
scope. If, for example, Generation has to consider patterns 
that were .n ly  created by phenomena ill a certain source lan- 
guage but were not fully resolved in Transfer, then minimizing 
Transfer represents no real gain in nmdularity or language 
independence. Nor does it save lexicographic effort, as in any 
case, the linguistic classification and judgement process 
re,nains b:~.sically tile same, even if shifted to other system 
components. 
A remark is in order concerning multi-target generality. In 
principle, it is technically possible to add tags at tile put state- 
ment, along with the ItEB tag, to define multilingual trans- 
lations (cf. e.g. Boitet g6\]). l lowever, from our discussion of 
ttre difference between monolingual subcategorization patterns 
and the sense distinctions needed for translation, it follows that 
the algorithms in the lexicon must be further refined in order 
to cove," all sub-senses needed for a set of given target lan- 
guages. For any one language in the set, many of the differen- 
tiating rules will be redundant (see "voir trad n" definitions in 
\[Boitet 86\]). In practice, it would be better to construct dis- 
tinct variants of the lexicon for different arget languages. This 
need not significantly increase the lexicographic work required, 
as it is possible to use an existing lexicon as the basis for con- 
structing new variants. The linguistic re-evaluation of senses is 
required anyway. What is important is that all target languages 
use the same structure and formalism. 
5. The  Spec i f i ca t ion  Language 
\[Slocum 87\] claims (correctly, ill our view) that "lexical entries 
for computer use tend to be \[ormally stated, compact, and 
thus cryptically encoded". While the formal style is inevitable, 
we have tried to avoid compactness and cryptical expression 
by allowing the lexicographer to state the lexical facts and the 
effects they have on processing in terms that are directly 
related to the logic of the linguistic process. Therefore, tile set 
of available instructions i rather simple and intuitive. We have 
tried to allow enough expressive power to support a variety of 
requirenlents for bilingual lexical mapping, while restricting 
the scope of operations as much as possible, to reduce com- 
plexity and avoid undesired side effects on other entries or 
suhsystems. We have also emphasized ease of maintenance and 
testing, and strict isolation of the lexical subsystem from other 
parts of the translation system. 
Each entry in tile bilingual lexicon is in fact a mini-program. 
Although executable declarations may look complicated at first 
glance, they have, in our view, many advantages over a rigid 
data structure. The specification formalism may be less neat 
and "natural" than ttre metalanguage \[Isabelle 86\] hopes for, 
but it call be made more "user friendly" through the introduc- 
tion of higher level abbreviations on top of the basic language, 
as required by users. Some functions for abbreviated writing 
were mentioned in section :2 above. Other mechanisms (e.g. 
macros) can be used to tailor the specification style to indi- 
vidual tastes. 
The program which comprises a lexical entry is initiated by 
reference to a lexical item that appears on tile Sl. parse tree. 
The program ternlinates when an end instruction is reached, 
or when the last instruction in the program is executed. A 
function is terminated by a return instruction. 
The instructions allow the lexicographer to check for the exist- 
ence of a |)articular condition or pattern on the parse tree by 
an appropriate /_f instruction; control tile seqnencing of 
instructions by using a goto instruction; and decide on a partic- 
ular translation for a word by using a put instruction (this is 
not allowed in the case of a function). 
The following represents tile current inventory of lexieal oper- 
ations supported by the specification formalism. It may be 
necessary to extend this formalism as more experience is 
gained with actual lexical entries. 
The syntax of the specification language is given below. Bold 
letters denote non-terminal constructs, normal letters denote 
terminals (keywords). The notation used is as follows: 
209 
symbo l  descr ip t ion  symbol description 
= = a meta-symbol. \ [ term\]  
I a meta-symbol denoting choice. (term) + 
nil a representation of the null string or list. (term)* 
( )  < > ; terminals. 
program = = start access-key statement + finish 
statement = = \[label :\] instruction 
uric or no appearance of term. 
one or more appearances of term. 
zero or more appearances of term. 
instruction = = end; I goto(label); I put \[in u-name\] (allowed-attribute value); I call function-name(parameter-list); I 
if (condit ion)then < instruction + > \[else < instruction + > \]; 
function-name = = user-delined-\[unction-name \[ pr -defined-\[unction-name 
user-defined-function = = define user-delined-\[unetion-name In-statement + finish 
hi-statement = = \[label :\] \[n-instruction 
fn-instruction = = goto(label); I return(true); I return(false); I call pre-defined-function-name(parameter-list); I 
if (condit ion)then < \[n-instructio n + > \[else < \[n-instruction + > \]; 
condition = = call fimction-name I simple-pattern \[ not (condition) L (condition) and (condition) I (condition) or (condition) 
simple-pattern = = n-name(attribute-pair +)  I n-name has \[ no \] relation pattern 
pattern-condition = = node has \[ no \] relation pattern 
node : = \[n-name\](attribute-pair +)  I n-name 
relation : = \[f irst\] prebrother I \[f irst\] postbrother I \[f irst\] son i father I ancestor \[ 
\ [ last\]  prebrother \[\[ last\] postbrother \[\[ last\] son I descendent I relative 
pattern = = simple-pattern-condition { (pattern-condition) I (pattern \ [not \ ]  before pattern) I (pattern \ [not \ ]  after pattern) 
simple-pattern-condition = = node I (node,) + node \[ (node or node) \] (node and node) 
u-name = = main I cn \] name 
parameter-list = = nil i parameter +
attribute-pair = = (attribute-name value +)  
value = = string \[ key I ( value + ) 
label : = Ilanle 
access-key = = lexical item followed by part of speech. 
attribute-name = = name 
allowed-attribute = = an attribute-name the user is allowed by the system to change. 
pre-defincd-function-name = = a name of a function defined by the system. 
user-defined-function-name = = name 
name = = a string of letters and digits starting with a letter. 
parameter = = a parameter passed to a function. 
comment = = each line starting with @ is a comment. 
210 
The programs and functions in the dictionary include names 
for various entities. The scope of these names is limited as 
much as possible in order to facilitate debugging and mainte- 
nance (e.g. a name of a label or of a particular pattern (node) 
is recognized only within the program in which it appears). 
The user's ability to define variables and names is also inten- 
tionally restricted. There are two special names: MAIN, the 
name of the root of the parse tree; and CN (Current Node), 
the name of the leaf node representing the word for which the 
program wa:; invoked. 
Additional information about the semantics Of names, a formal 
definition of the relations between odes (e.g. prebrother, first 
prebrother, descendent, relative, etc.) and the keywords Before 
and After, etc., are provided in \[Golan 88\], an extended 
version of this paper. 
6. An Additional Example 
The following is the function N-of-ADJ, introduced in section 
2 above, which identifies the head noun argument, with prop- 
erty P, of a given adjective. It is a somewhat simplified version 
which deals with the major relevant phrase structures. It is 
given here mainly to illustrate the expressive power of the spe- 
cification folmalism as a general tool for pattern matching on 
parse trees. 
Define N-of. ADJ 
@ The funclion N-of-ADJ returns a True/False value 
@ The parameter P refers to a feature that can get +/- values 
If (CN has Ancestor ( A ((CAT AJP)) has Postbrother 
F((CAT NP NOUN)(P +)))) 
Then < Return(True); > ; 
@ John is an old and valued friend. 
@ John spoke to many old and valued friends. 
If (CN has Ancestor (A((CAT AJP)) has Prebrother 
F((CAT NP NOUN PRON) (Wtl nil)(P +)))) 
Then < Return(True); > ; 
@ John is very old, 
@ Mary is very old and tired. 
If (CN has Ancestor ( A ((CAT QUES)) has First Son 
F ((CAT NP PRON)(WH l)))) 
Then < If (F ((P +))) Then < Return(True);> 
Else < Return(False); > ; > ; 
@ Who is competent? 
@ Who does John expect o seem old? 
@ What does John expect o seem old? 
If (CN has Ancestor B((CAT INFCL))) 
Then < If(((B has Prebrother 
F ((CAT NP NOUN PRON)(WH nil)(P +))) 
or (B has Father ( C ((CAT AJP)) has Prebrother 
F ((CAT NP NOUN PRON)(WH nil)(P +)) ) ) ) 
or (B has Father ( C ((CAT INFCL)) has Prebrother 
F ((CAT NP NOUN PRON)(WH nil)(P + )) ) ) ) 
Then < Return(True); > ; > ; 
@ John wants to be rich and famous. 
@ Bill is certain to be happy. 
@ Mary wants to seem to be competent and punctual. 
5 If ( CN has Ancestor ( A ((CAT RELCL)) has Prebrother 
F((CAT NOUN)(P + )))) Then < Return(True); > ; 
Finish 
References 
\[Arnold 87\] Doug Arnold and Louis des Tombe: "Basic 
Theory and Methodology in Eurotra", in Machine Translation." 
1fieoretical and Methodological Issues, Sergei Nirenburg (ed.), 
Cambridge University Press, 1987. 
\[Biewer 85-1 Axel Biewer, Christian Feneyrol, Johannes 
Ritzke and Ervin Stegentritt: "ASCOF - A Modular Multilevel 
System for French - German Translation", Computational Lin- 
guistics, vol 11, no. 2-3, April-September 1985. 
\[B0itet 86 \ ]  Christian Boitet and N. Nedobejkine: "Toward 
Integrated Dictionaries for M(a)T", Proe. of COLING'86, 
Bonn, August 1986. 
\[Chomsky 81\] Noam Chomsky: Lectures on Government and 
Binding, Foris Publications, Dordrecht, Holland, 1981. 
\[Culling\[ord 87\] Richard E. Cullingford and Boyan A. 
Onyshkevych: "An Experimentation in Lexical-driven 
Machine Translation", in Machine Translation. 712eoretical nd 
Methodological Issues, Sergei Nirenburg (ed.), Cambridge Uni~ 
versity Press, 1987. 
\[Golan 88\] Igal Golan, Shalom Lappin and Mori Rimon: 
"An Active Bilingual Lexicon for Machine Translation", Tech- 
nical Report 88.242, IBM Israel Science and Technology, July 
1988. 
\[Isabelle 86\] Pierre lsabelle and Elliott MackIovitch: 
"Transfer and MT Modularity", Proc. of COLING'86, Bonn, 
August 1986. 
\[Jensen 86\] Karen Jensen: PEG 1986: A Broad-coverage 
Computational Syntax of English, Technical Report, IBM T. 
J. Watson Research Center, February 1986. 
\[Longman 78\] Longman Dictionary of Contemporary Engfish, 
Longman Group lad., Harlow and London, England, 1978 
(1986 edition). 
\[Melhy 86\] Alan K. Melby: "Lexieal Transfer: a Missing 
Element in Linguistic Theories", Proe. of COIANG'86, Bonn, 
August 1986. 
\[Nagao 86\] Makato Nagao and Jun-ichi Tsujii: "The 
Transfer Phase of the Mu Machine Translation System", Proc. 
of COLING'86, Bonn, August 1986. 
\[Slocum 87\] Jonathan Slocum and Martha Morgan: "The 
Role of Dictionaries and Machine-Readable L xicons in Trans- 
lation", International Lexicon Workshop, Stanford, July-Au- 
gust 1987. 
\[Stallard 87\] David Stallard: "The Logical Analysis of 
Lexical Ambiguity", 25th Annual Meeting of the ACL, Stan- 
ford, July 1987 
\[Warwick 87\] Susan Warwick: "Automated Lexical 
Resources in Europe", International Lexicon Workshop, Stan- 
ford, July-August 1987. 
211 
