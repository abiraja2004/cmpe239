JAUNT:  A Constra int  Solver 
for Disjunctive Feature Structures 
Hiroshi Maruyama 
IBM Research,  Tokyo Research Laboratory  
maruyama@ t r l .vnet . ibm.conl  
Abst rac t  
To represent a conlblnatorial nulnber nf ambigu 
ous interpretatioas of a natural a'nguage sentence f- 
ficiently, a "packed" or "factorized" represeutath)n is 
necessary. We propose a representatitm hat comprises 
a set of explicit value disjunctltms and constraints hn- 
posed on them. New constraints are successively added 
for disambiguation, dnrhtg which local consistencies 
are maintained by an underlying mechanism. We have 
developed a constraint solver called JAUNT that em 
bodies this idea. The latest techniques, including con 
straint propagation and forwa,vl checking, are employed 
ms constraint satisfaction mechauisms. JAUNT also al- 
lows an external recta-inference program tn intervene 
in the constraint satisfaction process in order to control 
the application of the constraints. 
1.  I n t roduct ion  
Certain natural language constructs, such as PP: 
attachnmnt in English, are known to have a combinato- 
rial number of syntactic parses (Church & Patil 1988). 
For example, sentence (1) has 14 (= Catalan(4)) dif= 
ferent parses because of the three consecutiw~ PPs: 
Put the block on t}m floor on the table in the 
room. (1) 
Representing the set of parses in a compact way and 
extracting a correct parse by using such knowledge as 
A block cannot be on a thmr and on a table 
at the same time 
are keys to a practical natural anguage system. 
The parsing method of Constraint Dependency 
Grammar (Maruyama 1990) axldressed exactly these 
issues. The essential ideas were 
? to represent the set of parses by a constraint net- 
work, which is emnposed of a set of explicit, vahm 
disjunctions and constraints imposed on them, 
? to apply constraint propagation i  order to kee I) 
the constraint network locally consistent, and 
? to dynamically add new constraints for disam- 
biguation. 
In this paper, we describe a programming tool 
named JAUNT that embodies the above ideas. 
JAUNT is a constraint solver for disjmmtive feature 
structure% whose constraint satisfaction mechanisms 
are constraint propagation and forwar~l checking. In 
the next secthm, we show \]tow various ambiguities are 
represented in our explicit vahm disjunction + con- 
straints cheme. The constraint satisfaction algorithnls 
S :~ { 
\[id=O,cat=v,head=put,gr=root,mod=nilJ, 
\[id=i,cat=np,hoad=block,gr=obj,mod~O\], 
\[id=2,cat=pp,prep=on,head=floor, 
gr={~loc,postmod~},mod={~O,l~} \ ] ,  
\[id=S,cat=pp,prep=on,head=table, 
gr={~ioc,postmod~},mod={~O,l,2~} \], 
\[id=4,cat=pp,prep=in,head=room, 
gr={~loc,postmodZ},mod={~O,l,2,3~} J 
}; 
Figure 1: JAUNT representation f sentence (l) 
adapted in JAUNT are explained in Section 3. Section 
4 describes the rise /)f JAUNT's recta-inference apa- 
bility. Section 5 concludes the paper. 
2.  Exp l i c i t  d i s junct ion  + const ra in ts  
Let us emmlder sentence (1). In order to simplify 
the following dlscussimt, we iL~stlnle that the sentence 
is prepmcessed ms in Figure 1. This preprocessing can 
be done \[W a simple context-free grammar that does 
not determhm PP-attachments. In the figur% \ [ . . . \ ]  
is a featnre structure, { . . .}  is a llst, and {~{...Y,} 
is a disjunction. "Phus~ the variable S represents the 
(packed) structure of sentence (1) as a list of five eom- 
\[}mmnts 1 each of whldl corresl)onds to a V: an NP, or 
a PP. The grammatical relation (gr=) and the modi- 
flee (meal=) of the three PPs are disjunctions, meaning 
that one of the wdues shouhl be selected, but that the 
correct candidate has not yet beat determined. For ex- 
ample, the first PP "on the floor" has {~0,1~,} .'~s its 
and= vahm, which means it can modify either phrase 0 
(the verb "put") or phrase 1 (the NP "the block"). 
Not all the value combhtations of the disjunctions 
are allowed. In the above example, if a PP modifies 
the main verb, the grammatical relation should be loc. 
In JAUNT, constraints are introduced by addc state- 
meats. The program fragment (2) applies constraints 
between the moditlee and the grammatical relation of 
a pp. 
fo r  W in S begin 
addc W.cat==pp & S.(W?mod).cat in {pp,np} => 
W?gr==postmod ;
addc W.cat==pp ~ S. (W?mod) .cat==v => 
W?gr==loc; 
end; (2) 
\[\]ere~ dots and question marks are operators for me: 
cessing components of bsts or feltture structurest. '\].'he 
?The difference between a (lot and a question mark is that a 
Ac~.s DE COLING-92, NAIVI~S, 23-28 Ao(rr 1992 1 1 6 2 PRec. OF COLING-92, NANIES, AUG. 23-28, 1992 
symbols t~ (logical and) an,I => (iml,ly) h~ve their or- 
dinary logical meanings. In geuernl, ;tny first-order 
logical formula without qnantifieation is allowed as a 
ctmstraint. 'Fhe variable W is bonnd to ea~zh V~ NP~ 
and PP while the addc statelnen|,s lmtweee beg in  and 
end are executed. Tim lirst addc statement reaxls ~s 
ft)ll(,ws: 
If tile category of W is PP aud the category of 
the modifiee of W is either PP or NP, then the 
grammatictd relation of W should be postmod. 
The applied constraints are represented implicitly by 
an internal data structure called a consltvdnt oeln,o'rk 
(described t;tter). 
in axlrlititlu~ tam p,'ojeclivity constrzdut, that modifi~ 
cation liuks do unt crossover, can be progranmmd ~s 
h)llows: 
for Y,X in S begin 
addc (Y.id < L id  ~ X?mod < Y.Jd) => 
l?mod <= Y?mod; 
end; (3) 
We have now obtained a packed representation that 
consists of explicit disjunctions, as in Figure 1, and 
constraints attached behind them. Each value conl-- 
bination of the disjunctions that globally sat, isfies tim 
constraints exactly corresponds to one of the 14 parses 
of sentence (1). 
Every context-free parsing ,~lgorit.hnl timt ha.s a 
polynomial time bound prodnees a pu~cketl represen 
tation of the parsing results (for example, ? chart ill 
chart parsing (Kaplan 1973), a pa,'si.g mat,'ix in the 
CKY nmthod (Yonnger 1967), and a .sha,~d-packed- 
forest in qbmita's algoritlun (Tomita 1987)). These 
representations take advantage of tile regularities of 
syntactic ambiguities in context-free parslog. For ex- 
ample, sillce it is known that 1~ consecutive P\]'s ilave 
Cutalan(n) different p~zrses, it is possible to encode 
all PP-attachment ambiguities by renlemberiug only n 
and the position of tile PPs (Church ~ Patil 1982). 
However, once we try to extract ~ single illterpre 
tation item these representations, we face a prubhml, 
because such regularities may be vnid when new cun.- 
straints ~re introduced for disnmbiguati,nl. Consider 
the application of constraint (4): 
A verll cannot have two h)eatives. (4) 
Tiffs constraint viohttes the regularity of the PI'  
att;miunent ambiguity and tl,ereh)r,~, the Cb'G be-led 
packed representations lentioned ailove cannot hall-- 
tile this new int~rmation properly without modifyiug 
the grammar significantly. Ill JAUNT~ this constraint 
is ~pplied by a simple addc statement (5). 
for X,? in S begin 
adde not(X?mod==Y?mod ~ S. (X?mod) .cat==~ & 
X?gr==i?c & Y?gr==l?c) ; (5) 
end ; 
lebrrnaliy~ it ha.s beea proven that Constraint De- 
peudency Grammars: whose rules Ca~ b(! written a~s 
q.estion mrtrk allows ~ disjunction as its value, w\]mre~ a (lot 
does not. The cllrretlt inl|l lell lentatiOll generates more e|flclent 
code for dots than for question m~rks. 
S := { 
\[id=O, cat=v ,head=put, gr=root ,and=nil\], 
lid = i, cat=rip, head=block, gr=obj ,mod=O\] , 
lid=2, cat =pp, prep=on, head=f leer, 
gr={%loc,postmod~,},mod={%0, I%) \] , 
\[id=3, cat=pp, prop=on ,head=t able, 
gr={%inc,postmod~},mod={%0,2~} \] , 
lid=4, cat=pp, prep=in, huad=room, 
gr={~Ioc, postmod%}, mod={%0, I, 2,3~} \] 
}; 
Figure 2: JAUNT rel,resent~tion f sentence (1) 
restricted f(irms of JAUNT program: have ~ weak 
generativr power strictly greater than that of CI"G 
(Maruy~ma 1991), This implies that certain types of 
pa~rsing results can be represenu..d by constraint net- 
works but not by CFG based represmttatioos. 
Sen and Simmons (1988) proposed syntactic 9~phs 
and discussed the axlvantagos of having explicit, d is  
junctions in a packed data structure. Their represeu 
tation is similar to ours in tile seuse th;tt they have 
con~trahlts attached to the explicit disjnnctive data 
structure. However, they d .  uot diseusa how to ~rp. 
ply disam\[liguation k owledge in order tn reduce the 
ambiguity effectiwqy, lu JAUNT, the underlying con- 
straint saris\[action algorithm removes im:onsistmdl val- 
IteS ~cnd keeps tim constrai/it uetwork locally consistent. 
Consider, lot example~ the application of the new con 
straint (6): 
An object {:annot In! on two distinct objects 
a,t the same tin,e. (6) 
This constraint is written a~s follows: 
for X,Y in S begin 
addc X.prap~=on ~ Y.prep==on & 
X?mod in {pp,np} => X?mod != Y?mod;17) 
end; 
After this coustraint \[ta.s beet, evahl~ted~ tile and 
attribute of the t 'P  "on the t~ble" becomes {~0,2Z}, 
n~ strewn it, Figure 2, because the vMue 1 is locally 
inconsisteut ;mcnrtling to the coostraints applied su far, 
and central, pneti( il,ate ill any of the remaining seveu 
re;tdings. 
There },ave been several ~Lttenlpts to incorporate dis 
junctions in uniiicatinu-ba.sed grammars re.g. Karl 
tuoen 1984). Constr.'tints ;ere introduced by ~t unifi- 
cation between two disjuuctiw.' feature structures. A 
nnificatio, succeeds only if there are combinations (ff 
wducs of the disjunctions that s~tisfy tile equality con 
straints implied by the u,lificatio.. It, order to clarify 
the exl,ressiw~ power of fe~ture structures with gen- 
eral disjunctions, Kasper ~ Rounds (1986) defined a 
logic-be-led notation called FM1, A fornlula in FMI, 
can be rewritteu as an addc statement in JAUNT, and 
hence, constraints expre~ed hy a unification can also 
be expr~ssed in JAUNT. In ~|dition, in unification- 
based grammars, the nnly basic predicate is equality, 
aud other useful predicates, such em inequalities and 
set inclusion/membership, arediflicuh to represent. In 
~If the secottd PP "on tile table" modifies the NP "the block," 
the first PP "on tim riot,r" ha.s no legal modifiee~. 
ACRES DE COLING-92, Nam'l~s, 23-28 AOUX' 1992 1 1 6 3 I'koc. OV COLING-92, NANTES, AU(L 23-28, 1992 
JAUNT,  inequalities and set operations are built-in, 
and user-defined predicates are also allowed. 
3. Const ra in t - sa t i s fac t ion  a lgor i thm 
Since every disjunction in a JAUNT program has a 
finite number of choices, its satisfiability problem can 
be formulated as a constraint satisfaction problem over 
a finite donlain (sometimes called a consi.~tenl-htbeling 
problem (Men\[snarl 1974)). Much effort has been de  
voted to developing efficient algorithms for this prob 
lea.  
Two such algorithms are employed in JAUNT.  Ore, 
is the constrainl propagation algorithm (Mackworth 
1977), which is activated when a new constraint is 
added by addc statements. The constraint propaga- 
tion algorithm runs in polynomial time, and eliminates 
locally inconsistent vMues from the choice points and 
propagates the results to the neighboring constraints. 
The constraint propagation algorithm usually reduces 
the size of the search space significantly. 
The other algorithm used in JAUNT is the forward- 
checking Mgorithm (Haralick &E l l io t t  1980), which 
is triggered by the execution of a special f ind  s tat~ 
meat. It is essentially a back-tracking algorithm, but 
it prunes unpromising branches whenever temporal 
choices are made, thus significantly reducing the size 
of the remaining search space. 
This section describes in detail the constraint propa- 
gation Mgorithm used in JAUNT.  Re'0ders are referred 
to Hentenryck (1989) for the forward-checking algo- 
rlthm. 
3.1 Internal representat ion  of  constraints 
Bob)re describing the Mgorithm in detail, let us ex- 
plain the internal representation of the constraints, hi 
a compiled \[nodule of a JAUNT program, a disjunc- 
tion is represented by a data structure called a Choice 
Point (CP). A CP maintains a list of ptJssible values 
(called a domain) at the time of program execution. 
When a new constraint is added by a addc statement, 
the constraint is represented internally ms a conslrrint 
ms\[lisa For example~ assume that W is bound to 
\[gr={~loc ,posttaod~}, mod--{Y,0, lY,}\]. 
W?gr and W?mod are represented internMly a.~ CPs 
whose domain size is two. Then, when the constraints 
(2) are evaluated, a new two-dlmensional constraint 
matrix is created between the two CPs, as shown in 
Figure 3. 
Each dimension of the constraint matrix corresponds 
to a CP. The elements indicate whether the particn- 
lar combination of the CP vMues is legal (1) or illegal 
(0). For example, W?gr=loc and W?mod=O satisfies the 
constraint and hence the corresponding element in the 
matrix is 1. 
If another adds statement is then executed declar- 
ing that ttm value combination of W?gr=pontraod and 
W?mod=l is illegal, the corresponding element in the 
matrix is changed to 0, yielding the matrix shown in 
Figure 4. 
W?g( W?rnod 
Figure 3: Constraint matrix 
W?~lr W?rnod 
\[ {~IoC pOS 
Figure 4: Updated constraint matrix 
Suppose that the executioll of art adde statement 
referring to 7t different CPs XhX2,... ,Xn reveals 
that the value combhtation < xl,x~,...:x,~ > is il- 
legal. JAUNT first locates an n dimensional con 
straint matrix connected to X1,X2,...,X=, and set 
its element corresponding to the value combination 
< xi, x2, ..., x,~ > to 0. If there is no such constraint 
matrix, JAUNT creates a new one whose elements are 
all 1 except for the element of < xl,x~,...~x,, > that 
is set to 0. 
8.2 Constraint propagation 
The ba.sie idea of constraint propagation is to re 
mow~' locally inconsistent values from the, choice points 
and to reduce their domain size before a back tracking 
search is performed. 
\[n the example ~d)ove, let us consider the row 
af W?gr=postraod in the constrah\[t matrix. When 
i~?gr=postmod~ the elements of the matrix are zero, 
whatew~r value W?mod Lakes. This means that there are 
no glnbal solutions with W?gr=postmod, and therefore 
this value can be safely removed fronl tim domain of 
the CP W?gr. Similarly, Id?rnod=l ca.n be removed from 
the domain of the CP W?raod. 
In general, when a particular row or column (or 
plane or hyperplaue, if the dimension is greater th~n 
two) contains all zero elements, the corresponding 
vMne zl of CP X can  never participate in ~ solutimt 
(see Figure 5). Therefore, a'i can be eliminated frmn 
the domaitt of X. Whenever a constraint matrix is 
updated~ JAUNT searches for a. hyperplane whose ele~ 
ale/Its are all zero aud relnoves the corresponding v~thle 
from its domain. This may updrrte other constraint 
matrices conllected to l he C.P~ and may cause rabies 
in other CPs to be elhninated. Thus, updates are prop- 
agated ow~r the network of constraints until the entire 
network reaches a stable state. 
For every hyperplane in a constraint matrix, JAUNT 
ACTUS DE COLING-92. NAbrrES, 23-28 AO(Yr 1992 1 l 6 4 PROC. OF COLING-92, NANIES, AUG. 23-28, 1992 
X\Y  ... 
xi 0 (I 0 ... 0 
Figure 5: Locally innonsistent value a:i 
suppo.\[~3\[\] 
Numtmr of I's 
ill the plal~ 
\[ ~ 3/~ ~ 
suppo~\[Xl\[l 
Figurt+ 6: Support 
keeps the current number of t's on that plane, called 
the support (see Figure 6). When a certain element 
of a constraint matrix apl)ears to be inconsistent a,s a 
result of the evaluation of addc statement, he curre 
sponding support in each dimensiun is decremented. 
When a value in a CP is removed by constraint prop 
station, the carrespondlng hyperplaue of every con 
straint matrix connected to the (11' is removed, attd 
the result is reflected i~( all tt~e support values in the 
matrix. This algorithm is a uatnral extension of Mohr 
and Henderson's arc-c(msistency algorithm (Mohr & 
Henderson 1986) for allowing n:ary constraints. 
The cmnputathmal complexity of our constralut 
propagation algorithm is hounded by O(eIMD, where 
IMI is the siz,~ of the constraint matrices and e is the 
number of the cunstraint matrices, becattse at lemst 
oue element in st)me matrix is changed to 0 from I for 
every iteration of constraint propagatiom If the con 
str~ints are Iocal~ that is, if the arity of each ennstraint 
is bounded by a small integer, this time bound is a 
polynomial of the number of disjunctions. 
Our algorlthnr tries to maintain h,cal consistency 
ix( the sense that it runs(tiers only one eonstr+dnt ma 
trix at. +t time. This is a generalization of the notion 
called am consistency (Mackworth 1977) or pair-wise 
cousisteucy, and is equlva\]ent tn the flrst two steps 
of Ka.sper's (1987) successive aptnvximatimL Algo 
rithms for achieving more global consistency by look: 
ins at mnltlple constraint matrices are possibh+, but as 
Carter (1990) argues in his paper on the experimen. 
tal Propane parser, once pair-wise consistencies have 
been achieved, peffurnling a backtrack search is usu- 
ally more efficient than using higher-level consistency 
algorithms. In JAUNT, a forward:checking algorithm, 
which is far better than the traditional backtracking 
algorithms (Haraliek & Elliot 1980), is provided for 
generating global solutions, if necessary, although th\[~ 
intended use of JAUNT is to combine constraint prop 
agation with the recta-inference d scribed in the uexl 
section~ rather than t() perfornl a search. 
There hay,' t~en attl!nlpts to formulate natural an- 
guage pro,:essing as a cunstraiut satisfaction prob- 
lenl with broader don~ains (fl~r example, the Herbraud 
domain). CIL (Mukai 1988) and cu=Pmh)g (Tsuda, 
ltasida & Sirai 1(.189) are examples of such atteuipts. 
There is a trade-off between the expressive power and 
the COmlmtatiunal complexity, aml we argue that linite 
donlaius have sutticient expressive power while retain: 
ing the couqmtational eflicieucy implied by the algu+ 
rithms described above. 
4.  Meta : in fe rence  
A cunsiM,(~nt- \ ]at)e l l iLg pr( )b l ( !n l  uLay or nlay not  have 
a solution. I f  it ha_s role, it is most probable that there 
are multiple solutions. In fax:l, it+ the glven constraints 
are lint 'tight' enough tu narrow down the uumber uf 
soh l t i t l l i S  to  (Hit? o r  a few!  the  prohhml Ill~l,y have  an  eX  
ponential number of solntions. This situatlon is com- 
mon hL natural anguage processing. Strict grammars 
canse analysis failures for grammatical sentelt{;(~s~ i)n 
the other hand, lnose graulmars pruduce a combinato 
rially explosive number oF parse trees fin' certain types 
of sentence. 'lb avoid this situation, cnnstrahits shouhl 
be dynamically added aud remuw~d according to the 
size of the stdul.iut( space+ hi uther words, a constraint 
solver shunhl tm provided with a means of watching 
its own infl~rence process and changing its strategy ac= 
cord(us to tim observati<m. 
To set>purl the metaAnference apability~ JAUNT 
provides the following built in functions: 
1. i ncous is tentp( )  ... Non-NULl, wilen JAUNT 
detects i ncD l ts l s tenc ies  bf~tweell co l t s t ra in ts  
2. saveS(ate()  ... Save the current status of con- 
straint sat(slant(us 
g. loadState()  ... lLestore the saved status of con-. 
straint satisfactiuu. 
lu JAUN'I'~ tire state of the constraint:satisfaction 
process is deJined ms the set of all choice points and all 
cosstraint nlatrices. Oth,~r statuses bUlC\]I mS global aud 
local variables, the prograln couuter+ ;utd the coutrol 
stack are l in t  saved I sn applications (If cmlstraints nan 
be uadone without distilrbing the c<uttrul l .w. 
Meta inh~renc,~ is nonletlntes perh~rmed in an exter 
hal nlodule. JAUNT has interqm)cess crassus(ca- 
tion primitiw~s hmm~d on UNIX so<:kets. With these 
met;uinference apalfilities, an independent inference 
process timing ext.ernal knuwh~dge can tilt)ill(or and iIi- 
terveneln a JAUNT progra.nt. If it detects an incon- 
sistency, it instructs the JAUNT i>rogram to go b.'u:k 
tu the previous inferenc\[~ state and try another set of 
constraints; if it finds thai the solution spa~:e is not 
small enough+ it may giw~ new constraints from its own 
knowledge source. By separating the rneta-inference 
module from tile object-level JAUNT program, modu- 
larity \[)f knowledge is ;whieved. 
As an application <>f the meta:inference apability, 
let us describe the interactive Japanesp parser of the 
Japanese t<FEnglish m;u:hine translation system JETS 
(Maruyama, Watanabe, & Oginn 1990). The systmn 
structure is shown in Figure 7. Tim morphological 
A(:rl~s BE COL1NG+92, NANTES, 23-28 ^ O(JT 1992 1 1 6 S Pron. oi: COLING-92, Nm,n'zs, AUG. 23-28, 1992 
Fignre 7: Analysis p~rt of JETS 
\[~ord_id=O, 
string="ANATh", 
modifieeffi{~1,2,3,4~}, 
lex={~, \[part_of_speech=pronoun, sf={hum}\], 
\[part _of _speech=noun, sf={loc}\] 
%), 
Figure 8: Input feature structure 
analyzer analyzes an input sentence using a type-3 
grarl'lln&r and creates a feature structure that COll- 
talus disjunctions for lexieal and attachment ambigu- 
ities (Figure 8). The syntactic analysis program writ- 
ten in JAUNT applies grammatical constraints based 
on Constraint Dependency Grammar to these choice 
points and sends the result to a user-interlace run- 
ning on a separate machine. The amblguons choice 
points (those with domain size> 1) are highlighted on 
the screen, and the end user can select an appropri- 
ate value for some of them. This information is sent 
back to the JAUNT program through the inter-process 
communication channel and applied in the form of new 
constraints. This iteration is written in JAUNT as fed- 
lows; 
Uif := opon(Client~ame,"socket") ; 
while true begin 
send(U/f ,S) ; 
X := read(Ui f ) ;  
if X==goAhead then break; 
saveStato() ; 
addc S. (X.id)?mod==X.mod; 
if /nconsistentp() then begin 
send(Uif,"inconsistency detected") ; 
l oadStateO ; 
end; 
end; 
Thus, h* JETS, the end nser acts as an external know\[ 
edge source to guide the inference process of the pro- 
gram. 
SHALT2, an experimental English-to-Japanese ma- 
chine translation system currently being developed at 
IBM's Tokyo Research Laboratory, has a similar sys- 
tem structure (Nagao 1990). Instead of user interac- 
tion, an external example ba.~e built from an exist- 
ing corpus is used for resolving attachment amblgui- 
ties in SHAUF2. Thus, clear modularization ofgeneral 
syntactic/semantic knowledge from domain-dependent 
example-based knowledge is achieved. 
5. Conc lus ion  
We have described a constraint solver for efficiently 
processing ambi~nlties in natural anguage sentences. 
Disambignation is dntm by dynamically adding new 
constraints while the constraint satisfaction algorithm 
mainteoius local consistency. The system is actually 
bnldemented and used in two macl6ue translatiun sys- 
tems. 
References 
1. Carter, I}., 1990. "Efficient Disjunctive Unification for 
Bottom-Up Parsing," COLING '90. 
2. Church, K. and Patti, R., 1982 "Coping with Syntactic 
Ambiguity, or llow to Put the Block m the Box on the 
Table." Arne*-tcan d. of Compulattonal Linguistics 8. 
3. llaralick, M. and Elliott, G. 1,., 1980, "lnerea~sing Tree 
Search Efficiency for Constraint Sittisfaction Prob- 
lems," Arhficial Intelligence 1~. 
4. llentenryck~ P. V., 1989, Constraint Satisfaction In 
Logic Programming, MIT Press. 
5. Karttunen, L., 1984, "FcaUtres and Values~" COL1NG 
'8q. 
6. Ka.sper, R. T., 1987, "A Unification Method for 
Dis.Inactive Feature I}escriptions," 25lh ACL Annual 
Meeting. 
7. Kasper, IL T., and Rounds, W. C., 1986, "A Logical 
Semantics for Feature Structures," 2Jth ACL Annual 
Meeting. 
8. Mackworth~ A. K., 1977, "Consistency m Networks of 
ll.elation," Artificial lntelhgence 8. 
9. Maruyama, 11., 1990, "StmlcUtral )isambiguation 
with Constraint Propagation," 28th ACL Annual 
Meelin 9. 
10. Maruyama, H., 1991, "Constraint I)ependency Gram 
mar and Its Weak Generative Capacity," Advances in 
Software Science and Technology 3. 
11. Maruyama, H., Watanabe, 11., and Ogino, S., 1990, 
"An Interactive Japanese Parser for Machine 'lYansla- 
tion," COLING '90. 
12. Montanari, U., 1974, "Networks of Constraints: Fun- 
damental Properties and Applications to Picture Pro 
cessing," Information Science 7. 
13. Mohr, R. and llenderson, T., 1986, "Arc and Path 
Consistency Revisited," Artificial Intelligence 28. 
14. Mukai, K. 1988, "Partially Specified Term in Logic 
Programming for IAnguistic Analysis," International 
Conference on Fifth Generation Computer Systems, 
Tokyo. 
15. Nagao, K, 1990~ "Constraints and Preferences: In- 
tegrating Grammatical nd Semantic Kimwledge for 
Structural )isambiguation," Pacific Rim Interna- 
tional Conference on Al, Nagoya. 
16. Se,, J. and Simmons, R. 1988, "Syntactic Graphs: a 
Representation for the Union of All Ambiguous Parse 
Trees," Computational Linguistics 15 
17. Tsuda, 11., llasida, K., and Sirai, I1., 1989, "JPSG 
Parser on Constraint Logic Programming," 4th ACL 
European Chapter. 
18. Younger, D. H., 1967, "Recognition and Parsing of 
Context-Free Languages in time nO, '' Information and 
Control 10. 
ACRES DE COLING-92, NANTEs, 23-28 Ao~r 1992 I 1 6 6 PRec. OF COLING-92. NANTES, AUG. 23-28, 1992 
