Const ra in t -Based  Categor ia l  Grammar  
Gosse  Bouma and  Ger t jan  van  Noord  
Alfa- informatica nd 
Behavorial  and Cognitive Neurosciences, 
Ri jksuniversiteit  Groningen 
{gosse,vannoord} @let.rug.nl 
Abst rac t  
We propose a generalization f Categorial Grammar in 
which lexical categories are defined by means of recur- 
sive constraints. In particular, the introduction of re- 
lational constraints allows one to capture the effects of 
(recursive) lexical rules in a computationally attractive 
manner. We illustrate the linguistic merits of the new 
approach by showing how it accounts for the syntax of 
Dutch cross-serial dependencies and the position and 
scope of adjuncts in such constructions. Delayed evalu- 
ation is used to process grammars containing recursive 
constraints. 
1 In t roduct ion  
Combinations ofCategorial Grammar (co) and unifica- 
tion naturally lead to the introduction of polymorphic 
categories. Thus, Karttunen (1989) categorizes NP's as 
X/X, where x is a verbal category, Zeevat el al. (1987) 
assign the category X/(NP\X) to NP's, and Emms (1993) 
extends the Lambek-calculus with polymorphic ate- 
gories to account for coordination, quantifier scope, and 
extraction. 
The role of polymorphism has been restricted, how- 
ever, by the fact that in previous work categories were 
defined as feature structures using the simple, non- 
recursive, constraints familiar from feature description 
languages such as PATR. Relational constraints can be 
used to define a range of polymorphic ategories that 
are beyond the expressive capabilities of previous ap- 
proaches. 
In particular, the introduction of relational con- 
straints captures the effects of (recursive) lexical rules 
in a computationally attractive manner. The addition 
of such rules makes it feasible to consider truly 'lexical- 
ist' grammars, in which a powerful exical component 
is accompanied by a highly restricted syntactic ompo- 
nent, consisting of application only. 
2 Recurs ive  Const ra in ts  
In cG, many grammatical concepts can only be de- 
fined recursively. Dowty (1982) defines grammatical 
functions uch as subject and object as being the ul- 
timate and penultimate 'argument-in' of a verbal cate- 
gory. Hoeksema (1984) defines verbs as exocentric at- 
egories reducible to s. Lexical rules frequently refer to 
such concepts. For instance, a categorial lexical rule 
of passive applies to verbs electing an object and must 
remove the subject. 
In standard unification-based formalisms, these con- 
cepts and the rules referring to such concepts cannot be 
expressed irectly. 
2.1 Sub jec t -verb  agreement  
Consider a categorial treatment of subject-verb agree- 
ment with intransitive ( NP\[NOM\]\S ) and transitive 
((NP\[NOM\]\S)/NP\[ACC\]) verbs defined as follows: 
(1) lez(walks,X):- 
iv(X). 
/ez(kisses, X) :- 
tv(X). 
vat\[  eat s \] 
iv( dir'\' 
arg \[ catnp \] )" 
case nora 
iv( 
val 
dir '/' 
vat\[ cats \] 
dir '\' 
arg \[ cat np \] 
case nom 
arg \[ cal np \] 
case  aCE 
Subject-verb agreement can be incorporated easily if 
one reduces agreement to a form of subcategorization. 
147 
If, however, one wishes to distinguish these two pieces of 
information (to avoid a proliferation of subcategoriza- 
tion types or for morphological reasons, for instance), it 
is not obvious how this could be done without recursive 
constraints. For intransitive verbs one needs the con- 
straint that (arg agr) = Agr (where Agr is some agree- 
ment value), for transitive verbs that (val arg agr) = 
Agr, and for ditransitive verbs that (val val arg agr) = 
Agr. The generalization is captured using the recursive 
constraint sv_agreement (2). In (2) and below, we use 
definite clauses to define lexical entries and constraints. 
Note that lexical entries relate words to feature struc- 
tures that are defined indirectly as a combination of 
simple constraints (evaluated by means of unification) 
and recursive constraints. 1 
(2) lex(walks, X) :- 
iv(X), 
sv_agreement( sg3 , X). 
lex(kisses, X) :- 
tv(X), 
sv_agreement( sg3 , X). 
sv-agreement(Agr' \[ cat np \] agr Agr \S). 
sv_agreement( Agr , Y \X  ) :- 
sv_agreement( Agr , X). 
Relational constraints can also be used to capture 
the effect of lexical rules. In a lexicalist theory such 
as cG, in which syntactic rules are considered to be 
universally valid scheme's of functor-argument combi- 
nation, lexical rules are an essential tool for capturing 
language-specific generalizations. As Carpenter (1991) 
observes, some of the rules that have been proposed 
must be able to operate recursively. Predicative forma- 
tion in English, for instance, uses a lexical rule turning 
a category reducible to vP into a category reducing to 
a vP-modifier (vP\vP).  As a vP-modifier is reducible 
to vP, the rule can (and sometimes must) be applied 
recursively. 
2 .2  Ad juncts  as  a rguments  
Miller (1992) proposes a lexical rule for French nouns 
which adds an (modifying) adjective to the list of argu- 
ments that the noun subcategorizes for. Since a noun 
1We use X/Y  and Y\X  as shorthand for dir ' / '  
arg Y 
and dir ' , respectively and S, NP, and Adj as 'typed 
arg Y 
variables' of type \[ cats \], \[ cat np \], and \[ cat adj \], 
respectively. 
can be modified by any number of adjectives, the rule 
must be optional as well as recursive. The advantages 
of using a lexical rule in this case is that it simplifies 
accounting for agreement between ouns and adjectives 
and that it enables an account of word order constraints 
between arguments and modifiers of a noun in terms of 
obliqueness. 
The idea that modifiers are introduced by means of 
a lexical rule can be extended to verbs. That is, ad- 
juncts could be introduced by means of a recursive rule 
that optionally adds these elements to verbal categories. 
Such a rule would be an alternative for the standard cat- 
egorial analysis of adjuncts as (endocentric) functors. 
There is reason to consider this alternative. 
In Dutch, for instance, the position of verb modifiers 
is not fixed. Adjuncts can in principle occur anywhere 
to the left of the verb: 2 
(3) a. dat Johan opzettelijk een ongeluk 
that J. deliberately an accident 
veroorzaakt 
causes 
that J. deliberately causes an accident 
b. dat Johan Marie opzettelijk 
that J. M. deliberately 
geen cadeau geeft 
no present gives 
that J. deliberately gave M. no present 
There are several ways to account for this fact. One 
can assign multiple categories to adjuncts or one can 
assign a polymorphic ategory x /x  to adjuncts, with x 
restricted to 'verbal projections' (Bouma, 1988). 
Alternatively, one can assume that adjuncts are not 
functors, but arguments of the verb. Since adjuncts are 
optional, can be iterated, and can occur in several posi- 
tions, this implies that verbs must be polymorphic. The 
constraint add_adjuncts has this effect, as it optionally 
adds one or more adjuncts as arguments to the 'initial' 
category of a verb: 
(4) iex(veroorzaken, X):- 
add_adjuncts(X, NP\ (NP \S)). 
lex(geven, X) :- 
add_adjuncts(X, NP\ (NP\ (NP\S) ) ) .  
add_adjuncts(S, ). 
add_adjuncts(Adj \X, Y) :- 
add_adjuncts(X, Y). 
add_adjuncts( dir D , dir D ) :- 
arg A arg A 
add_adjuncts(X, Y). 
2As we want to abstract away from the effects of 'verb- 
second', we present only examples of subordinate clauses. 
148 
This constraint captures the effect of applying the 
following (schematic) lexical rule recursively: 
(5) xl\...\xi\x,+l\...\s/Y1...Y, 
# 
XI  \ . . . \X ikAd jkX i+ l  \ .  . . \S /Y1 .  . . Y .  
The derivation of (3a) is given below (where X =~ Y 
indicates that add_adjuncts(Y,X) is satisfied, and IV ---- 
NP\S). 
(6) . . .  J. opzetteli jk een ongeluk 
NP ADJ NP 
veroorzaakt 
NP\IV 
NP\ (ADJ\IV) 
ADJ\IV 
IV 
S 
An interesting implication of this analysis is that in 
a categorial setting the notion 'head' can be equated 
with the notion 'main functor'. This has been pro- 
posed by Barry and Pickering (1990), but they are 
forced to assign a category containing Kleene-star op- 
erators to verbal elements. The semantic counterpart 
of such category-assignments is unclear. The present 
proposal is an alternative for such assignments which 
avoids introducing new categorial operators and which 
does not lead to semantic complications (the semantics 
of add_adjuncts is presented in section 3.3). Below we 
argue that this analysis also allows for a straightforward 
explanation of the distribution and scope of adjuncts in 
verb phrases headed by a verbal complex. 
3 Cross -Ser ia l  Dependenc ies  
In Dutch, verbs selecting an infinitival complement (e.g. 
modals and perception verbs) give rise to so called cross- 
serial dependencies. The arguments of the verbs in- 
volved appear in the same order as the verbs in the 
'verb cluster': 
(7) a. 
b. 
dat An1 Bea2 will kussen~. 
dat An Bea wants to kiss 
that An wants to kiss Bea 
dat An1 Bea2 Cor3 Will 
dat An Bea Cor wants 
zien2 kussen3. 
to see kiss 
that An wants to see Bea kiss Cor 
The property of forming cross-serial dependencies is 
a lexical property of the matrix verb. If this verb is a 
'trigger' for cross-serial word order, this order is obliga- 
tory, whereas if it is not, the infinitival complement will 
follow the verb: 
(8) a. *dat An wil Bea kussen. 
b. dat An zich voornam Bea 
that An Refl. planned Bea 
te kussen. 
to kiss 
that An. planned to kiss Bea 
e. *dat An zich Bea voornam te kussen. 
3 .1  Genera l i zed  D iv i s ion  
Categorial accounts of cross-serial dependencies ini- 
tially made use of a syntactic rule of composition 
(Steedman, 1985). Recognizing the lexical nature of 
the process, more recent proposals have used either a 
lexical rule of composition (Moortgat, 1988) or a lexical 
rule of 'division' (Hoeksema, 1991). Division is a rule 
which enables a functor to inherit the arguments of its 
argument :3
X/Y  ::?, (X /Z ,  . . . IZ , , ) I (Y /Z .  . . IZ , )  
To generate cross-serial dependencies, a 'dishar- 
monic' version of this rule is needed: 
(9) x/v  (zA... z.\x)/(zA.. ,  z.\Y) 
Hoeksema proposes that verbs which trigger cross- 
serial word order are subject to (9): 
(10) . . .An  Bea wil kussen 
NP NP IV/IV NP\IV 
# 
(NP\IV)/(NP\IV) 
NP\IV 
IV 
In a framework using recursive constraints, gener- 
alized disharmonic division can be implemented as a 
recursive constraint connecting the initial category of 
such verbs with a derived category: 
(11) lez(willen,X) :- 
cross_serial(X, (NP\S) / (NP\S) ) .  
lez(z ien,  X) :- 
cross_serial(X, (NP\ (NPkS)) / (NP\S) ) .  
lez(voornemen,  (NPre fl \ (NP \S) ) / (NP  \S)). 
aArgument inheritance is used in HPSG to account for 
verb clustering in German (Hinrichs and Nakazawa, 1989). 
The rlPSG analysis is essentially equivalent to Hoeksema's 
account. 
149 
(12) cross_serial(Out,In) :-
division(Out, In), 
verb_cluster(Out). 
division(X, X) .  
division(  Z \X  ) / ( Z \  Y ), X '  /Y ' )  :- 
division(X/Y, X ' / Y') .  
\[ \[ + \] \] ) 
Only verbs that trigger the cross-serial order are sub- 
ject to the division constraint. This accounts immedi- 
ately for the fact that cross-serial orders do not arise 
with all verbs selecting infinitival complements. 
3 .2  Verb  C lus ters  
The verb_cluster constraint ensures that cross-serial 
word order is obligatory for verbs subject to 
cross_serial. To rule out the ungrammatical (8a), for 
instance, we assume that Bea kussen is not a verb clus- 
ter. The verb kussen by itself, however, is unspecified 
for vc, and thus (7a) is not excluded. 
We do not assume that cross-serial verbs take lexical 
arguments (as has sometimes been suggested), as that 
would rule out the possibility of complex constituents o 
the right of cross-serial verbs altogether. If one assumes 
that a possible bracketing of the verb cluster in (7b) is 
\[wil \[zien kussen\]\] (coordination and fronting data have 
been used as arguments that this is indeed the case), 
a cross-serial verb must be able to combine with non- 
lexical verb clusters. Furthermore, if a verb selects a 
particle, the particle can optionally be included in the 
verb cluster, and thus can appear either to the right or 
to the left of a governing cross-serial verb. For a verb 
cluster containing two cross-serial verbs, for instance, 
we have the following possibilities: 
(13) a. dat An Bea heeft durven aan 
that An Bea has dared part. 
te spreken 
to speak 
that An has dared to speak to Bea. 
b. dat An Bea heeft aan durven te spreken. 
c. dat An Bea aan heeft durven te spreken. 
A final piece of evidence for the the fact that cross- 
serial verbs may take complex phrases as argument 
stems from the observation that certain adjectival and 
prepositional rguments can also appear as part of the 
verb cluster: 
(14) dat An dit aan Bea had duidelijk 
that An this to Bea has clear 
gemaakt 
made 
thai An had made this clear to Bea 
Cross-serial verbs select a +vc  argument. Therefore, 
all phrases that are not verb clusters must be marked -
vc. In general, in combining a (verbal) functor with its 
argument, it is the argument hat determines whether 
the resulting phrase is -vc. For instance, NP-arguments 
always give rise to -VC phrases, whereas particles and 
verbal arguments do not give rise to -vc phrases. This 
suggests that NP's must be marked -vc, that particles 
and verbs can remain unspecified for this feature, and 
that in the syntactic rule for application the value of 
the feature vc must be reentrant between argument 
and resultant. 
3 .3  The  d is t r ibut ion  and  scope  o f  
ad juncts  
The analysis of cross-serial dependencies in terms of 
argument inheritance interacts with the analysis of ad- 
juncts presented in section 2.2. If a matrix verb inherits 
the arguments of the verb it governs, it should be pos- 
sible to find modifiers of the matrix verb between this 
verb and one of its inherited arguments. This prediction 
is borne out (15a). However, we also find structurally 
similar examples in which the adjunct modifies the gov- 
erned verb (15b). Finally, there are examples that are 
ambiguous between a wide and narrow scope reading 
(15c). We take it that the latter case is actually what 
needs to be accounted for, i.e. examples uch as (15a) 
and (15b) are cases in which there is a strong prefer- 
ence for a wide and narrow scope reading, respectively, 
but we will remain silent about the (semantic) factors 
determining such preferences. 
(15) a. dat Frits Marie volgens mij lijkt 
that F. M. to me seems 
te ontwijken. 
to avoid 
It seems to me that F. avoids M. 
b. dat Frits Marie opzettelijk lijkt 
that F. M. deliberately seems 
te ontwijken. 
to avoid 
It seems that F. deliberately avoids M. 
c. dat Frits Marie de laatste tijd lijkt 
that F. M. lately seems 
te ontwijken. 
to avoid 
It seems lately as if F. avoids M. 
It seems as if F. avoids M. lately 
On the assumption that the lexical entries for lijken 
en ontwijken are as in (16), example (15c) has two possi- 
ble derivations ((17) and (18)). Procedurally speaking, 
the rule that adds adjuncts can be applied either to the 
matrix verb (after division has taken place) or to the 
150 
governed verb. In the latter case, the adjunct is 'inher- 
ited' by the matrix verb. Assuming that adjuncts take 
scope over the verbs introducing them, this accounts 
for the ambiguity observed above. 
(16) lex(lijken, Verb):- 
add_adjuncts(Verb, Verb'), 
cross_serial(Verb', (NP\S)/(NP\S)). 
lex(ontwijken, Verb):- 
add_adjuncts(Verb, NP\(NP\S)). 
(17) ... de laatste tijd lijkt 
ADJ IV/IV 
te ontwijken 
TV 
TV/TV 
(AD&TV)/TV 
ADJ\TV 
TV 
(18) ... de laatste tijd lijkt te ontwijken 
ADJ IV/IV TV 
(ADJ\TV)/(ADJ\TV) ADJ\TV 
ADJ\TV 
TV 
The assumption that adjuncts cope over the verbs 
introducing them can be implemented as follows. We 
use a unification-based semantics in the spirit of Pereira 
and Shieber (1987). Furthermore, the semantics is 
head-driven, i.e. the semantics of a complex constituent 
is reetrant with the semantics of its head (i.e. the func- 
tor). The feature structure for a transitive verb in- 
cluding semantics (taking two NP's of the generalized 
quantifier type ((e, t), t} as argument and assigning wide 
scope to the subject) is: 
(19) 
val 
dir 'V 
arg \[ 
\[ cat s \] 
dir 'V 
\[ cat np \] ar9 sem (X^Sobj)^Ss,,bj 
cat np \] 
sem (Y^kiss(X,V))ASobj 
sem Ssubi TV 
Thus, a lexical entry for a transitive verb can be de- 
fined as follows (where TV refers to the feature struc- 
ture in 19): 
(20)/ez(kussen, X) :- 
add_adjuncts(X, TV). 
The lexical rule for adding adjuncts can now be ex- 
tended with a semantics: 
(21) add_adjuncts(\[ sem Sx \ ]x '  \[ sem Sy \]y) :- 
add_adj(X, Y, Sx, Sy). 
add_adj(S, S, Sem, Sem). 
val X 
dir 'V add_adj( 
arg \[ 
add_adj(X, 
cat adj \] 
sere Sy^SA 
Y, Sx, Sa). 
,Y, Sx, Sy):-  
\[va, x\] \[va, Y\] 
add_adj( dir D , dir D ,Sx,Sr)  :- 
arg A arg A 
add_adj(X, Y, Sx, Sy). 
Each time an adjunct is added to the subcategoriza- 
tion frame of a verb, the semantics of the adjunct is 
'applied' to the semantics as it has been built up so far 
(Sy), and the result (SA) is passed on. The final step in 
the recursion unifies the semantics that is constructed 
in this way with the semantics of the 'output' category. 
As an adjunct A1 that appears to the left of an adjunct 
A2 in the string will be added to the subcategoriza- 
tion frame of the governing verb after As is added, this 
orders the (sentential) scope of adjuncts according to 
left-to-right word order. Furthermore, since the scope 
of adjuncts is now part of a verb's lexical semantics, 
any functor taking such a verb as argument (e.g. verbs 
selecting for an infinitival complement) will have the 
semantics of these adjuncts in its scope. 
Note that the alternative treatments ofadjuncts men- 
tioned in section 2.2 cannot account for the distribution 
or scope of adjuncts in cross-serial dependency con- 
structions. Multiple (i.e. a finite number of) catego- 
rizations cannot account for all possible word orders, 
since division implies that a trigger for cross-serial word 
order may have any number of arguments, and thus, 
that the number of 'subcategorization frames' for such 
verbs is not fixed. The polymorphic solution (assigning 
adjuncts the category x/x) does account for word or- 
der, but cannot account for narrow scope readings, as 
the adjunct will always modify the whole verb cluster 
(i.e the matrix verb) and cannot be made to modify an 
embedded verb only. 
4 Processing 
The introduction ofrecursive lexical rules has repercus- 
sions for processing as they lead to an infinite number 
of lexical categories for a given lexical item or, if one 
151 
considers lexical rules as unary syntactic rules, to non- 
branching derivations of unbounded length. In both 
cases, a parser may not terminate. One of the main 
advantages of modeling lexical rules by means of con- 
straints is that it suggests a solution for this problem. 
A control strategy which delays the evaluation of con- 
straints until certain crucial bits of information are filled 
in avoids non-termination a d in practice leads to gram- 
mars in which all constraints are fully evaluated at the 
end of the parse-process. 
Consider a grammar in which the only recursive con- 
straint is add_adjuncts, as defined in section 2.2. The 
introduction of recursive constraints in itself does not 
solve the non-termination problem. If all solutions 
for add_adjuncts are simply enumerated uring lexical 
look-up an infinite number of categories for any given 
verb will result. 
During processing, however, it is not necessarily the 
case that we need to consider all solutions. Syntactic 
processing can lead to a (partial) instantiation of the 
arguments of a constraint. If the right pieces of infor- 
mation are instantiated, the constraint will only have a 
finite number of solutions. 
Consider, for instance, a parse for the following 
string. 
(22) ... J. opzettelijk een ongeluk veroorzaakt 
NP ADJ NP Verb 
NP\(ADJ\IV) 
ADJ\IV 
NP\S 
S 
Even if the category of the verb is left completely 
open initially, there is only one derivation for this string 
that reduces to S (remember that the syntax uses appli- 
cation only). This derivation provides the information 
that the variable Verb must be a transitive verb select- 
ing one additional adjunct, and with this information 
it is easy to check whether the following constraint is 
satisfied: 
add_adjuncts(NP\(ADJ\(NP\S) ), NP\(NP\S)). 
This suggests that recursive constraints should not be 
evaluated during lexical look-up, but that their evalu- 
ation should be delayed until the arguments are suffi- 
ciently instantiated. 
To implement this delayed evaluation strategy, we 
used the block facility of Sicstus Prolog. For each re- 
cursive constraint, a block declaration defines what the 
conditions are under which it may  be evaluated. The 
definition of add_adjuncts (with semantics omitted for 
readability), for instance, now becomes: 
(23) add_adjuncts(\[ arg Arg \ ]x ,Y )  :- 
add_adjuncts(X, Y, Arg). 
? - block add_adjuncts(?,?,-). 
add_adjuncts(S, , _). 
add_adjuncts(Adj \X,  Y,  _) :- 
add_adjuncts(X, Y). ivy, x\] \[w,Y\] add_adjuncts( dir D , dir D ,.A.) :- 
arg A arg A 
add_adjuncts(X, Y). 
We use add_adjuncts~2 to extract the information 
that determines when add_adjuncts/3 is to be evalu- 
ated. The b lock declaration states that add_adjuncts/3 
may only be evaluated if the third argument (i.e. the 
argument of the 'output' category) is not a variable. 
During lexical ook-up, this argument is uninstantiated, 
and thus, no evaluation takes place. As soon as a verb 
combines with an argument, the argument category of 
the verb is instantiated and add_adjuncts~3 will be eval- 
uated. Note, however, that calls to add_adjuncts~3 are 
recursive, and thus one evaluation step may lead to an- 
other call to add_adjuncts~3, which in its turn will be 
blocked until the argument has been instantiated suffi- 
ciently. Thus, the recursive constraint is evaluated in- 
crementally, with each syntactic application step lead- 
ing to a new evaluation step of the blocked constraint. 
The recursion will stop if an atomic category s is found. 
Delayed evaluation leads to a processing model in 
which the evaluation of lexieal constraints and the con- 
struction of derivational structure is completely inter- 
twined. 
4.1 Other strategies 
The delayed evaluation techniques discussed above can 
be easily implemented in parsers which rely on back- 
tracking for their search. For the grammars that we 
have worked with, a simple bottom-up (shift-reduce) 
parser combined with delayed evaluation guarantees 
termination of the parsing process. 
To obtain an efficient parser more complicated search 
strategies are required. However, chart-based search 
techniques are not easily generalized for grammars 
which make use of complex constraints. Even if the the- 
oretical problems can be solved (Johnson, 1993; DSrre, 
1993) severe practical problems might surface, if the 
constraints are as complex as the ones proposed here. 
As an alternative we have implemented chart-based 
parsers using the 'non-interleaved pruning' strategy 
(terminology from (Maxwell III and Kaplan, 1994)). 
152 
Using this strategy the parser first builds a parse-forest 
for a sentence on the basis of the context-free backbone 
of the grammar. In a second processing phase parses 
are recovered on the basis of the parse forest and the 
corresponding constraints are applied. This may be ad- 
vantageous if the context-free backbone of the grammar 
is 'informative' nough to filter many unsuccessful par- 
tial derivations that the parser otherwise would have to 
check. 
As clearly a CUG grammar does not contain such an 
informative context-free backbone a further step is to 
use 'selective feature movement' (cf. again (Maxwell III 
and Kaplan, 1994)). In this approach the base gram- 
mar is compiled into an equivalent modified grammar 
in which certain constraints from the base grammar are 
converted to a more complex context-free backbone in 
the modified grammar. 
Again, this technique does not easily give good results 
for grammars of the type described. It is not clear at all 
where we should begin extracting appropriate features 
for such a modified grammar, because most information 
passing is simply too 'indirect' to be easily compiled 
into a context-free backbone. 
We achieved the best results by using a 'hand- 
fabricated' context-free grammar as the first phase of 
parsing. This context-free grammar builds a parse for- 
est that is then used by the 'real' grammar to obtain ap- 
propriate representation(s) for the input sentence. This 
turned out to reduce parsing times considerably. 
Clearly such a strategy raises questions on the rela- 
tion between this context-free grammar and the CUG 
grammar. The context-free grammar is required to pro- 
duce a superset of the derivations allowed by the CUG. 
Given the problems mentioned above it is difficult to 
show that this is indeed the case (if it were easy, then it 
probably would also be easy to obtain such a context- 
free grammar automatically). 
The strategy can be described in somewhat more de- 
tail as follows. The context-free phase of processing 
builds a number of items defining the parse forest, in a 
format hat can be used by the second processing phase. 
Such items are four-tuples 
(R, Po,P,n) 
where R is a rule name (consistent with the rule names 
from the CUG), P0, P are string positions and D de- 
scribes the string positions associated with each daugh- 
ter of the rule (indicating which part of the string is 
covered by that daughter). 
Through a head-driven recursive descent he second 
processing phase recovers derivations on the basis of 
these items. Note that the delayed evaluation tech- 
nique for complex constraints is essential here. Alter- 
native solutions are obtained by backtracking. If the 
first phase has done a good job in pruning many failing 
search branches then this is not too expensive, and we 
do not have to worry about the interaction of caching 
and complex constraints. 
5 F ina l  Remarks  
In sections 2 and 3 we have sketched an analysis of 
cross-serial dependency constructions and its interac- 
tion with the position and scope of adjuncts. The 
rules given there are actually part of a larger frag- 
ment that covers the syntax of Dutch verb clusters 
in more detail. The fragment accounts for cross- 
serial dependencies and extraposition constructions (in- 
cluding cases of 'partial' extraposition), infinitivus-pro- 
participio, modal and participle inversion, the position 
of particles in verb clusters, clitic climbing, partial vp- 
topicalization, and verb second. In the larger fragment, 
additional recursive constraints are introduced, but the 
syntax is still restricted to application only. 
The result of Carpenter (1991) emphasizes the impor- 
tance of lexical rules. There is a tendency in both CG 
and HPSG to rely more and more on mechanisms ( uch 
as inheritance and lexical rules or recursive constraints) 
that operate in the lexicon. The unrestricted generative 
capacity of recursive lexical rules implies that the re- 
maining role of syntax can be extremely simple. In the 
examples above we have stressed this by giving an ac- 
count for the syntax of cross-serial dependencies (a con- 
struction that is, given some additional assumptions, 
not context-free) using application only. In general, 
such an approach seems promising, as it locates the 
sources of complexity for a given grammar in one place, 
namely the lexicon. 
References  
Guy Barry and Martin Pickering. 1990. Dependency 
and coordination i  categorial grammar. In G. Barry 
and G. Morrill, editors, S~udies in Categorial Gram- 
mar. University of Edinburgh. Edinburgh Working 
Papers in Cognitive Science 5. 
Gosse Bouma. 1988. Modifiers and specifiers in cate- 
gorial unification grammar. Linguistics, 26:21-46. 
Bob Carpenter. 1991. The generative power of cat- 
egorial grammars and head-driven phrase structure 
grammars with lexical rules. Computational Linguis- 
tics, 17(3):301-313. 
Jochen DSrre. 1993. Generalizing earley deduction for 
constraint-based grammars. In Jochen Do~rre, edi- 
tor, Computational Aspects of Constraint-Based Lin- 
guistic Description. Dyana-2 Deliverable R1.2.A. 
153 
David R. Dowty. 1982. Grammatical relations and 
montague grammar. In Pauline Jacobson and Ge- 
offrey Pullum, editors, The Nature of Syntactic Rep- 
resentation, pages 79-130. Reidel, Dordrecht. 
Martin Emms. 1993. Parsing with polymorphism. In 
Sixth Conference of the European Chapter of the As- 
sociation for Computational Linguistics, pages 120- 
129. 
Erhard Hinrichs and Tsuneko Nakazawa. 1989. Flipped 
out: AUX in German. In Papers from the 25th 
Annual Regional Meeting of the Chicago Linguistic 
Society, pages 187-202. Chicago Linguistics Society, 
Chicago. 
Jack Hoeksema. 1984. Categorial Morphology. Ph.D. 
thesis, Groningen University. 
Jack Hoeksema. 1991. A categorial theory of reanalysis 
phenomena, ms. RUG Groningen. 
Mark Johnson. 1993. Memoization in constraint logic 
programming. Paper presented at the First Work- 
shop on Principles and Practice of Constraint Pro- 
gramming, April 28-30, Newport, Rhode Island. 
Lauri Karttunen. 1989. RadicM lexicalism. In Mark R. 
Baltin and Anthony S. Kroch, editors, Alternative 
Conceptions of Phrase Structure, pages 43-65. Uni- 
versity of Chicago Press. 
John T. Maxwell III and Ronald M. Kaplan. 1994. The 
interface between phrasal and functional constraints. 
Computational Linguistics, 19(4):571-90. 
Philip Miller. 1992. Clitics and Constituents in Phrase 
Structure Grammar. Garland, New York. 
Michael Moortgat. 1988. Categorial Investigations. 
Ph.D. thesis, University of Amsterdam. 
Fernando C.N. Pereira and Stuart M. Shieber. 1987. 
Prolog and Natural Language Analysis. Center for 
the Study of Language and Information Stanford. 
Mark Steedman. 1985. Dependency and coordination 
in the grammar of Dutch and English. Language, 
61:523-68. 
Henk Zeevat, Ewan Klein, and Jo Calder. 1987. Uni- 
fication categorial grammar. In Nicholas Haddock, 
Ewan Klein, and Glyn Morrill, editors, Categorial 
Grammar, Unification Grammar and Parsing. Cen- 
tre for Cognitive Science, University of Edinburgh. 
Volume 1 of Working Papers in Cognitive Science. 
154 
