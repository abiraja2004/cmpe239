SYSTEM DEMONSTRATION 
NATURAL LANGUAGE GENERATION WITH ABSTRACT MACHINE 
Evgen iy  Gabr i lov ich  and  N iss i rn  F rancez  
Computer Science Department 
Technion, Israel Inst i tuteof  Technology 
32000 Haifa, Israel 
{gabr,  f rancez}~cs ,  t echnion,  ac. i l  
Shu ly  Wintner  
Seminar fiJr Sprachwissenschaft 
Universit~it Tiibingen 
72074 Tiibingen, Germany 
shuly?sf s. nphi i. uni-tueb ingen, de 
Abstract" 
We present a system for Natural Language Generation based on an Abstract Machine ap- 
proach. Our abstract machine operates on grammar s encoded in a unification-based Typed 
Feature Structure formalism, and is capable of both generation and parsing. For efficient gener- 
ation, grammars are first inverted to a suitable form, and then compiled into abstract machine 
instructions. A dual compiler translates the same input grammar into an abstract machine 
program for parsing. Both generation and parsing programs are executed under the same 
(chart-based) evaluation strategy: This results in an efficient, bidirectional (parsing/generation) 
System for Natural Language Processing. Moreover, the system possesses ample debugging fea- 
tures, and thus can serve as a user-friendly environment for bidirectional grammar design and 
development. 
1 Overv iew 
An input for the generation 1 task is a logical form which represents a meaning, and a grammar to 
govern the generation process. The output consists of one or more phrases in the language of the 
grammar whose meaning is (up to logical equivalence) the given logical form. 
The system robe  demonstrated applies an Abstract.Machine (AM) approach for Natural Lan- 
guage Generation, within the framework of Typed Feature Structures (Carpenter, 1992b). Such a 
machine is an abstraction over an ordinary computer, lying somewhere between regular high-level 
languages and common hardware architectures. Programming an Abstract Machine has proved 
-fruitful in previous research, reaching a peak as a highly efficient echnique to build Prolog compil- 
ers (Ait-Kaci, 199!). 
AMALIA 2 has two compilers of grammars into Abstract Machine instructions; the outputs of 
compilation are AM programs which perform either chart generation or chart parsing, both accord- 
ing to the given grammar. Both tasks use an auxiliary table (chart) to store intermediate processing 
results..AMALIA has a uniform core engine for bottom-up chart processing, which interprets the 
given (abstract machine ) program, and realizes the generation or parsing task. In the  case of gen- 
eration it is the given semantic meaning whose components are consumed in the process. The only 
differences between the two processing directions are in the nature of chart items and interpretation 
o f  the final results. Thereby, AMALIA makes dual use of its chart and forms a complete bidirectional 
natural language system, which is considered an advantage in the literature (Strzalk0wski, 1994). 
The system is capable of very efficient processing, since grammars are precompiled irectly into 
abstract machine instructions, which are subsequently executed over and over. 
lln this work we mean by "generation" what is sometimes known also as "syntactic generation". Thus, no text. 
plannin$, speaker intentions and the like are considered here. / 
2The acronym stands for "Abstract MAchine for Llnguistic Applications". .. 
276 
Logical forms specified as meanings by input grammars are given in a so-called predicate- 
argument structure a. Thus, meanings are built from basic units (feature structures), each having 
a predicate and (optionally) a number of arguments. Our approach also allows ,k-abstractions 
over predicate-argument constructs, as well as systematic encoding of second- and higher-order 
functions. 
Grammars are usually designed in a form oriented towards the analysis of a string and not 
towards generation from a (usually nested) semantic form. In other words, rules reflect the phrase 
structure and not the predicate-argument structure. It is therefore useful to transform the grammar 
in order to enable systematic reflection of any given logical form in the productions. For this 
purpose, we apply to the input grammar an inversion procedure, based upon 4 (Samuelsson, 1995), 
to render tile rules with tile nested predicate-argument structure, corresponding to that of input 
logical forms. The resultant "inverted" grammar is thus more suitable for performing the generation 
task. Once the grammar is inverted, the generation process can be directed by the input semantic 
form; elements of the input are consumed uring generation just like words are consumed uring 
parsing. Grammars must satisfy certain requirements in order for them to be invertible. However, 
ttle requirements are not overly restrictive and allow encoding of a variety of natural language 
grail\] mars. 
Grammar inversion is performed prior to compilation for generation. The given grammar is 
enhanced in a way that will uhimately enable to reconstruct the words spannedby the semantic 
forms. To achieve this aim, ea.ch rule constituent is extended by an additional special-purpose 
feature. The value Of this feature for tile rule's head is set to the concatenation of its values in the 
body constituents, to reflect the original phrase structure of the rule. 
Figure 1 delineates an overview of AM-based generation. After the grammar is inverted, it is 
compiled into the abstract machine code. At run time, the given logical form is decomposed into 
meaning components, which initialize the AM chart, and then the generation program is invoked. If 
generation terminates, it yields a (possibly empty) set of feature structures; a grammar-independent 
post-processing routine an'alyzes these structures and retrieves the generated phrases per se. 
G ~Inversion }
Logical 
form "---r - - /  I AN 
smoke (john) 
<john, Smoke> 
-1 
,,j 
AMALIA 
sm, 
"John" "smokes" 
"John 
okes" 
Figure h An overview of generation with Abstract Machine. 
This outline only contains a brief description of software features and capabilities. For a theo- 
retical background on using an abstract machine for Natural Language Parsing refer to (Wintner 
and Francez, 1995; Wintner, 1997). (Gabrii0vich, 1998) gives more details on Natural Language 
Generation with Abstract Machine. (Wintner, Gabrilovich, and Francez, 1997a) describes ,4MALIA 
3The predicate-argument structure is analogous to the familiar representation Of semantic logical forms with 
first-order terms. 
4Samuelsson's inversion algorithm was originally developed for definite clause grammars. We adapted it to the 
Typed Feature Structure formalism. 
277 
as a unified platform for parsing and generation, elaborating more on the way the two directions 
are integrated into a single system. 
2 .AMALIA functionality 
.AMALIA operates On input grammars encoded in a subset of the ALE specification language (Car- 
penter , 1992a) In particular, .AMALIA supports the same type hierarchies as ALE does, with exactly 
the same specification syntax. This means that the user can specify any bounded-complete partial 
order as the type hierarchy. In contrast to ALE, .AMALIA allows appropriateness loops in the type 
hierarchy. On the other hand, .AMALIA does not support ype constraints and relational extensions. 
.AMALIA uses a subset of ALE's syntax for describing totally well-typed, possibly cyclic, non- 
disjunctive feature structures. Set values, as in ALE, are not supported, but list values are..AMALIA 
does not respect he distinction between intensionol and extensional types (Carpenter, 1992b, 
Chapter 8). Also, feature structures cannot incorporate inequality constraints. 
?4MALIA supports macros in a similar way tO:ALE. The syntax is the same, and macros can have 
parameters or call other macros (though not recursively, of course). ALE'S special macros for lists 
are supported by AMALIA. Lexical rules are not supported in this version of AMALXA..AMALIA'S 
syntax for pliraze structure rules is similar to ALE'S, with the exception of the cats> specification 
(permitting a list of categories in the body of a rule) which is not supported. ?4MALIA uses ALE'S 
syntax in describing lexical entries, and allows disjunctive lexical entries, separated by semicolons. 
? .AMALIA is implemented in ANSI-C, augmented by, lea: and yacc to implement the input acquisi- 
tion module , and Tcl/Tk to build the graphical user interface. The application is compatible with 
a variety Of platforms, such as SUN and SILICON GRAPHICS workstations running UNIX operating 
system, as well as IBM PC running V~rlNDOWS'95 and LINUX. For a detailed escription and a 
complete user's guide of AMALIA refer to (Wintner, Gabrilovich, and Francez, 1997b). 
? There are two versions of .AMALIA: an interactive, user-friendly program with a graphical user 
interface, and a non'interactive but more efficient version for batch processing. The former program 
provides extensive debugging capabilities, and is ideally suited for developing reversible grammars. 
Figure 2 presents a sample snapshot of the program screen. In the case of generation, the 
"Input string" field specifies the name of the query file, which contains (an ALE description of) a 
feature structure representing the input semantic form. In this example, the query file encodes the 
logical form Vx(man(x)--, dream(z)); the feature structure for this query is shown in the figure over 
the main program screen. The "Messages" window displays the phrases generated (if any). The 
feature structures that encode these phrases are also displayed graphically, in separate windows 
(not shown in the figure). In the case of parsing, the "Input string" field contains the word string 
to be parsed, and the program eventually displays feature structures assigned to this string by the 
parser (if any). 
References 
Ait-Kaci, Hassan. 1991. Warren's Abstract Machine:A Tutorial Reconstruction. The MIT Press. 
Carpenter, Bob. 1992a. ALE- the attribute logic engine: User's guide. Technical report, Laboratory for 
? Computational Linguistics, Philosophy Department, Carnegie Mellon University, Pittsburgh, PA. 
Carpenter,? Bob. 1992b. The Logic of Typed Feature Structures. With Applications to Unification Grammars, 
Logic Programs and Constraint Resolution. Cambridge University Press. 
" 278 
m 
,W 
! ! i :~b ~i~i..;:~i .:::!?!.i~;~!: ;; - !?~i!.!!: :.~:!':;! .::.~!Speetal Purpose:Reg! t~?~;~i~.~it~.:-i ~r:~ff?;~b~i~?i?:;~z : ::i!'!.':::~ 
::.:.::,~i,:~b::..::. . . .  ~: :~ .." . :<.~?..> "- ~ :.~:: ~;~!:~:~. ... .. -" --.~ " J.,~:'.~:;!'T/.:?..~2::i~;::~;~;<!:~i~:~'~:i~::::;~.~ :;.:: ,!::~iL: f::.:: ::  :::~ 
" '~ '~ l s le r~ ~:: ..~:.:,.~ : ~ ~,-:  ...... ~ IE~P"  ~:~.~-~ . . . . . . . .  .:,.- :: .. :. : .~.~ r~<..,,-.~.:: ~,.~:: :P ro  ~ Code.~... ,~-c :, .- .:~ ; .......... 
iXS . !046  : 19 .  STR l-b;lrld ::- - i  ~: ;=-~:-:~:::~:~=~-:-:':-::~"~.~:=::7:;c.:r:-"-::-:;'-':'= . ....... ::-: '::--~ ~
II~4 " : 1047  : ? 20:--.. "REF"22 .  ': :. '::;".:: . , i  ~ ~ t~ I~z .  
I l xs  : : .~o4s. :!~: 2 \ ] . :  ::~REF: ~S~,:. : ' .:i'i~:--. .-:.::~. ~ '"iiii!C.~ii:i~ ..J!!!~L~:?~:!:ii!:~:::~it:-.::.:::.::.! .i :.:.:~: :: 
': ' "' : ~ i  : " " T " " " " " : " " ~ " ?:i:>::~m~2./:L. '  \[z'/\] ~, , -  .::?~::~' ,.~ .":.., . ? ' : -  i ~. I~ . . . .  : zos~ . .~ ..... ~2: -..s R a t~ c._\].:~ . - ;  ~ .:...,:,,:.,.,..:,,,~.:~:.,. ..... ~1!! 
Ilx7 " : : :Z  ~,,:.!~ ! 23 :  .... REF. 26  i ::.~i.:.. r l :~  " -:::::~:::;:i!:~.:i:::;ii:i!ii:.:i\[13l:'l~l{i!!::.) .>::  . : : : : : : : -  - : . : : " : . . . . ! . '~  
" . ? ~ ,';'.",: ? . . . . . .  . ? .: ? ~ ? .-..::: .i, ... :".. -: ? i " ..:.. .:.~ .. " ? ":.-'~-. ~i ~:~ l ira : . -1  :{s 24 :  RE~ 27 . .  -1  ~;~. : ...:.::.-. . . . . .  , '~,, - : . . . . : : : : \ [4TI:n:-  . . . . . . .  ? ~ 
" . " - ~,'~ " " " , " ~:~.  : - .  ? i -  ~-~ ~. - - : .  i .~ .  : . . : .  ,~==~=' , - - - -~- - : -  . . . . . . . . . . . .  .= . . i~  Ik9 : - - I  .,~ 25: "REF 27 ..... . ? ? .. - I ~  . : : : .  ! . . . . . . . .  : ..-. 122\] at~ra le  I I : :  ? ~ I :~  ? ? :,~,.~ . . . . ~ .~ : . : . . .  : . . : : . . .~  ' . . . : ,  ~ , : .~ . , .  . . . .  . .- ~ 
I k lo  : .... -1  ~ . ~6: STR.mn. -  .... ? . . . .  1 .~ : ~;~ ::::~-;:~:~.~ . . .  ~.".:~:i~-.":.".-. ~ i~  ? ". " ~,~ ? ? " . . . .  . ~ " " " .  :: ~ . . : "  "V:).. ~ " . ' : L  ~'T~.:  -~. : :'-LE.-Z..L..~:7.i .i- :~ ? I IX l t  : " -1  ~,~ -27 :  STR sem : -1  ,.~. p~,~-.::: ..- ~: : ; ' , - i . " . : . , . . : r ;~q .. I  ~il::~ 
I t xn . : .  -~  i~  ~s :  "STR l _b ind  . :  . :1  ! !~! " : : : " : :~ : : : ! :  " : " :  ~~"~: ~"! :  : : : : !~:~L: !  ' ~ i :  
Itx   " ' REF 31 " -1  ~! i " :,,..: :.:.,:'i. :. : .~ : . , ' i~r . : :  t t~ l  j- . . .- I . i i l :~. 
I1X14 :. : : :1  i.~:~ i ? 30 :  "REF 36  " ' i  ~.i! " ' .:':(:::::::ii!~:i'::":.!"i:::! :: ;i i " : ;  i : : ' : : : ! i~ \ ] -~: l~ l : : : -  iit:~: 
Ilx s : . - ;  i~i:~ '31 :  STR atorn i~L . :  ! -1  ~ i !  :::':~:?"'~.;!:.:i ' .i:.:~:~;i ~ ' : : " : : )~?: ) : ' : : : : ( ' . ' : :~~i i  
I!X16 : -1  i~!~. 32- REF  35 " : -1  ::i~ ..... '(:"" ,::":~! i ~'/z~" ..::?' ~v.':.-:l~'-~--~.: . i|~i~ 
ltx z. : ~3:  ' :REF- .27  " : . . :  -1  ~i :~'' :.::_":,iii.:;~::~.::'::-i:: ::~ " ..... : :? . : : i "~: : : :~ . .  . ~!  
I I v  . " (" -~ . " ? " " P{  " : " " " . : : .  : - , : :.~,~ :~ ? : -"  .~ : :%~' - :  ? l . tEg .2_ . . J  : ,  ~ ,"~: X18 ' . -~1 ,;;. 34 .  REF 27  . . . .  1 ~. -. .~.~__..:::.:.::"," _~==. . ....... ~ ~  .. . . . . . . .  ~ ...... ~iil:::! 
X19  : -1 .  '/!~{ 35 : .  STRdream .: . : .  -1  ~ i~ 'z~t :  . : : . " : i~i~:: . : ! . :  ~ . . : : '  
X20  : ' : -1  . ~ 36 :  :STR arg=2 '-  :.. ,1  : :~ \ ]e .~ %::,~. ~7~: ;  . i  .. ' . .  ======================================================== ~ 
? , . .  --:.-: " Messages  ". ==================================== . - :  .:':. ::..: .::!::,!i:":'i::"::. .,./:. .: : ' " . 
, ~  ~,  a i~y~a. . .  . ? : .  " " ? . . . .  :..'. :::"-::.",'~;~::~.~::, '. ' :. -~'!~!~: :::-. : -  : .: :'," I~ '  
e~e~'3~ ~an drca . '~s  " " - ? " :: " . . . .  ' :  ": ; : ' ? ,  " " :=~~" '  : : ' !  " : J I~  
Figure 2: A sample screen shot of.AMALIA. 
Gabrilovich, Evgeniy. 1998. Natural language generatio n by abstract machine for typed feature structures. 
Master's thesis, Technion, Israel Institute of Technology, Haifa, Israel. In preparation. 
Samuelsson, Christen 1995. An efficient algorithm for surface generation. In Proc. of the 14th Int'l Joint 
Conference on Artificial Intelligence, Montreal, Canada, pp. 1414-1419. Morgan Kaufmann, August. 
Sirzalkowski, Tomek, editor. 1994. Reversible Grammar in Natural Language Processing. The Kluwer Inter- 
national Series in Engineering and Computer Science. Kluwer Academic Publishers, The Netherlands. 
Wintner, Shuly. 1997. An Abstract Machine for Unification Grammars. Ph.D. thesis, Technion, Israel ? 
Institute of Technology, Haifa, Israel, January. 
Wintner, Shuly and Nissim Francez. 1995. An abstract machine for typed feature structures. In Proc. of the 
5th Workshop on Natural Language Understanding and Logic Programming, pp. 205-220, Lisbon, May. 
Wintner, Shuly, Evgeniy Gabrilovich, and Nissim Francez. 1997a. AMALIA - a unified platform for parsing 
and generation. In R. Mitkov, N. Nicolov, and N. Nicolov, editors, Proc. of "Recent Advances in Natural 
Language Processing" (RANLP'97), pp. 135-142, Tzigov Chark, Bulgaria, September. 
Wintner, Shuly, Evgeniy Gabrilovich, and Nissim Francez, 1997b. AMALIA - Abstract MAchine for Lin- 
guistic Applications - User's Guide. Laboratory for Computational Linguistics, Computer Science De- 
parmtent, Technion, Israel Institute of Technology, Haifa, Israel, June, 
279  
