Denotational Semantics for "'Natural'" 
Language Question-Answering Programs 1 
Michae l  G. Ma in  2 
Dav id  B. Benson  
Depar tment  of  Computer  Sc ience  
Wash ington  Sta te  Un ivers i ty  
Pu l lman,  WA 99164-1210 
Scott-Strachey style denotational semantics is proposed as a suitable means of commu- 
nicating the specification of "natural" language question answerers to computer program- 
mers and software engineers. The method is exemplified by a simple question answerer 
communicating with a small data base. This example is partly based on treatment of 
fragments of English by Montague. Emphasis is placed on the semantic interpretation of 
questions. The "meaning" of a question is taken as a function from the set of universes to 
a set of possible answers. 
1. Introduction 
We advocate the use of Scott-Strachey denotational 
semantics for "natural" language question-answering 
programs. The majority of this paper demonstrates 
the use of denotational semantics for a small question 
answerer. The types of questions possible are similar 
to those in Harris (1979), Winograd (1972), and 
Woods (1972). The analysis is not as deep as in Kart- 
tunen (1977) or similar studies, as it is oriented to the 
specification of useful, but linguistically modest, capa- 
bilities. 
Before the demonstration, we discuss the benefits 
of formal semantics and why denotational semantics is 
an appropriate formalization. The semantics of a 
question answerer is given by defining the action of 
the program for each possible input. An informal 
semantic description, perhaps in narrative form, is 
necessary for a potential user who wants to know what 
questions he may ask and what sort of answers the 
program will provide. Informal meanings are also 
valuable to the designer and implementer of a question 
answerer. However, the designer and implementer 
must understand all aspects of a proposed question 
answerer in a precise unambiguous way that informal 
1 This research was supported in part by NSF grants 
MCS7708486 and MCS8003433. 
2 Current Address: Department of Computer Science, Uni- 
versity of Colorado, Boulder, CO 80309. 
methods do not provide. In short, a formal method of 
specifying the semantics is needed at the design and 
implementation stage (see Ashcroft and Wadge 1982). 
Once a formal semantics has been given, it can be 
put to other uses as well. It can provide the basis for 
a rigorous proof of correctness of an implementation. 
Furthermore, formal specifications might allow partial 
automation of the implementation process in the same 
way that automatic ompiler-writers produce parts of a 
compiler from a formal specification of a programming 
language (see Johnson 1975). With the advent of at 
least one commercially available "natural" language 
question-answering program (Harris 1979), these ad- 
vantages become even more concrete. 
If there is a familiarity to these arguments, it is 
because the same reasoning is used to justify formal 
semantics for programming languages. The problems 
of design and analysis of question answerers are much 
the same for programming languages - Benson (1975) 
argues this point at length. An obvious approach is to 
apply a programming language technique - denotation- 
al semantics - to the problem of formally specifying a 
question answerer. As a bonus, the method is under- 
stood by many programmers and software engineers 
through introductory textbooks such as Stoy (1977), 
Gordon (1979), McGettrick (1980), Pagan (1981), 
and Tennent (1981). Additionally, linguistic treat- 
ments of natural language, such as Montague (1973), 
are basically denotational and we can modify such 
Copyright 1983 by the Association for Computational Linguistics. Permission to copy without fee all or part of this material is granted 
provided that the copies are not made for direct commercial dvantage and the Journal reference and this copyright notice are included on 
the first page. To copy otherwise, or to republish, requires afee and/or specific permission. 
03 62-613X/83/010011-11 $03.00 
American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 11 
Michael G. Main and David B. Benson Denotational Semantics for 'Natural' Language Q-A Programs 
treatments to meet our needs. 
In denotational semantics for programming lan- 
guages, evaluation functions map program segments 
into objects in various semantic domains. These ob- 
jects are taken as the meanings of the program seg- 
ments, and determine the output of a program. Simi- 
larly, in the semantics of a question answerer, evalua- 
tion functions map input (questions) into objects that 
determine the output (answers). 
Deciding what objects are in the semantic domains 
has a fundamental  effect on the capabilities of the 
overlying question answerer, as well as an effect on 
the usefulness and clarity of the semantic descriptions. 
Lewis (1972) discusses these considerations for natu- 
ral language sentences and the domains described in 
section 2 are based on his, although the treatment of 
questions is closer to Ajdukiewicz (1926). Also intro- 
duced in section 2 are the lambda expressions that 
denote individual semantic objects. Such expressions 
have been used in denotational semantics of program- 
ming languages (see Scott 1970, Milne and Strachey 
1976, Stoy 1977) and in treatments of fragments of 
English by Montague (1973). 
In section 3, evaluation functions mapping inputs 
for a small question answerer to objects in the seman- 
tic domain are given. The allowable questions are 
defined by a category grammar as has been done by 
Ajdukiewicz (1935), Carnap (1937), Lewis (1972), 
Montague (1973), and others. An account of the 
answer relationship is given in section 4. 
In the final section, we briefly describe an imple- 
mentation of the question answerer and suggest some 
broad principles for designing question answerers. 
2. Semantic Domains for Natural Language 
2.1 The Domains 
A semantic domain is a set of objects. The objects are 
meanings of syntactic constructs; in our case the syn- 
tactic constructs are natural language phrases. In de- 
notational semantics for programming languages, the 
semantic domains often have some order imposed on 
the objects to treat recursively defined functions. The 
specification of a question answerer may also involve 
explicit recursively defined questions, although in this 
demonstration only quantification is used and not re- 
cursion. This does not prevent an implementat ion 
from using recursion - almost surely it will, to handle 
the quantification. But lack of recursion does allow us 
to use unordered semantic domains, as described be- 
low. 
One domain is the set of objects about which ques- 
tions will be asked, e.g., moon rocks, toy blocks, or 
whatever. We are not concerned with the internal 
structure of these objects; hence they are called atoms 
and the domain is designated A. Two other domains 
are the set of natural numbers, designated N, and the 
set of truth values {true, false}, designated T. 
A fourth domain is the set of possible universes, 
designated U. Intuitively, a universe is a description 
of properties of atoms, the relationships between at- 
oms, the relationships between relationships, etc .... A 
universe is usually a partial description including only 
the properties and relationships of interest. For exam- 
ple, in the toy blocks world (Winograd 1972) a uni- 
verse is the specification of the size, shape, color, and 
position of all the blocks in the scene. A toy blocks 
universe does not include a description of the density, 
mass, or material composition of the various blocks. 
In application, the set of possible universes may be 
called a "data base",  and each actual universe is a 
specific state or configuration of the data base. The 
internal structure of such a data base is left unspeci- 
fied in this paper. 
Other semantic domains are built from the four 
basic domains. For example, the set of functions from 
universes to truth values, designated \[U--T}, is a new 
domain. In general, if X and Y designate sets, then 
\[X--Y} designates the set of functions from X to Y. 
Other semantic domains could be conceived (e.g., 
product or sum domains), but function domains will be 
adequate for our examples. 
2.2 Assigning domains to syntactic categories 
Natural language phrases have been divided into many 
different categories (see Kahn 1978). Exactly which 
categories are used depends upon syntax. In the cate- 
gory grammar of section 3, the categories include sen- 
tence, intransitive verb, common noun, noun group, 
noun modifier, numeral, and so on. There are also 
separate interrogative categories for phrases that ask a 
question, such as how many stones. 
To each syntactic category, a semantic domain is 
assigned. The meaning of a phrase is an object in the 
assigned domain. Ultimately, from the meaning of a 
question, we will derive its answer. But first we assign 
domains to non-interrogative categories, beginning 
with the category of sentences. 
A declarative sentence is a proposition - that is, 
something to which a truth value can be assigned. The 
meaning of a sentence somehow determines what that 
truth value is in any possible universe. So, an appro- 
priate semantic object for a sentence is a function 
from possible universes to truth values. The domain 
assigned to the category of sentences is therefore 
\[U--T}, which we will designate S. If a declarative 
sentence has a meaning a E S, and/3 is a universe, then 
a/3 is true just if the sentence is true in the universe/3.3 
3 Lower case Greek letters are semantic objects. Juxtaposi- 
tion indicates functional application and associates left-to-right. 
Thus, a/3 means the function a applied to the argument /3, and a/37 
means (a(/3))(),). 
12 Amer ican  Journa l  of Computational Linguistics, Volume 9, Number 1, January-March 1983 
Michael G. Main and David B. Benson Denotational Semantics for "Natural" Language Q-A Programs 
If there is a single fixed universe, then sentences could 
be assigned meanings in T alone. However, question 
answerers are generally based on a changeable uni- 
verse or data base. Hence, the \ [U- -T\ ]  approach is 
needed to give a fixed meaning to a sentence whose 
truth value may vary from universe to universe. 
Both common nouns and intransitive verbs define 
subsets of A. The subset of stone (a common noun) is 
the set of atoms that are stones. The subset for the 
intransitive verb phrase belong to Preston is the set of 
atoms that belong to Preston. The meaning of such a 
phrase determines what that subset is for any possible 
universe. This can be done by an object in 
\[U-~\[A-~T\]\] (i.e., functions from U to \[A--T\]) .  This 
domain is assigned to both common noun and intransi- 
tive verb categories, and is designated by C. If a com- 
mon noun has a meaning a e C, and/3 is a universe and 
3' an atom, then a/33' is true just if ~, is in the subset 
defined by the common noun in the universe /3 - and 
similarly for intransitive verbs. 
For most other syntactic categories, the semantic 
domain is determined by how phrases in that category 
combine with sentences, common nouns, intransitive 
verbs, and other phrases to form new phrases. For 
example, a noun group combines with an intransitive 
verb to form a sentence. Therefore, a semantic object 
for a noun group should take a semantic object from C 
(the domain for intransitive verbs) and yield a seman- 
tic object from S (the domain for sentences). Thus, 
the semantic domain for noun groups is \[C-~S\]. 4 
Similarly, a noun modifier, such as black, combines 
with a common noun, such as stone, to form a new 
common noun - black stone. So, the semantic domain 
for noun modifiers is \[C--C\].  By examining the syn- 
tactic rules, this method can be applied to most cate- 
gories. 5 Occasional exceptions can be made - for 
example, numerals are assigned the domain, N, of 
natural numbers. 
2.3 Interrogative categories 
So far, the categories include only non-interrogative 
phrases. Syntactically, the interrogative phrases paral- 
lel the non-interrogatives, but semantically an interro- 
gative lacks something. For example, Ajdukiewicz 
(1926) would represent he meaning of the interroga- 
4 A name, such as John, is one type of noun group that de- 
notes a particular atom which does not change from universe to 
universe Therefore, it might be better to have names in a separate 
syntactic category with assigned semantic domain A. But, doing 
this would not do away with the category noun group, since some 
noun phrases are not names (e.g., every stone). But, having two 
categories unduly complicates the syntax, so we lump names togeth- 
er with other noun groups, and treat them as Montague (1973) has. 
5 This method of assigning semantic domains is an application 
of Frege's rule of compositionality, which says that the meaning of 
a compound phrase is composed from the meaning of its parts? 
(Frege 1892, van Emde Boas and Janssen 1979) 
tive sentence what is black and white and read all over 
as: ?x(x is black and white and read all over). Here, x 
is a variable and "?"  a quantifier indicating the lack. 
In this case, the range of the variable is the set of 
noun group phrases that could answer the question. 
There are also interrogative phrases in other cate- 
gories, such as the intransitive verb phrase owns what. 
And it is not always a noun group that is missing; for 
? example, the noun group how many stones lacks a nu- 
meral. In general, any non-interrogative category is 
made into an interrogative category by indicating what 
is lacking. Hence, if X and Y are non-interrogative 
categories, then X?Y designates the category of inter- 
rogative phrases that are syntactically like X-phrases 
but semantically lack a Y-phrase. 6 If Y has semantic 
domain Y and X has semantic domain X, then X?Y will 
have semantic domain \[Y--X\]. Furthermore,  if an 
interrogative phrase in X?Y has a meaning aE\[Y-~X\], 
then a/3 is that object of X that results when /3eY an- 
swers the interrogative. 
For example, the interrogative sentence who killed 
cock robin will have a meaning aE\ [ \ [C-~S\] - -S \ ] ,  since it 
is a sentence (domain S) lacking a noun group 
(domain \ [C- -S\ ] ) .  If the sparrow has a meaning 
/3t IC- -S \ ] ,  and the sparrow killed cock robin has a 
meaning 7ES, then a/3=~,. 
A similar idea can be applied to one other catego- 
ry: yes-no questions. Such an interrogative lacks a 
truth value, so the semantic domain assigned to yes-no 
questions is \ [T - -S \ ] .  If a t \ [T - -S \ ]  is the meaning of a 
yes-no question, then a(true)? S is the meaning of the 
sentence when it is answered by yes, and similarly for 
an a(false). 
2.4 Lambda expressions 
Up to this point, semantic objects have been described 
in English. In order to be more precise, a formal no- 
tation is needed. We use a typed lambda expression 
for denoting functions, similar to the lambda calculi of 
Church (1951). 
Every lambda expression has a type that indicates 
the semantic domain of the object denoted by the 
expression. These types are in one-to-one correspon- 
dence with the semantic domains (A, U, T, N, \[U-~T\], 
etc .... ), so we will use the same letters in ordinary 
typescript for the expression types (A, U, T, N, 
\[U-~T\], etc .... ). 
The expressions of each type include a set of con- 
stants and a denumerable set of variables. A function 
that maps the constants into semantic objects is an 
interpretation, and generally remains fixed. A func- 
tion that maps variables into semantic objects is a 
variable assignment and, as its name suggests, will 
6 This could be extended to include phrases, like who does 
what, which question more than one thing at a time. 
American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 13 
Michael G. Main and David B. Benson Denotational Semantics for "Natural' Language Q-A Programs 
change. If q, is a variable assignment, x is a variable 
of any type, and a is an object from the semantic do- 
main of x, then ~p\[a/x\] is a changed variable assign- 
ment that is like ~ except that q~\[a/x\] assigns a to the 
variable x. In this way, new variable assignments are 
formed from old. Finally, each lambda expression 
denotes one semantic object, but which object this is 
varies as the variable assignment changes. So, for an 
expression b the notation \[\[bll ~ is to denote the se- 
mantic object for the expression b, with variable as- 
signment ~p.7 
Table 1 gives recursive rules defining lambda ex- 
pressions and the semantic objects they denote. We 
take as given a set of constants and a denumerable set 
of variables for each type, and a fixed interpretation, 
q0. X and Y are arbitrary types, with corresponding 
semantic domains X and Y. 
Some lambda expressions can be derived more than 
one way. Any such ambiguities are resolved as fol- 
lows: 
a. The expression following a lambda abstraction (i.e., 
),x) or a quantifier (i.e., 3x, ?x, 3nx,) will be as 
long as possible - that is, to the first unmatched 
right parenthesis or to the end of the entire expres- 
sion. 
b. The unary operator -, has higher priority than any 
of the binary operators (A, V, =, =>, .-, >, and 
functional application, which is indicated by juxta- 
position). Functional application has the highest 
priority of the binary operators and associates left- 
to-right, e.g., bcd=(bc)d.  The other binary opera- 
tors have equal precedence and also associate left- 
to-right, e.g., bcAdcVc = ((bc)A(dc))Vc.  
3. Syntax  and Semant ics  of a Smal l  Quest ion  
Answerer  
3.1 Syntact ic  categor ies  
To illustrate the mechanics of the previous section, we 
give the syntax and semantics of a small question an- 
swerer. The question answerer accepts questions 
about configurations of pieces in the game of Go. 
Briefly, a configuration consists of a 19 by 19 grid of 
points, labeled A-1 through S-19. Each point may 
contain a black or a white stone. Like-colored stones, 
connected horizontally or vertically, form blocks. 
Empty points adjacent to a block are that block's lib- 
erties. Each configuration is a universe in the seman- 
tic domain U. 
The syntax for a question answerer must answer 
the question: what phrases are grammatically correct 
input to the question answerer? Our approach uses 
various syntactic categories, in the style of Montague 
(1973). A syntactic category is a set of phrases, in- 
cluding basic phrases and derived phrases. The de- 
rived phrases are specified by recursive syntactic rules 
that describe how phrases from various categories 
combine to form new phrases. 
The syntax presented here has two kinds of cate- 
gories. First, non- interrogative categories, whose 
phrases do not ask questions. These categories are 
listed in Table 2, along with an abbreviation for each, 
the lists of basic expressions, and the associated se- 
mantic domains from section 2. In the table, A - I ,  
A-2, and so on are names of points on the Go board. 
The basic phrases heo, he 1, they o, they 1, and so on are 
used as variables in a manner made precise by syntac- 
tic rules given later. 
The second kind of category is the interrogative 
category. Syntactically, an interrogative category be- 
haves like some non-interrogative category, but it also 
asks a question whose answer is from some other non- 
interrogative category. If a phrase is syntactically like 
a phrase from category X, and asks a question whose 
answer is in category Y, then that phrase is in a cate- 
gory X?Y. This separation of interrogatives i needed 
because the semantic domain for interrogatives differs 
from that for non-interrogatives (see section 2.3). 
One additional interrogative category does not follow 
the X?Y pattern - the yes-no questions. We designate 
this category YN and list it in Table 3 with the other 
interrogative categories. 
3.2 Syntact ic  and semant ic  rules 
We now give syntactic rules that define the phrases of 
each category. With each syntactic rule is a semantic 
rule. For each phrase that a syntactic rule creates, the 
corresponding semantic rule tells precisely how to 
translate that phrase into a lambda expression denot- 
ing the meaning of the phrase. In these rules, italic 
letters (u, v, w, ...) are arbitrary phrases from any 
category and F1, F2, ..., are functions that combine 
phrases to yield new phrases. Variables in lambda 
expressions are of the following types. 
? m,m' , . . .o f  type N. 
? t,t',.., of type T. 
? u,u',.., of type U. 
? x,x~,.., of type C. 
? y ,y '  .... of type \[C-~S\]. 
? qi is the (2i+3)th variable of type A. 
? Pi is the (2 i+4)th variable of type A. 
? z is the first variable of type A. 
? z '  is the second variable of type A. 
7 The semantic object associated with a lambda expression 
also depends on the interpretation function, but we assume this is 
fixed. 
14 American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 
Michael G. Main and David B. Benson Denotational Semantics for "Natural" Language Q-A Programs 
LAMBDA EXPRESSION SEMANTIC OBJECT 
1. If b is a constant of type X, then b is an expression 
of type X. 
2. If x is a variable of type X, then x is an expression 
of type X. 
3. If b is an expression of type X, then (b) is also an 
expression of type X. 
4. If b is an expression of type Y and x is a variable 
of type X, then ~x.b is an expression of type \[X--Y\] .  
5. If b is an expression of type \ [X- ,Y \ ]  and c is an 
expression of type X, then bc is an expression of type 
Y. 
6. If b and c are expressions of type X, then b = c is 
an expression of type T. 
7. If b and c are expressions of type T, then -, b, bAc, 
bVc, b~,c, and b<==>c are expressions of type T. 
8. If n is an expression of type N, then n+l  is an 
expression of type N. 
9. If b is an expression of type T and x is a variable 
of type X, then 3x.b and Vx.b are expressions of type 
T. 
10. If b is an expression of type T, x is a variable of 
type X and n is an expression of type N, then 3nx.b is 
an expression of type T. 
\[lbll ~ is q0b (i.e., the interpretation ~ applied to the 
constant b). 
II x II q~ is ~x (i.e., the variable assignment ~b applied to 
the variable x). 
II (b) II q~ is 11 b II ~. 
II ?,x.b II ~ is that function a:X- ,Y ,  such that for every 
~x,  ~/~ --- Ilbllq~\[/3/x\]. 
II bc II ff is the function II b \[1 ~k applied to the argument 
II c II q~. 
II b = c II ~ is true iff \[\[ b II ~ is the same semantic ob- 
ject as II c II ~. 
II-,b II q~ is true iff II b II q~ is false, and similarly for /X 
(and), V (or), ~ (implication), and <==> (coincidence). 
II n+ 1 II q~ is the natural number successor of II n II q~. 
113x.bll~ is true iff there exists an aEX, such that 
Ilbllq~\[~/x\] is true. IlVx.bllq~ is 11-,3x.-,bll~. 
Let n = II n II ~k. Then II 3nx.b II ~ is true iff there exist 
,/ distinct objects in X, so that for any of these ,/ ob- 
jects, say a, II b II q~\[~/x\] is true. 
Table 1. Lambda expressions and their semantic objects. 
American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 15 
Michael G. Main and David B. Benson Denotational Semantics for 'Natural Language Q-A Programs 
SYNTACTIC CATEGORY SEMANTIC DOMAIN & BASIC PHRASES 
SE (sentence) 
CN (common oun) 
IV  (intransitive verb) 
NG (noun group) 
TV (transitive verb) 
NM (noun modifier) 
MG (modifying roup) 
PP (preposition or participial) 
NU (numerals) 
S = \[U-*T\]. 
No basic phrases. 
C = \[U~\[A---T\]\]. 
player, block, stone, liberty, point 
C. 
exist 
\[c--s\]. 
Black, White, he o, he 1 ..... they o, they 1 ..... A- l ,  A-2 . . . .  
\[\[C--S\]--C\]. 
own, belong to 
\[C-~C\]. 
black, white 
\[C-~C\]. 
No basic phrases. 
\[\[C-- S\]-- \[C-- C\]\]. 
at, with, owning, belonging to 
N 
0 ,1 ,2  . . . .  
Table 2. Syntactic categories (non-interrogative). 
SYNTACTIC CATEGORY SEMANTIC DOMAIN & BASIC PHRASES 
YN (yes-no question) 
NG?NG (noun group questioning a noun group) 
For any two non-interrogative categories, X and Y, 
X?Y is an interrogative category. 
\[T-~S\]. 
No basic phrases. 
\[\[C--S\]-- \[C-~S\]\]. 
who, what 
\[Y-~X\], where X is X's domain and Y is Y's domain. 
None of these categories, except NG?NG, have basic 
phrases. 
Table 3. Syntactic categories (interrogative). 
16 American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 
Michael G. Main and David B. Benson Denotational Semantics for "Natural" Language Q-A Programs 
3.2.1 The basic rule 
Syntactic Rule: 
RI .  For each category, its basic phrases are phrases. 
Semantics: 
We give a translation of each basic phrase, according 
to which category it is in: 
CN, IV: player translates to a constant of type C, 
denoted player; and similarly for any other basic 
phrase of category CN or IV. 
NG: Black translates to ~xAu.xu(Black), where 
Black is a constant of type A. Having Black be a 
constant of type A emphasizes the point that 
Black is a name, associated with some particular 
object in A. The translation of other basic phras- 
es of NG will be similar, except for he i and they i (i 
= 0,  1 .... ). In particular, he i translates to 
~x.~u.xuqi and they i translates to ~x.~u.xuPi. 
TV: own translates to XyAuAz.y(~ut.(own)uWz)u, 
where own is a constant of type \[U -* \[A -* \[A 
-- T\]\]\]; and similarly for any other basic phrase 
of category TV. This emphasizes that a transitive 
verb is a relation between two objects in A. In 
particular, if own interprets to a ?  \[U -- \[A -* \[A 
-~ T\]\]\], fleU, and 7, 8 ?A,  then afl3,d if true is the 
object 3' owns the object d in the universe ft.8 
NM: black translates to ~x.AuAz.xuz A (black)uz, 
where black is a constant of type C; and similarly 
for other basic phrases of category NM. 
PP: at translates to ~y.~x.Xu.Xz.xuz A 
y(XuV.(at)utz)u, where at is a constant of type 
\[U -* \[A -- \[A -* T\]\]\]; and so on. 
NU: 0 translates to 0, a constant of type N, which 
interprets to the natural number 0 in N; and simi- 
larly for other numerals. 
NG?NG: what translates to ~,y.y and who translates 
to ~yAx.~u.y(player)u/x yxu. 
3.2.2 The combinative rules 
These rules use a set of syntactic functions, F 1 
through F4, which combine phrases in various ways 
involving person, plurality, and so on. We give these 
functions first. 
Ft(u,v) is uv', where v' is v (if the first noun in u is 
plural) or the result of replacing the first verb in v 
by its third person singular form (if the first noun 
8 However, this scheme will not work with all transitive verbs, 
for example, alleged to be. Such verbs, called intensional verbs, 
require more complex translations, but the end result will still be of 
type \[\[C --,- S\] ~ CI. The same complexities arise for NM and PP. 
Our example contains none of these intensional words. 
in u is singular). 
F2(u,v) is uv t, where v' is the result of replacing the 
first noun in v by its objective form. 
F3(u,v) = uv. 
F4(u,v) = vu. 
Syntactic Rules: 
R2. If u is a phrase from NG and v is a phrase from 
IV, then Fl(U,V) is a phrase from SE. 
R3. If u is a phrase from TV and v is a phrase from 
NG, then F2(u,v) is a phrase from IF. 
R4. If u is a phrase from PP and v is a phrase from 
NG, then F2(u, v) is a phrase from MG. 
R5. If u is a phrase from NM and v is a phrase from 
CN, then F3(u,v) is a phrase from CN. 
R6. If u is a phrase from MG and v is a phrase from 
CN, then F4(u,v) is a phrase from CN. 
Interrogative Variants of Syntactic Rules: 
In any of the rules R2 through R6, exactly one of the 
arguments, u or v, may be a phrase from category X?Y, 
where X is the original category specified for the argu- 
ment and Y is any non-interrogative category. If the 
original result was to be from category Z, then the 
new result is in category Z?Y. For example, from R2, 
if u is a phrase from NG?NG and v is a phrase from 
IV, then Fl(U,v) is a phrase from SE?NG. 
Semantics: 
Let w = Fi(u,v), fo r i  = 1, 2, 3, or 4. Let u translate 
to b and v translate to c. Then there are three cases 
for the translation of w" 
Case (i): If neither u nor v is from an interrogative 
category, then w translates to bc. 
Case (ii): If u is from an interrogative category X?Y, 
then w translates to ~s.bsc, where s is a variable 
of type assigned to the category Y. 
Case (iii): If v is from an interrogative category X?Y, 
then w translates to ~s.b(cs), where s is a varia- 
ble of type assigned to the category Y. 
3.2.3 Extracategorical rules 
These rules combine phrases with words from outside 
the categories to form new phrases. The rules use two 
syntactic functions given here: 
Fs(u,v) is vu v, where u t is u (if v = 1), or the result of 
replacing the first noun in u by its plural form (if 
v~ 1). 
F6(u ) is the result of replacing the first noun in u with 
its plural form. 
Syntactic Rules and Semantics: 
R7. Let u be a phrase from CN, translating to b. 
American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 17 
Michael G. Main and David B. Benson Denotational Semantics for "Natural" Language Q-A Programs 
Then: 
(i) 
(ii) 
(iii) 
(iv) 
every u is a phrase from NG, translating to 
Xx.Xu.Vz.buz => xuz. 
some u is a phrase from NG, translating to 
Xx,Xu.3z.buz A xuz. 
the u is a phrase from NG, translating to 
Xx.Xu.3z.xuz A ?z ' .  (buz'  < ;. ( z=z ' ) ) .  
no u is a phrase from NG, translating to 
kx.Xu.-~3z.buz A xuz. 
R8. Let u be a phrase from CN, translating to b. 
Also let v be a phrase from NU, which translates 
to n. Then: 
(i) exactly Fs(u,v) is a phrase from NG, trans- 
lating to Xx.Xu.(3nz.buz A xuz) A 
- , (3 (n+l )z .buz  A xuz). 
(ii) at least Fs(u,v) is a phrase from NG, 
translating to Xx.Xu.3nz.buz A xuz. 
(iii) less than F5(u,v) is a phrase from NG, 
translating to Xx.Xu.-, (3nz.buz A xuz). 
R9. Let u be a phrase from SE, translating to b. 
Then is it the case that u is a phrase from YN, 
translating to M.Xu.bu<==>t. 
R10. Let u be a phrase from CN, translating to b. 
Then: 
(i) what F6(u) is a phrase from NG?NG, 
translating to ?~y.Xx.Xu.ybu A yxu. 
(ii) how many F6(u ) is a phrase from NG?NU, 
translating to Xm.Xx.Xu.(3mz.buz A xuz) 
A -, ( \ ] (m+ 1)z.buz A xuz. 
3.2.4 The abstraction rule 
This rule is to replace the variables he i and they i by 
other noun phrases. The necessity for abstraction is 
discussed in Lewis (1972). The syntactic functions F 7 
and Fs, defined below, are used. In these definitions, 
let u' be the result of replacing the first noun in u with 
its objective form, let up be the result of replacing the 
first noun in u with its plural form, and let u'p be the 
result of replacing the first noun in u with its plural 
objective form. 
FT(U,v,i) is the result of replacing, in v, all occurrences 
of he i by u and all occurrences of him i by u' .  
F8(u,v,i) is the result of replacing in v, all occurrences 
of they i by Up and all occurrences of them i by U'p. 
Syntactic Rule: 
R l l .  Let u be a phrase from NG, v be a phrase from 
SE, IV, or CN, and i be a variable index (e.g., 
0, 1, 2 . . . .  ). Then FT(U,v,i) and Fs(u,v,i) are 
phrases from the same category as v. 
Interrogative Variant of Syntactic Rule: 
Either u may be from NG?Y or v may be from SE?Y, 
IV?Y, or CN?Y (but not both), where Y is any non- 
interrogative category. In all cases, the result is from 
X?Y, where X is the first portion of the category of v. 
Semantics: 
Let b be the translation of u and c be the translation 
of v. The translation of FT(U,v,i) is given in the fol- 
lowing table, where s is a variable of type Y: 
Case 1: v from SE and u from NG: b(Xu.Xqi.cu) 
Case 2: v from SE and u from NG?Y: 
Xs.bx(Xu.Xqi.cu) 
Case 3: v from IV  or CN and u from NG: 
?~u.Xz.b(Xu' .Xqi.culz)u 
Case 4: v from IV  or CN and u from NG?Y: 
Xs.Xu.Xz.bs(Xu' .Xqi.cu'z)u 
Case 5: v from SE?Y  and u from NG: 
Xs.b(Xu.Xqi.csu) 
Case 6: v from IV?Y or CN?Y and u from NG: 
?~s.Xu.Xz.b(?~u' .hqi.csu'z)u 
The translation is identical for F8, except that qi is 
replaced by Pi- 
Some of the notions in the syntactic rules must still 
be formalized. We must define the plural, objective, 
and plural objective forms of each basic phrase in CN, 
NG, and NG?NG. A noun is then any such basic 
phrase or one of these forms. A verb is any basic 
phrase in IV  or TV. For each verb we must define its 
third person singular form. 
A brief discussion of the abstraction rules can clari- 
fy their usage and purpose. A sentence such as every 
player owns some stone has two possible meanings. It 
can mean: there is some particular stone owned by 
every player; or alternately, every player owns at least 
one stone, but not necessarily the same stone for each 
player. These two meanings will be achieved by intro- 
ducing the NG some stone at different times. The ab- 
straction rules allow this by delaying the introduction 
of a noun phrase. Initially, a variable (perhaps he o) is 
put in the sentence as a place holder. The abstraction 
rules allow an NG to later replace the variable. 
4. Quest ions and Answers  
4.1 Quest ions 
A question is any phrase from category YN, SE?NG, or 
SE?NU, along with its syntactic derivation. The syn- 
tactic derivation is needed because some phrases can 
be derived in more than one way (e.g., is it the case 
that every player owns some stone). 
Derivations are represented by trees. Each leaf in 
a derivation tree is labeled with a basic phrase. Each 
internal node is labeled with a derived phrase, plus the 
number of the syntactic rule that is used to derive it 
from its daughter leaves. 
From the semantic rules, every question translates 
to exactly one lambda expression. 
18 American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 
Michael G. Main and David B. Benson Denotational Semantics for "Natural" Language Q-A Programs 
4.2 Answers  
Let  Q be a quest ion that t ranslates to a lambda ex- 
pression,  b, of type \[X ~ S\]. A lso let: 
? q, be a var iable ass ignment,  
? g be a constant  of type U and II g II 4~ = ~', 
? d be a constant  of type X and II d II q~ = ,~. 
Then 6 is an answer to Q, in the universe 3' with var ia-  
ble ass ignment ~b iff II bdg II ~k is true. 
If b is an express ion of type \[X --  S\], then the 
answers  to its cor respond ing  quest ion are semant ic  
objects  in X. In general ,  these objects  depend on the 
choice of the universe and also on the var iable assign- 
ment. However ,  if the quest ion does not conta in  any 
var iables (he i or theYi), then the set of answers is the 
same for any var iable assignment.  Such a quest ion is 
cal led invariable, and we may speak of an answer  with-  
out respect  to a var iable assignment.  
4.3 Examples  
All  of these examples are invar iable quest ions,  so we 
may choose a var iable ass ignment,  ~p, at random. The 
types of var iables are as in sect ion 3.2, and we also 
use a lambda constant  g, of type U. As always,  there 
is a f ixed interpretat ion  assigning the lambda constants  
to semant ic  objects.  
In translat ing the examples  to lambda expressions,  
we use the semant ic  rules of sect ion 3.2. However ,  
after  t ranslat ing a phrase,  we will somet imes alter  the 
lambda express ion in ways that cannot  change the 
semant ic  object .  9
Example 1. One der ivat ion of the phrase is it the case 
that every player owns some stone is: 
(R9) is it the case that every player owns some stone 
I 
(R2) every player owns some stone 
o (R7) every player wn some stone 
I . / \  
player own (R7) some stone 
stone 
We have these translat ions:  
own some stone: 
Xu.Xz.=lz' .(stone)uz' A (own)uzz '  
9 In particular, we use logical conversion (such as b A b 
converts to b) and the a- and /3-conversions of lambda calculus. 
a-conversion i volves changing the name of a bound variable (e.g., 
?,x.x A y converts to ),z.z A y). /3-conversion corresponds to func- 
tional application (e.g., (~,x.x A y)z converts to z A y). Details can 
be found in Stoy (1977). 
every player:  
?,x.?,u.Vz.(player)uz ~ xuz 
every p layer  owns some stone: 
~u.Vz.(p layer)uz => (3z~.(stoue)uz t A (own)uzz t) 
is it the case that every p layer  owns some stone: 
Xt.?~u.(Vz.(player)uz => (3zV.(stone)uz ' A 
(own)uzz ' ) )  < ;. t 
Let  true be a constant  of  type T that  in terprets  to 
' t rue '~T.  F rom the def in i t ion of an answer,  ' t rue '  is 
an answer  to this quest ion in the universe II g II ~ iff: 
II (MAu. (Vz . (p layer )uz  A (3z t . (s tone)uz t A 
(own)uzz ' ) )  4=0, t ) ( t rue)g  II
Here,  ~p can be p icked at random. The above expres-  
sion converts  to 
II ?z. (p layer)gz  => (3zt . (s tone)gz  w A (own)gzz t) II 4~ 
This is a reasonable  condi t ion for ' t rue '  to answer  the 
quest ion. 
Example 2. An  a l ternat ive der ivat ion for the previous 
phrase is: 
(R9) is it the case that every p layer  owns some stone 
I 
(R11)  every player owns some stone 
\ , 
some (R)  every p ayer owns h im o 
(R7) every player (R3)  own h im 0 stone 
I / \  
player own he o 
In this case, the t rans lat ions are: 
own himo: 
~u.Xz.(own)uzq 0 
every player owns himo: 
Xu.Vz.(player)uz =~ (own)uzq 0
every player owns some stone: 
~u.3z ' . ( s tone)uz '  A (Vz.(player)uz ~ (own)uzz v) 
is it the case that every player owns some stone: 
kt .ku. (3z~.(stone)uz t /k (Vz.(player)uz 
(own)uzz ' ) )  < > t 
In the universe II g II ~, ' t rue '  is an answer  to this ques-  
t ion iff: 
II 3z ' . ( s tone)gz '  A (Vz.(player)gz => (own)gzz')l imb 
This contrasts  with example 1. 
American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 19 
Michael G. Main and David B. Benson Denotational Semantics for 'Natural" Language Q-A Programs 
Example 3. Here is a derivation of a phrase from 
SE?NU: \[ 
(R2) howman~tone~long  to Black 
(RI0)  how many stones (R3) belong to Black / / \  
stone belong to Black 
The semantic rules give these translations: 
belong to Black: 
Xu.Xz.(belong to)uz(Black) 
how many stones: 
km.kxAu.(3mz.(stone)uz A xuz) A 
-~ (3(m+l)z. (stone)uz A xuz) 
how many stones belong to Black: 
km.ku.(3mz.(stone)uz A (belong to)uz(Black)) A 
-, (3(m+ 1)z. (stone)uz A (belong to)uz(Black)) 
Let 7/ = II n II ff be a natural number. Then 7/ answers 
this question in the universe II g \[1 if, iff: 
II (3nz.(stone)gz A (belong to)gz(Black)) A 
-, ( \ ] (n+ 1)z. (stone)gz A (belong to)gz(Black)) II 
That is, there exists ~/ stones (but not ,/+1) that be- 
long to Black in the universe II g II ft. 
Example 4. This question is from SE?NG. 
(R2) what owns no black stone 
what (R2) own no black stone 
own (R7) no black stone 
I 
(R5) black stone / \  
black stone 
Here are the translations to lambda expressions: 
black stone: 
Xu.Xz.(stone)uz A (black)uz 
no black stone: 
Xx.hu.-,3z.(stone)uz A (black)uz A xuz 
own no black stone: 
~u.~z'.-, 3z.(stone)uz A (black)uz A (own)uz' z
what owns no black stone: 
ky.y(ku.kz'.-~ 3z.(stone)uz A (black)uz A 
(own)uz'z) 
The semantic object corresponding to White (namely, 
II ~x.hu.xu(White)II ~) answers this question in a uni- 
verse, H g II ~, iff: 
II-,\]z.(stone)gz A (black)gz A (own)g(White)z II q~ 
Any realistic interpretation interprets the constants 
black, own, and White so that H (black)gzllff and 
It (own)g(White)z II q~ are mutually exclusive for any g, 
z, and ~k, so that the semantic object for White does 
answer this question. 
The difficulty with examples such as these is that 
even when the translations of individual constructions 
are fairly simple the translation of a complex construc- 
tion inevitably appears cryptic and the translation 
process is tedious. However, the formal translations 
are amenable to mechanical manipulations and the 
translating process is also easily mechanized. Hence, 
we leave it as an exerciue in the manipulations to show 
that the translation of what blocks own at least 3 stones 
with less than 2 liberties is as follows: 
Xy.ku.y(bloek)u A y(Xu.Xz"33zL(stone)uz'  A 
-,(32z.(liberty)uz A (with)uz'z) A (own)uz"z ' )u 
The first part of the translation guarantees that a 
possible answer, y, is indeed a block. The second part 
checks that y owns at least 3 stones with less than 2 
liberties. Note that, although there may be other pars- 
ings of this sentence in a complete English grammar, 
our simple syntactic rules have forced this particular 
translation upon us. 
Answers to SE?NG questions are objects from \[C 
-~ S\]. However, it might be more convenient to have 
these answers be objects from A. A modification to 
the definition of an answer could allow this. In partic- 
ular, let b be a lambda constant of type A, which in- 
terprets to flEA. Then /3 could answer a question in 
the universe II g II ~, with variable assignment ~b, iff 
II XxAu.xuh II ~ E \[C -~ S\], does. 
5. Discuss ion 
We have used denotational techniques to define the 
semantics of a "natural" language question answerer. 
The questions are defined by syntactic rules - a cate- 
gory grammar. Associated with each syntactic rule is 
a semantic rule, giving a semantic object for each 
phrase the syntactic rule produces. The semantic ob- 
jects for questions are functions, from possible an- 
swers to propositions, where a proposition is an object 
that takes on a truth value. Thus, if a question, Q, has 
a semantic object that maps an answer, A, to a true 
proposition, then A answers Q. In this way, the rela- 
tion between questions and answers is formalized. 
While it is not our intent to give implementation 
details for the question answerer, an outline of the 
program's organization will lead to some concluding 
remarks. The program was written as a class project 
by the first author and four other students. The logi- 
cal divisions of the program were as follows: 
20 American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 
Michael G. Main and David B. Benson Denotational Semantics for "Natural" Language Q-A Programs 
? Lexical  analysis. The input is broken into basic 
component  words, or "tokens", using finite auto- 
mata techniques as in Johnson et al (1968).  
? Syntactic parser. An augmented transition network 
(Woods 1970) parses the input according to the 
category grammar with heuristic rules and interac- 
tive query to solve ambiguities. The output is a 
single derivation tree. 
? Semantic interpretation. The "meaning" of the sen- 
tence is computed according to the semantic rules. 
The output of this phase can be thought of as 
"machine code" for finding answers. At this stage, 
the "code" is independent of the actual structure of 
the implementation of the underlying data base. 
? Deductive components. The "code" from the previ- 
ous stage is improved based on conversion rules of 
logic, such as x or x = x. It is also modified ac- 
cording to the specific structure of the data base. 
The latter modif icat ions are implementat ion de- 
pendent. 
? Answerer. This corresponds to a database query- 
retrieval program. The "code" from the previous 
step is executed to produce an answer. 
In the actual implementation, the above stages are 
not strictly separate; still, the model is useful. There 
is a direct correspondence between the first four 
stages of the implementation and the initial four stages 
of a typical compiler (Aho and Ullman 1977). Hobbs 
and Rosenschein (1977) indicate how these last three 
stages could be developed using an augmented LISP as 
"code". 
In this paper, we have recommended using denota- 
tional semantics as a specif ication technique for 
quest ion-answering programs. The implementat ion 
suggests that principles of compiler design can be used 
as principles of question answerer design by the soft- 
ware engineer. 
References  
Aho, A.V. and Ullman, J.D. 1977 Principles of Compiler Design. 
Addison-Wesley, Reading, Massachusetts. 
Ajdukiewicz, K. 1926 The Semantic Analysis of Interrogative 
Sentences, Ruth Filozoficzny X. 
Ajdukiewicz, K. 1935 Syntactic Connexion. In McCall, S., Ed., 
Polish Logic, 1920-1939. Clarendon, Oxford (1967). 
Ashcroft, E.A. and Wadge, W.W. 1982 R~ for Semantics. ACM 
Trans. Prog. Lang. and Sys. 4: 283-294. 
Benson, D.B. 1975 Formal Languages vis-a-vis 'Natural' Lan- 
guages. In Sedelow, W. and Sedelow, S., Ed., Computers in 
Language Research: Trends in Linguistics. Mouton, the Hague 
(1979). 
Carnap, R. 1937 The Logical Syntax of Language. Smeaton, A., 
Trans. Kegan Paul, Trench, Trubner and Son, Ltd., London. 
Church, A. 1951 The Calculi of Lambda-Conversion. Princeton 
University Press, Princeton, New Jersey. 
Frege, G. 1892 On Sense and Reference. In Geach, P. and Black, 
M., Ed., Translations from the Philosophical Writings of Gottlob 
Frege. Basil Blackwell, Oxford (1952). 
Gordon, M.J.C. 1979 The Denotational Description of Programming 
Languages. Springer-Verlag, New York. 
Harris, L.R. 1979 Experience with ROBOT in 12 Commercial 
Natural Language Data Base Query Applications, Proc. 6th 
International Joint Conference on Artificial Intelligence. Tokyo: 
365-368. 
Hobbs, J.R. and Rosenschein, S.J. 1977 Making Computation 
Sense of Montagae's Intensional Logic, Artificial Intelligence 9: 
287-306. 
Johnson, S.C. 1975 YACC - Yet Another Compiler Compiler. 
CSTR 32. Bell Laboratories, Murray Hill, New Jersey. 
Johnson, W.L.; Porter, J.H.; Ackley, S.I.; and Ross, D.T. 1968 
Automatic Generation of Efficient Lexical Analyzers Using 
Finite State Techniques, Communications of the ACM 11(12): 
805-813. 
Kahn, C. 1978 Questions and Categories. In Hiz, H., Ed., 
Questions. D. Reidel Publishing Co., Dordrecht, Holland. 
Karttunen, L. 1977 Syntax and Semantics of Questions, Linguistics 
and Philosophy 1 : 3-44. 
Lewis, D. 1972 General semantics. In Davidson, D. and Harman, 
G., Ed., Semantics of Natural Language. D. Reidel Publishing 
Co., Dordreeht, Holland. 
McGettrick, A.D. 1980. The Definition of Programming Languages. 
(Cambridge Computer Science Texts t 1.) Cambridge University 
Press, Cambridge. 
Milne, R. and Strachey, C. 1976 A Theory of Programming Lan- 
guage Semantics. Chapman and Hall, London. 
Montague, R. 1973 The Proper Treatment of Quantification in 
Ordinary English. In Thomasen, R., Ed., Formal Philosophy. 
Selected Papers of Richard Montague. Yale University Press, New 
Haven, Connecticut (1974). 
Pagen, F.G. 1981 Formal Specification of Programming Languages: 
A Panoramic Primer. Prentice-Hall, Inc., Englewood Cliffs, New 
Jersey. 
Scott, D. 1976 Data Types as Lattices, SIAM Journal of Computing 
5: 522-587. 
Stoy, J. 1977 Denotational Semantics: The Scott-Strachey Approach 
to Programming Language Theory. M1T Press, Cambridge, Mas- 
sachusetts. 
Tennent, R.D. 1981 Principles of Programming Languages. Prentice- 
Hall, Inc., Englewood Cliffs, New Jersey. 
van Emde Boas, P. and Janssen, T. 1979 The Impact of Frege's 
Prineiple of Compositionality for the Semantics of Programming 
and Natural Languages. Report 79-07, University of Amster- 
dam. 
Winograd, T. 1972 Understanding Natural Language. Academic 
Press, New York, New York. 
Woods, W.A. 1970 Transition Network Grammars for Natural 
Language Analysis, Communications of the ACM 13(10): 591- 
602. 
Woods, W.A. 1972 The Lunar Sciences Natural Language Informa- 
tion System. Report 2378, Bolt Beranek and Newman. 
American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 21 
