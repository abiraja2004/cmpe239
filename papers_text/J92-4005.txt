Squibs and Discussions 
Restriction and Termination in Parsing 
Feature-Theoretic Grammars 
with 
S. P. Harrison* 
University of Western Australia 
T. M. Ellison* 
University of Western Australia 
Shieber (1987) describes a technique for limiting the number of active dges introduced into a chart 
by top-down prediction in chart parsers for PATR grammars, without affecting the correctness 
or completeness of the parser. That technique, termed restriction, isextendable toother parsing 
algorithms. It can be employed to increase parsing efficiency and to induce termination for some 
classes of grammars that would not otherwise terminate. 
Here, we describe one class of grammars for which restriction, as described by Shieber, induces 
non-termination. We do not suggest that the concept of restriction is fatally flawed, however. On 
the contrary, relatively minor modifications to the implementation f restriction can make it a 
more flexible tool for fine-tuning PATR grammars. 
Background 
Shieber (1987) observes that the potentially infinite category domain of feature-theoretic 
grammar formalisms like PATR-II makes implementing efficient parsers for such for- 
malisms difficult. He concludes that the two earliest approaches to the problem are 
at best ill-advised. Parsing with a context-free backbone ffectively ignores informa- 
tion in fact available to guide the parse and violates the spirit of feature-theoretic 
grammar. Tailoring the parsing algorithm or the grammar itself to the exigencies of 
feature-theoretic formalisms puts the burden of coping with the problem in the wrong 
place, on the end user of a grammar development system. 
The most obvious alternative to parsing with a context-free backbone is using 
graph unification, rather than atomic symbol identity, to drive the parsing process. 
Shieber notes that not only is that approach costly (in using information that in fact can 
never affect he outcome of a parse) but, for some grammars, induces non-termination. 
The class of grammars Shieber describes might be termed top-down path building gram- 
mars, because they are grammars in which the length of a path through the graph 
increases as one descends the parse tree. 
The particular grammar Shieber uses is one that counts the number of terminal 
symbols in the string being parsed: 
(G1) 
Rule "set end marker' 
S --* T: 
= (V) 
(U)  = a. 
* Centre for Linguistics, University ofWestern Australia, Perth, Western Australia 
(~) 1992 Association for Computational Linguistics 
Computational Linguistics Volume 18, Number 4 
Rule "recursive clause" 
To ~ T1A: 
Rule 'base clause' 
Rule 'lexical insertion" 
(Tof) = (Tiff). 
T -+ A. 
A -+ a. 
G1 generates trees like the following: 
S 
I 
i i 
a a a 
In the course of a derivation, G1 builds a path (Tnf +) from the root of the graph 
T, corresponding to each node Tn in the tree. The 'count' is reflected in the length of 
the path (T,f+ I. As one descends the tree, the length of the path that is the value of 
the attribute f increases by 1 for each successive node Tn+l: 
Hence the term top-down path building, characterizing grammars like G1. Recall that, !n 
a chart parsing regime, for each active edge Em of the form: 
(i, j, X ---* e~.Yfl) 
and each rule Ri of the form: 
y ---, -y 
the top-down rule adds an active edge En of the form: 
(j , j, Y ~ .'V ) 
520 
S. P. Harrison and T. M. Ellison Restriction and Termination i  Parsing 
If, associated with Era, there is a graph Gin, and with Ri a graph Gi, then associated 
with En will be a graph Gn = Gi UGm(Y), where Gm(Y) is the subgraph of Gm at Y. As 
Shieber points out, a parser employing this top-down rule will not terminate when 
interpreting rammar G1. On initialization (with Rule 'set end marker'), the parser 
generates an active edge seeking a constituent of category T. The top-down rule then 
uses that edge and the Rule 'recursive clause' to generate a new active edge seeking 
a constituent of category T. That active edge then generates a new (and, crucially, a 
distinct) active edge not subsumed by any existing edge, "and so forth, ad infinitum." 
In other words, each top-down recursion anticipates a different erminal string that is 
one symbol longer than that predicted on the previous recursion; because the graphs 
associated with those anticipated strings are distinct, the normal chart parsing checks 
fail to prevent looping. 
Shieber's olution to the problem posed by grammar G1 is to introduce a notion 
he terms restriction. Under restriction, the graph associated with an edge generated by 
the top-down rule (applied to an active edge Em and a grammar ule Ri) is not a graph 
G = Gi U Gm (X), where Gi is the graph associated with Ri and Gm (X) is that portion 
of the graph (associated with Era) corresponding to the left hand side of Ri. Rather, 
G = Gi U (Gm(X)!~), where Gm(X)!~) is a graph G' resulting from filtering out of Gm 
all those paths not explicitly sanctioned by ~. The filter ? is termed a restrictor, and 
is represented as a set of paths P. The graph G' (= G!@) is derived from G by filtering 
out all those paths that are not members of p.1 
Given a restrictor that passes through only the (cat) path, the termination problem 
for grammar G1 vanishes. Since the active edges generated by the top-down rule 
pass on only their category information, each time the rule 'recursive clause' is called 
recursively, the edge it generates i the same (underspecified) edge generated on the 
first call to that rule, and already on the chart. 
The following observations regarding the restrictors Shieber describes might be 
made at this point: 
1. The graph for the active edge generated by the top-down rule with a 
parser using restriction is no less specific (has no less information) than 
the graph stipulated by the rule used; i.e., it is information from the extant 
active edge that is suppressed. 
2. The restrictor provides a positive restriction, i.e., it stipulates which paths 
are included in the restricted graph, not which paths are suppressed. 
A Problem: Bottom-up Path Building 
The following grammar might be considered almost the inverse of the grammar G1 
described by Shieber (1987). It parses strings of length 1, and generates one node T in 
1 Shieber's definition of restriction isas follows: 
"Given a relation F between paths and labels, and a dag D, we define D!F to be the most 
specific dag D ~ (D D D ~) such that for every path p either Dr(p) is undefined, or D~(p) is 
atomic, or for every l C dom(D~(p))~ p@l. That is, every path in the restricted dag is either 
undefined, atomic, or specifically allowed by the restrictor." 
That definition might seem to suggest that paths that are instantiated (atom valued) are not filtered out 
by the restrictor. His examples demonstrate that that is not the correct interpretation f his definition. 
Rather, itwould seem that atomic paths (i.e. 'leaves'), and not atomic-valued paths, fall through the 
filter. 
521 
Computational Linguistics Volume 18, Number 4 
the parse tree for each arc labeled g in the graph corresponding to the item recognized: 
(G2) 
Rule 'copy attribute' 
S ~ AT: 
Rule 'recursive clause' 
To ~ TI: 
Rule 'base clause" 
T --~: 
Rule 'lexical insertion a' 
A~a:  
Rule 'lexical insertion b' 
A- ,b :  
(Ag,) = (Tg). 
(Togg) = (Tlg). 
(Tg) = e. 
(Aggg) = e. 
(Agg) = e. 
G2 generates exactly two trees: 
Tree2a. 
S 
a T 2 
Tree2b. 
$ /N  
b T 1 
each of which is associated with a distinct graph: 
Dag2a. Dag2b. 
? ?I'J' 
A To 
J e 
522 
S. P. Harrison and T. M. Ellison Restriction and Termination i  Parsing 
For this grammar, the length of the path (Tng +) in each subgraph Tn increases as 
one ascends the tree. Hence the term bottom-up ath building is used to characterize 
grammars of this sort. 
Using the same restrictor (i.e. (cat)) employed for G1, a parser interpreting G2 will 
not terminate on any grammatical input. As in G1, only one active edge generated 
from the Rule 'recursive clause' is put on 
E1 
x0 
1, 1, Xo --+ .Xl, 
Xl 
The rule 'base clause' of G2 generates the 
E2 
the chart: 
: I cat:T 
Icat l 
g: EI 
passive edge: 
I 
1,1,X---,., X: g: e 
The fundamental rule then applies to E1 and E2 to yield the passive edge: 
Ea 
x0: 
\ [ ca t :T \ ]  X1 : g : \ [~e 
1, 1,Xo --* X l .  ~ 
and then applies to E1 and E3 to yield: 
E4 
1, 1,X0 ~ XI., 
Xo : g: \] 
\[ cat : T 1 X1 : g:~\ ]  ~g : e\] 
and so forth, ad infinitum. Ultimately, the fundamental rule will generate a passive 
edge with a graph G such that G(g) = {Gi: T'(g)}, for the passive edge: 
(0, 1, S --', A.T, Gi) 
where {Gi : T'(g)} is the subgraph corresponding to the constituent T. At that point, 
the parser, in effect, will have parsed the input string. Nonetheless, it will continue 
to add new passive edges, each with a graph whose/g+/path is one arc longer than 
that of the passive edge from which it is generated. 
Bottom-up ath building grammars are not without interesting linguistic applica- 
tions. Consider, for example, the following PATR implementation f the append oper- 
ation on lists employed in HPSG (Pollard and Sag 1987; Section 2.2): 
(G3) 
Rule 'collect lists' 
Top --~ Left Right Append: 
(Append list1/ = ( Left list/ 
(Append list2/ = (Right list / 
(Top list/ = {Append list/. 
523 
Computational Linguistics Volume 18, Number 4 
Rule 'base case' 
Append --*: 
(Append list} = (Append list2) 
(Appendlistl) = (). 
Rule 'recursive clause' 
Append0 ~ Append1: 
(Append0 list first} 
(Append0 list rest) 
(Append0 list1 rest) 
(Append1 list2) 
= (Append0 list1 first} 
= (Append1 list} 
= (Append1 list1) 
= (Append0 list2). 
Given the rules 'base case' and 'recursive clause,' one need only introduce a 'dummy' 
constituent Append (whose only function is to collect the list-valued attributes list1 
and list2 in a single list), and appropriate constraints on some list-valued attribute, in 
order to simulate the HPSG append in PATR. Unfortunately, because these two rules are 
an instance of the bottom-up ath building problem, no derivation employing these 
rules will terminate. 2 
Solutions 
The source of the bottom-up ath building problem is the active edge E1 above, whose 
~g+} path is of indeterminate length. Because the parser does not know how long that 
path should be, it keeps adding to it ad infinitum. Observe, however, that the parser 
had the required information (obtained from the (g) attribute of constituent A), but 
was induced by the restrictor to throw that information away. 
There are at least three solutions to the problem posed by bottom-up ath building 
grammars under restriction: 
1. Impose a finite limit on the path (g+}. 
2. Convert he grammar to top-down path building. 
3. Change the nature and implementation f restriction. 
We consider each of these proposals in turn in the following paragraphs. 
Solution 1 involves picking an arbitrary upper limit on the length of (g+}, and 
adding a corresponding path to the restrictor. The parser would then terminate for 
any input whose (g+} path length is less than or equal to that of the stipulated 
path. For example, a parser interpreting G2 above would terminate with the restrictor 
{(cat}(g  g)}. But that is a "Band-Aid" solution at best. 
2 The append operation is necessary whenever  a grammar  demands  that two list-valued attributes be 
combined; for example, when the SUBCAT of a constituent is defined as the union of the values of 
SUBCAT for its daughters,  or when the l ist-valued SKELETON of a syllable is defined as the 
SKELETON of the onset followed by the SKELETON of the rhyme. One would, of course, prefer to 
have PATR extended to accommodate append, rather than have to simulate the append operation in pure 
PATR, but that is not the issue here. The point we are making is s imply that one could simulate append 
in pure PATR, were it not for the restriction regime of the PATR standard efined in Shieber (1989). 
524 
S. P. Harrison and T. M. Ellison Restriction and Termination in Parsing 
Solution 2 might involve a grammar like G4, a top-down path building grammar 
weakly equivalent to G2. G4 does not, however, have the termination problem of G2: 
(G4) 
Rule 'base case' 
S --> T: 
Rule 'recursive clause' 
To -* TI: 
Rule 'copy path" 
T-+A:  
Rule 'lexical insertion a' 
A-*a :  
Rule 'lexical insertion b' 
A-+b:  
(Tg) = e. 
(Tog) = (Ylgg). 
(Tg) = (Ag). 
(Aggg) = e. 
(Agg) = e. 
(The following are the trees, and corresponding complex feature structures, generated 
by G4: 
S S 
I 
A 
I 
a 
A T2 
O 
A vl 
S 
e 
525 
Computational Linguistics Volume 18, Number 4 
Note that the length of the path g+ increases as one descends the tree.) Similarly, 
grammar G5 provides a top-down path building solution to the append operation: 
(G5) 
Rule 'collect lists' 
Append --. Left Right: 
(Append residue) = (Append list) 
(Append list1) = (Left list) 
(Append list2) -- (Right list). 
Rule 'append base case' 
Top ~ Append: 
(Top list) = (Append list) 
(Append residue) = (Append list2) 
(Append list1) -- (). 
Rule 'append recursive clause' 
Append0 --~ Append\]: 
(Append0 list) = (Append1 list) 
(Append0 list1) = (Append1 list1 rest) 
(Append0 list2) = (Append1 list2) 
(Append0 residue) = (Append1 residue rest) 
(Append1 residue first) = (Append1 list1 first). 
Consider the case of two descendants, Left and Right, of a node Top, where the value 
of (Left list) is (a, b), the value of (Right list) is (c, d), and the value of (Top list) is 
append ((L list), (R list)). G3 assigns to that construction the parse tree: 
Left Right Aplend o
Append 1
ApJend 2 
526 
S. P. Harrison and T. M. Ellison Restriction and Termination in Parsing 
and the complex feature structure: 
Top: 
Left : 
Right : 
Append 0: 
Append1 : 
Append 2: 
Ilist : ~-~1 
I1 \[first: ~ \ ] i res t :  ~L_23 ~ I \]\] ist :~-~ f-Z\] first : b 
rest () 
I \[first: i l i s t : r3 \ ]  \] 1\] first : d rest : rest : 
list : \ [ \ ]  restfirst :: 
list1: ~-\] restfirst: ~ :  
list2 : E\] 
list : ~\] 
list1 : ~\] 
list2 : \[~ 
listl : 
list2 
first : \[~ 
rest : 
first : 
rest : 
G5, by contrast, assigns it the parse tree: 
Top 
I 
Aplendo 
Append 1 
Left Right 
527 
Computational Linguistics Volume 18, Number 4 
and the complex feature structure: 
Top: 
Left : 
Right : 
Append 0: 
Append 1: 
Append 2: 
\[,ist l 
first : 
. i s t : \ [ \ ]  rest: 
I first : 
l i s t : \ [ \ ]  rest: 
list : ~-~ 
residue : ~-~ 
list1 : \ [ \ ]  
list2 : ~3~ 
list : ~i~ 
residue : \ [ \ ]  
list1 : ~-~ 
list2 : \ [ \ ]  
list : 
residue : 
list1 : 
list2 : 
6-a 
rest: () 
c \]\] 
first : d 
rest : ( ) 
rest 
\[ rfierStt:: ~ \ ]  
first : 
rest 
first : ~ 
rest 
As noted above, G3 provides a 'dummy' constituent Append that one might want 
ultimately to prune, since its only function is to assemble the appended list. By con- 
trast, G5 assembles the appended list in successive Append nodes dominating the 
constituents Left and Right. One might want to argue that the latter solution is less fe- 
licitous than the former because the Append nodes dominate lexical material. In any 
event, as Shieber stresses, the grammar writer should not be constrained to choose 
between weakly equivalent grammars by the demands of the grammar development 
system. 
Let us now consider solution 3, modifying the nature and implementation f re- 
striction. We choose to term the sort of restriction Shieber describes positive restriction. 
In positive restriction, the restrictor tells the parser how much of the information for 
which paths to retain (in the graph corresponding to the active edge used by the top- 
down rule). If a path is not explicitly mentioned in the restrictor, no information about 
that path is retained. An empty restrictor in effect ells the parser to throw away all 
the information in the restricted graph. 
(An anonymous reviewer for Computational Linguistics points out that grammars 
G2 and G3, in contrast to Shieber's G1, are not offiine parsable \[in the sense of Bresnan 
and Kaplan 1982:263ff and Johnson 1988:95ff\], and suggests that this failure of offiine 
parsability is a necessary condition for membership n the class of grammars that are 
528 
S. P. Harrison and T. M. Ellison Restriction and Termination i  Parsing 
nonterminating under positive restriction. The constituent s ructures generated by a 
grammar are offiine parsable iff: 
i. they contain no nonbranching dominance chains in which the same 
category \[label\] appears twice, and 
ii. all terminal nodes dominate lexical material 
G2 and G3 fail both these conditions, since neither the T node chain of G2 nor the 
Append node chain of G3 either branch or dominate lexical material. We make two 
observations in this regard. First, while it may indeed be the case that failure of offiine 
parsability is a necessary condition for non-termination u der positive restriction, it is 
certainly not a sufficient one, since G4 and G5 both fail condition i. above, and are thus 
not offiine parsable, but do terminate under positive restriction. Second, though G2 
through G5 fail the letter of an offiine parsability constraint, hey do not fail its spirit. 
Offiine parsability has been proposed as a constraint on grammars guaranteeing 
the decidability of the recognition problem for feature-theoretic grammars of the sort 
considered here. For grammars that satisfy offiine parsability, it will be the case that 
the number of nodes of any parse tree assigned to some string will be a computable 
function of the length of the string being parsed. This is not the case for G2 through 
G5. What is the case, however, is that the number of nodes in a parse tree generated 
by those grammars i a computable function of the graphs associated with the lexical 
material covered by the tree. This is because ach of these grammars makes crucial 
reference ither to a list-valued or path-valued attribute of lexical items, where the 
length of the list or path is finite and stipulated in the lexicon. The number of iden- 
tical nodes in any nonbranching dominance chain generated by these grammars i a 
function of the length of a \[bounded\] list or path.) 
Positive restriction can be contrasted with what might be termed negative restric- 
tion. Under negative restriction, the restrictor tells the parser what information to 
throw away. For stipulated paths, the effects of positive and negative restriction are 
the same: a restrictor (ggg) tells the parser to (positively) retain all information up to 
and including an atomic value for the path (ggg), or to (negatively) throw away all 
information about any nonatomic extension of (ggg). The difference is in the interpre- 
tation of paths not explicitly mentioned; under positive restriction these are thrown 
away; under negative restriction they are retained. 
In formal terms, a restrictor, for Shieber, is a relation between paths and the single 
edges that are permitted to extend those paths: If ? is a restrictor, p a path and 1 some 
edge label, then the restrictor permits the path pl iff p~l. But Shieber does not use 
the full power of this formalism. He considers only what we term positive restrictors. 
Mathematically, if P is some finite set of paths, one can define a positive restrictor q~+ 
to be the relation defined by: 
p@+l iff 3 q E P, p~q 
where p < q means that p is a (perhaps improper) prefix to the path q. By contrast, he 
negative restriction regime proposed here allows paths not explicitly disallowed: 
p~pl i f f (3rEP~ r<p)=~qEP,  pGq (1) 
In other words, whereas the positive restrictor admits those paths obeying the condi- 
tion "is a prefix of a member of the restrictor set," the negative restrictor only applies 
529 
Computational Linguistics Volume 18, Number 4 
this condition to paths extending members of the restrictor set. Paths not extending 
members of the restrictor set are themselves not subject o restriction. 
It is an easy matter to show that any positive restrictor p can be defined in terms of 
a negative restrictor. If the null path is included in the restrictor set, then the antecedent 
of the implication in the definition of ~-  (1 above) is always true (except if p = //),  
and the consequent 3q E P U {/ /}, P ~ q is equivalent to 3q E P, p <_ q (except when 
P = / /)- If p is the null path, then the antecedent is always true and so / /~p-u{0} l 
is equivalent to //~+l. For other p, //~u{0}l = //~+l. So, ~{0} = ~+" Thus, an 
implementation using negative restriction can simulate any positive restrictor and, 
therefore, can necessarily solve all problems olvable by positive restriction, as well as 
those problems, described earlier, where positive restriction fails. 
Note that we have limited ourselves, as Shieber has, to finite restrictor sets. This 
limitation is not necessary. A more general proposal allows restrictor sets consisting 
of all paths expressable by some regular expression. Restrictors can then be imple- 
mented as finite state automata. An implementation f this sort would not impose a 
large computational burden and would allow much greater flexibility in the choice of 
restrictor relations. 
We have demonstrated that any restriction definable by a positive restrictor can 
also be defined by a negative restrictor. It follows that any parser requiring positive 
restriction to guarantee termination will also terminate for the same set of grammars 
using negative restriction. But we have also demonstrated that the reverse does not 
hold. Therefore, it would seem that negative restriction is superior to positive restric- 
tion in the implementation f parsers for feature-theoretic grammars. 
References 
Johnson, M. (1988). "Attribute-value logic 
and the theory of grammar." CSLI Lecture 
Notes, 16. 
Kaplan, R., and Bresnan, J. (1982). 
"Lexical-functional grammar, a formal 
system for grammatical representation." 
In The Mental Representation of Grammatical 
Relations, edited by J. Bresnan, 173-281. 
MIT Press. 
Pollard, C., and Sag, I. A. (1987). 
"Information-based syntax and 
semantics." CSLI Lecture Notes, 13(1). 
Shieber, S. M. (1987). "Using restriction to 
extend parsing algorithms for 
complex-feature-based formalisms." 
Proceedings, 23rd Annual Meeting of the 
ACL. 154-52. 
530 
