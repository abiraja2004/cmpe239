THE DESIGN OF THE KERNEL ARCHITECTURE FOR THE EUROTRA* SOFTWARE 
R.L. Johnson**, U.M.I.S.T., P.O. Box 88, Manchester M60 IQD, U.K. 
S. Krauwer, Rijksuniversiteit, Trans 14, 3512 JK Utrecht, Holland 
M.A. RUsher, ISSCO, University of Geneva, 1211 Geneve 4, Switzerland 
G.B. Varile, Commission of the European Conm~unities, P.O. Box 1907, Luxembourg 
ABSTRACT 
Starting from the assumption that machine 
translation (MT) should be based on 
theoretically sound grounds, we argue that, 
given the state of the ar t ,  the only v iab le  
solution for the designer of software tools for 
MT, is to provide the linguists building the MT 
system with a generator of highly specialized, 
problem oriented systems. We propose that such 
theory sensitive systems be generated 
automatically by supplying a set of definitions 
to a kernel software, of which we give an 
informal description in the paper. We give a 
formal functional definition of its architecture 
and briefly explain how a prototype system was 
built. 
I. INTRODUCTION 
A. Specialized vs generic software tools for MT 
Developing the software fo r  a spec i f i c  task 
or class of tasks requires that one knows the 
structure of the tasks involved. In the case of 
Machine Translation (MT) this structure is not a 
priori known. Yet it has been envisaged in the 
planning of the Eurotra project that the 
software development takes place before a 
general MT theory is present. This approach has 
both advantages and disadvantages. It is an 
advantage that the presence of a software 
framework will provide a formal language for 
expressing the MT theory, either explicitly or 
implicitly. On the other hand this places a 
heavy responsibility on the shoulders of the 
software designers, since they will have to 
provide a language without knowing what this 
language will have to express. 
We are grateful to the Commission of the 
European Communities for continuing support 
for the Eurotra Machine Translation project 
and for permission to publish this paper; 
and also to our colleagues in Eurotra for 
many interesting and stimulating 
d iscuss ions .  
** order  not  s ign i f i cant  
There are several ways open to the 
software designer. One would be to create a 
framework that is sufficiently general to 
sccomodate any theory. This is not very  
attractive, not only because this could 
trivially be ach ieved  by selecting any 
ex is t ing  programming language,  but  a l so  
because  th i s  would not  be of  any he lp  fo r  the  
people doing the linguistic work. Another, 
equally unattractive alternative would be to 
produce a very  spec i f i c  and spec ia l i zed  
formalism and offer this to the linguistic 
community. Unfortunately there i s  no way to 
dec ide  in a sensible way in which d i rec t ions  
this formalism should be specialized, and 
hence it would be a mere accident if the 
device would turn out to be adequate. What is 
worse, the user of the formalism would spend a 
cons iderab le  amount of h is  time t ry ing  to 
overcome its deficiencies. 
In other words, the difficulties that face 
the des igner  of such a software system is that 
it is the user of the system, in our case the 
linguist, who knows the structure of the 
problem domain, but is very often unable to 
articulate it until the language for the 
transfer of domain knowledge has been 
established. Although the provision of such a 
language gives the user the ability to express 
himself, it normally comes after fundamental 
decisions regarding the meaning of the 
language have been frozen into the system 
architecture. At this point, it is too late 
to do anything about it: the architecture will 
embody a certain theoretical conTaitment which 
delimits both what can be said to the system, 
and how the system can handle what it is 
told. This problem is particularly severe 
when there is not one user, but several, each 
of whom may have a different approach to the 
problem that in their own terms is the best 
one. 
This requires a considerable amount of 
\[!exibility to be built into the system, not 
only within a specific instance of the system, 
but as well across instances, since it is to 
be expected that during the construction phase 
of an MT system, a wide variety of theories 
will be tried (and rejected) as possible 
candidates. 
226 
In  o rder  to  best  su i t  these  apparent ly  
conf l i c t ing  requ i rements  we have taken the 
fo l low ing  des ign  dec is ions  : 
1. On the one hand, the so f tware  to  be 
des igned w i l l  be or iented  towards a c lass  of  
abstract systems (see below) rather than one 
specific system. This class should be so 
res t r i c ted  that  the dec is ions  to  be taken dur ing  
the l ingu is t i c  development of  the end user  
system have d i rec t  re levance  to the l ingu is t i c  
problem domain, wh i le  power fu l  enough ~o 
accommodate a var ie ty  of  l ingu is t i c  s t ra teg ies .  
2. On the o ther  hand, jus t  spec i fy ing  a 
c lass  of  systems would be insu f f i c ient ,  g iven 
our expectat ion  that  the h igh ly  exper imenta l  
nature  of  the l ingu is t i c  development phase w i l l  
g ive r i se  to  a vas t  number of  exper lmenta l  
ins tant ia t ions  of  the system,  which should  not  
lead to  cont inuous ly  c reat ing  complete ly  new 
vers ions  of  the system.  What is  needed is  a 
coherent  se t  of  so f tware  too ls  that  enable  the 
system deve lopers  to  adapt  the system to  changes 
wi th  a minimal amount of  e f fo r t ,  i . e .  a sys tem 
generator .  
Thus, we re jec t  the view that the 
arch i tec ture  shou ld  ach ieve th i s  f lex ib i l i ty  by 
s imply  evading theoret i ca l  commitment. Ins tead  
i t  shou ld  be capable  of  d i sp lay ing  a whole range 
of  h igh ly  spec ia l i zed  behav iours ,  and there fore  
be capab le  of  a h igh degree of  in terna l  
reconf igurat ion  accord ing  to externa l ly  supp l ied  
spec i f i ca t ions .  In o ther  words we aim at  a 
system which is  theory  sens i t ive .  
In our ph i losophy  the reconf igurat ion  of  
the system should  be ach ieved by supp ly ing  the 
new spec i f i ca t ions  to the system rather  than to 
a team in charge of  redes ign ing  the sys tem 
whenever new needs fo r  the user  a r i se .  
There fore  the par t  of  the sys tem that  is  v i s ib le  
to the l ingu is t i c  user  w i l l  be a sys tem 
generator ,  ra ther  than an ins tance  of  an MT 
system. 
B. Computat iona l  Paradigm for  MT Sof tware  
The computat iona l  paradigm we have chosen 
fo r  the systems to be generated  i s  the one of  
exper t  systems because the des ign  of  so f tware  
fo r  an MT system of  the scope of  gurot ra  has 
much in common wi th  the des ign  of  a very  la rge  
exper t  system.  In  both cases  success fu l  
operation relies as much on the ease with which 
the specialist knowledge of experts in the 
problem domain can be communicated to  and used 
by the sys tem as on the programming sk i l l  o f  the 
so f tware  des igners  and implementers .  Typ ica l ly ,  
the des igners  of  exper t  systems accommodate the  
need to incorporate  la rge  amounts of  spec ia l i s t  
knowledge in a f lex ib le  way by a t tempt ing  to  
bu i ld  in to  the system des ign  a separat ion  
between knowledge of  a domain and the way in 
which that  knowledge is  app l ied .  The 
character i s t i c  a rch i tec ture  of  an exper t  
system is  in the form of  a P roduct ion  System(PS)  
(c f  Davis & King 1977).  
A progranuuing scheme is  convent iona l ly  
p ic tured  as hav ing two aspects  ( "A lgor i thms + 
Data = Programs")  - -  ( c f  Wirth 1976); a 
p roduct ion  system has three  : a data  base ,  a 
set  of  ru les  (somet imes ca l led  'p roduct ions '  
- -  hence the name), and an in terpreter .  Input  
to  the computat ion  is  the in i t ia l  s ta te  of the 
data  base .  Rules cons is t ,  exp l i c i t l y  or  
imp l i c i t l y ,  of  two par ts  : a pat tern  and an 
act ion .  Computat ion proceeds  by progress ive  
mod i f i ca t ions  to  the  data  base as the 
in terpreter  searches  the data  base and 
a t tempts  to  match pat terns  in ru les  and app ly  
the cor respond ing  act ions  in the event  of  a 
success fu l  match.  The process  ha l t s  e i ther  
when the in terpreter  a t tempts  to app ly  a 
ha l t ing  ac t ion  or  when no more ru les  can be 
app l ied .  
Th is  k ind of  o rgan isat ion  i s  c lear ly  
a t t rac t ive  fo r  knowledge-based computat ions .  
The data  base  can be set  up to model ob jec ts  
in the problem domain. The ru les  represent  
smal l ,  modular  i tems of  knowledge, whose 
syntax  can be ad jus ted  to  re f lec t  fo rmal i sms 
wi th  which exper t  users  are  fami l ia r .  And the 
in terpreter  embodies a genera l  p r inc ip le  about  
the appropr ia te  way to  app ly  the exper t  
knowledge coded in to  the  ru les .  Given an 
appropr ia te  problem domain, a good exper t  
sys tem des ign  can make i t  appear  as i f  the  
s ta tement  of  exper t  knowledge is  ent i re ly  
dec la ra t ive  - -  the idea l  s i tuat ion  from the 
user ' s  po in t  o f  v iew. 
A major  aim in des ign ing  Eurot ra  has been 
to  adapt  the essent ia l  dec la ra t ive  sp i r i t  of  
p roduct ion  systems to the requ i rements  of  a 
sys tem for  la rge  sca le  machine t rans la t ion .  
The reason  fo r  adapt ing  the arch i tec ture  of  
c lass ica l  exper t  sys tems to  our  spec ia l  needs 
was that  the s imple  product ion  system scheme 
i s  l i ke ly  to  be inadequate  fo r  our purposes .  
In  fac t ,  the success  of  a c lass ica l  PS 
model in a g iven domain requ i res  that  a number 
of  assumpt ions  be sat i s f ied ,  namely: 
1. that  the knowledge requ i red  can be 
appropr ia te ly  expressed  in the form of  
p roduct ion  ru les ;  
2. that  there  ex is ts  a s ing le ,  un i fo rm 
pr inc ip le  fo r  app ly ing  that  knowledge; 
3. f ina l ly ,  that  the pr inc ip le  of  app l i ca t ion  
i s  compat ib le  w i th  the  natura l  express ion  of  
such knowledge by an exper t  user .  
227 
In machine translation, the domain of 
knowledge with which we are primarily 
concerned is that of language. With respect to 
assumption (I), we think automatically of 
rewrite rules as being an obvious way of 
expressing linguistic knowledge. Some caution 
is necessary, however. 
First of all, rewrite rules take on a 
number of different forms and interpretations 
depending on the l ingu is t i c  theory  w i th  which 
they are assoc ia ted .  In the s imples t  case ,  they  
are mere ly  c r i te r ia  of  the we l l - fo rmedness  of  
strings, and a co l lec t ion  o f  such ru les  is  
s imply equ iva lent  to a recogn i t ion  dev ice .  
Usually, however, they are also understood as 
describing pieces of tree structure, although in 
some cases -- phrase structure rules in 
particular -- no tree structure may be 
explicitly mentioned in the rule: a set of such 
rules then corresponds to some kind of 
transducer rather than a simple accepting 
automaton. 
The point is that rules which look the same 
may mean different things according to what is 
implicit in the formalism. When such rules are 
used to  dr ive  a computat ion ,  everything which is 
imp l i c i t  becomes the respons ib i l i ty  o f  the 
in terpreter .  This  has two consequences  : 
a. if there are different interpretations of 
rules according to the task which they are 
supposed to perform, then we need different 
interpreters to in terpret  them, which is  
contrary to assumption (2); an obvious case is 
the same set of phrase structure rules used to 
drive a builder of phrase structure trees given 
a string as input, and to drive an integrity 
checker given a set of possibly well-formed 
trees; 
b. alternatively, in some cases, information 
which is implicit for one type of interpreter 
may need to be made explicit for another, 
causing violation of assumption (3); an obvious 
case here is the fact that a phrase structure 
analyser can be written in terms of 
transductions on trees for a general rewrite 
interpreter, but at considerable cost in clarity 
and security. 
Secondly, it is not evident that 'rules', 
in either the pattern-action or the rewrite 
sense, are necessarily the most appropriate 
representation for all linguistic description. 
Examples where other styles of expression may 
well be more fitting are in the description of 
morphological paradigms for highly inflected 
languages or the formulation of judgements of 
relative semantic or pragmatic acceptability. 
The organisational complexity of Eurotra 
also poses problems for software design. Quite 
separate strategies for analysis and synthesis 
will be developed independently by language 
groups working in their own countries, 
a l though the resu l t s  of  th i s  decent ra l i sed  and 
distributed development will ultimately have 
to be combinable together into one integrated 
translation system. What is more, new 
l anguages  or  sub languages  may be added at  any 
t ime,  requ i r ing  new s t ra teg ies  and modes of  
descr ip t ion .  
Finally, the Eurotra software i s  intended 
not only as the basis for a single, large MT 
system,  but  as a genera l  purpose  fac i l i ty  fo r  
researchers  in MT and computat iona l  
linguistics in genera l .  
These extra considerations impose 
requirements of complexity, modularity, 
extensibility and transparency not commonly 
expected of today's expert systems. 
The conclusion we have drawn from these 
and similar observations is that the 
inflexible, monolithic nature of a simple PS 
is far too rigid to accommodate the variety of 
diverse tasks involved in machine 
translation. The problem, however, is one of 
size and complexity, rather than of the basic 
spirit of production systems. 
The above considerations have led us to 
adopt the principle of a controlled production 
system, that is a PS enhanced with a control 
language (Georgeff 1982). The elements of the 
vocabulary of a control language are names of 
PSs, and the well-formed strings of the 
language define just those sequences of PS 
applications which are allowed. The user 
supplies a control 'grammar', which, in a 
concise and perspicuous way, specifies the 
class of allowable application sequences. Our 
proposal for Eurotra supports an enhanced 
context free control language, in which names 
of user-defined processes act as non-terminal 
symbols. Since the language is context free, 
process definitions may refer recursively to 
other processes, as well as to gran~aars, whose 
names are the terminal symbols of the control 
language. 
A grammar specifies a primitive task to be 
performed. Like a production system, it 
consists of a collection of declarative 
statements about the data for the task, plus 
details of the interpretation scheme used to 
apply the declarative information to the data 
base. Again, as in a production system, it is 
important that the information in the 
declarative part should be homogeneous, and 
that there should be a single method of 
application for the whole grammar. We depart 
somewhat from conventional productions system 
philosophy in that our commitment is to 
declarative expression rather than to 
production rules. 
228 
The dev ice  of  us ing  a cont ro l  language to  
de f ine  the organ lsat ion  of  a co l lec t ion  of  
grs~muars prov ides  the user  w i th  a power fu l  too l  
fo r  s imu la t ing  the procedura l  knowledge inherent  
in const ruct ing  and tes t ing  s t ra teg ies ,  w i thout  
depar t ing  rad ica l ly  from an essent ia l l y  
dec la ra t ive  framework.  
An important feature of our design 
methodology is the commitment to interaction 
with potential users in order to delineate the 
class of tasks which users themselves feel to be 
necessary. In this way, we aim to avoid the 
error which has often been made in the past, of 
presentin 8 users with a fixed set of selected 
generally on computational grounds, which they, 
the users, must adjust to their own requirements 
as best they can. 
II OVERVIEW OF THE SYSTEM GENERATOR 
The task  of  our  users  is  to  des ign  the 
problem or iented  machine here  ca l led  "eurot ra" .  
Our cont r ibut ion  to th i s  task  is  to prov ide  them 
wi th  a machine 1 in terms of  which they can 
express  the i r  percept ion  of  so lu t ions  to  the 
problem (bear ing  in mind a l so  that  we may need 
to accommodate in the fu ture  not  on ly  
mod i f i ca t ions  to users ' s  percept ion  of  the 
so lu t ion  but a l so  to the i r  percept ion  of  the 
problem i t se l f ) .  
I t  i s  c lear ly  unreasonab le  to  expect  users  
to express  themse lves  d i rec t ly  in terms of  some 
computer ,  espec ia l l y  g iven the character i s t i cs  
o f  the convent iona l  von Neumann computers  which 
we can expect  to be ava i lab le  in the inuuediate 
fu ture .  The normal s t ra tegy ,  which we adopt i s  
to  des ign  a prob lem-or iented  language which then 
becomes the users' interface to a special 
purpose virtual machine, mediated by a compiler 
which transforms solutions expressed in the 
prob lem-or iented  language in to  programs which 
can be run d i rec t ly  on the appropr ia te  
computer .  Funct iona l ly ,  can express  th i s  in the  
fo l low lng  way : 
We use the term "computer" to refer to a 
phys ica l  ob jec t  implemented in hardware ,  
wh i le  "machine" is  the ob jec t  w i th  which a 
programmer communicates.  The essence  of  
the task  of  des ign ing  so f tware  too ls  i s  to  
t rans form a computer in to  a machine which 
cor responds  as c lose ly  as poss ib le  to  the 
terms of  the problem domain of  the user  fo r  
whom the tools are written. 
eurot ra  = compi le r  : usd 2 
where usd s tands  fo r  "user  so lu t ion  
de f in i t ion" .  We can dep ic t  the arch i tec ture  
graph ica l ly  as : 
usd 
COMPILER 
,L 
source text --~ COMPUTER --~ target text 
F ig .  1 
In  Symbols : 
( compi le r  : usd) : text  -9  text  
The p ic ture  above is  c lear ly  s t i l l  an 
overs impl i f i ca t ion .  In  the f i r s t  p lace ,  such 
a compi le r  would be enormous ly  d i f f i cu l t  to  
wr i te  and mainta in ,  g iven the  t remendous 
complex i ty  of  the poss ib le  so lu t ion  space of  
Machine Trans la t ion  problems which the  
compi le r  i s  in tended to represent .  Secondly ,  
espec ia l l y  in the l ight  of  our  observat ion  
above that  the users '  v iew of  the problem 
space i t se l f  may change,  i t  would be very  
unwise to  invest  enormous e f fo r t  in the  
const ruct ion  of  a very  complex compi le r  which 
may turn  out  in the end to be const ructed  to  
accept  so lu t ions  to  the wrong c lass  of  
p rob lems.  
Fo l low ing  we l l -es tab l i shed  so f tware  
eng ineer ing  pract i ce ,  we can compensate fo r  
th i s  d i f f i cu l ty  by us ing  a compi le r  generator  
to  generate  appropr ia te  compi le rs  ra ther  than 
bu i ld ing  a complete new compi le r  from 
scratch .  Apart  from making the ac tua l  p rocess  
of  compi le r  const ruct ion  more rap id ,  we 
observe  that  use of  a compi le r  generator  has 
impor tant  benef i c ia l  s ide  e f fec ts .  F i r s t ly ,  
i t  enab les  us to  concent ra te  on the cent ra l  
i ssue  of  language des ign  ra ther  than secondary  
quest ions  of  compi le r  imp lementat ion .  
Secondly ,  i f  we choose a we l l -des igned 
compi le r  generator ,  i t  tu rns  out  that  the  
descr ip t ion  of  the user  language which i s  
input  to  the generator  may be very  c lose  to  an 
abst rac t  spec i f i ca t ion  of  the  language,  and 
hence in an impor tance  sense  a descr ip t ion  of  
the  potent ia l  of  the  user  machine.  
2 For  the  remainder  of  th i s  sect ion  we sha l l  
use the  notat ion  
x :y -~ z 
with  the  in fo rmal  meaning of  "app l i ca t ion  o f  x 
to  y y ie lds  resu l t  z " ,  or  "execut ion  of  x w i th  
input  y g ives  output  z" .  
229 
Af ter  the in t roduct ion  of  a compi le r  
generator  the p ic ture  of  our  a rch i tec ture  looks 
l l ke  th i s  (u ld  s tands  fo r  "user  language 
def in t ion" ;  CGstands  fo r  "compi le r  generator" ) :  
usd 
uld ---~ CG ---9 COMPILER 
source text -- ~ COMPUTER -- target text 
Fig. 2 
In symbols : 
((CG : uld) : usd) : text -~ text 
For many software engineering projects this 
might be an entirely adequate architecture to 
support the design of problem oriented systems. 
In OUr case, however, an architecture of this 
kind only offers a partial resolution of the two 
important issues already raised above : 
incomplete knowledge of the problem domain, and 
complex i ty  of  the semant ics  of  any poss ib le  
so lu t ion  space.  The use of  a compi le r  generator  
cer ta in ly  he lps  us to separate  the problem of  
de f in ing  a good user  language from that  of  
implementing it. It also gives us the very 
important insight that the use of generators as 
design tools means that in optimal cases input 
to the generator and formal specification of the 
machine to be generated may be very close or 
even identical. However, we really only are 
addressing the question of finding an 
appropriate syntax in which users can formulate 
solutions in some problem domain; the issue of 
def in ing  the semant ics  under ly ing  that  syntax ,  
o f  s ta t ing  fo rmal ly  what a par t i cu la r  so lu t ion  
means is  still open. 
We can perhaps make the point more 
explicitly by considering the conventional 
decomposition of a compiler into a parser and a 
code generator (cf, for example, Richards and 
Whitby-Strevens 1979). The function of the 
parser is to transform a text of a programming 
language into a formal object such as a parse 
t ree  which is  syntact i ca l ly  un i fo rm and easy to 
descr ibe ;  th i s  ob jec t  i s  then t rans formed by the 
code generator into a semantically equivalent 
text  in the language of  the ta rget  machine. 
With in th i s  approach,  i t  i s  poss ib le  to 
contemplate  an organ isat lon  which,  in la rge  
measure, separates the manipulation of the 
syntax of a language from computation of its 
meaning. Since the syntactic manipulation of 
programming languages is by now well understood, 
we can take advantage of this separation to 
ar r ive  at  formal  de f in i t ions  of language syntax  
which can be used d i rec t ly  to generate  the 
syntact i c  component of a compi le r .  The process  
of automatically computing the meaning of a 
program is, unfortunately much more obscure. 
Our task  is  rendered  doubly d i f f i cu l t  by 
the fac t  that  there  is  no obv ious  re la t ion  
between the k ind of  user  program we can expect  
to have to t reat  and the s t r ing  of  von Neumann 
ins t ruct ions  which even the most advanced 
semant ica l ly  o r iented  compi le r  generator  i s  
l i ke ly  to  be tuned to produce.  
We can ga in  some ins ight  in to  a way round 
th i s  d i f f i cu l ty  by cons ider ing  s t ra teg ies  l i ke  
the one descr ibed  fo r  BCPL (R ichards  and 
Whitby-Strevens, clt). In this two-stage 
compi le r ,  the input  program i s  f i r s t  
t rans la ted  in to  the  language of  a 
pseudo-mach ine ,  known as O-code. The 
implementer  then has the cho ice  of  
implement ing an O-code machine d i rec t ly  as an 
in terpreter  or  of wr i t ing  a second stage 
compi le r  which t rans la tes  an O-code program 
in to  an equ iva lent  program which i s  runnab le  
d i rec t ly  on ta rget  machine.  This  techn ique ,  
which is relatively well established, is 
normally used as a means Of constructing 
easily portable compilers, since only the 
second-stage intermediate code to target code 
translation need be changed, a job which is 
rendered much easier by the fac t  that the 
input language to the translation is invariant 
over all compilers in the family. 
Clear ly  we cannot  adopt th i s  model 
d i rec t ly ,  s ince  O-code in o rder  to be 
optimally portable is designed as the language 
of a generic stack-oriented yon Neumann 
machine, and we have made the point repeatedly 
that yon Neumann architectures are not the 
appropriate point of reference for the 
semantics of MT definitions. However, we can 
also see the same organisation in a different 
light, namely as a device for allowlng us to 
build a compiler for languages whose semantics 
are not necessarily fully determined, or at 
least subject to change and redefinition at 
short notice. In other words, we want to be 
able to construct compilers which can compile 
code for a class of machines, so as to 
concentrate attention on f ind ing  the most 
appropriate member of the class for the task 
in hand. 
we now have a system architecture in which 
user solutions are translated into a 
syntactically simple but semantically rather 
empty intermediate language rather than the 
native code of a real computer. We want to be 
able easily to change the behaviour of the 
associated virtual machine, preferably by 
adding or changing external definitions of its 
functions. We choose to represent this 
machine as an interpreter for a functional 
language; there are many reasons for this 
choice, in particular we observe here that 
such machines are characterised by a very 
simple evaluator which can even accept 
externa l  redef in i t ions  of itself and apply  
230 
them dynamica l ly ,  i f  necessary ;  they  typ ica l ly  
have a very  s imple  syntax  - normal ly  composed 
on ly  of  atoms and tup les  - which i s  s imple  fo r  a 
compi le r  to  generate ;  and the funct ion  
de f in i t ions  have,  in programming terms,  a very  
t rac tab le  semant ics  which we can exp lo i t  in 
ident i fy ing  an ins tance  of  an exper imenta l  
implementat ion  wi th  a fo rmal  system def in i t ion .  
With the add i t ion  of  the in terpreter  
s lmu la t ing  the abst rac t  machine,  our  in fo rmal  
p ic ture  now looks l i ke  th i s  : 
u ld - -~ CG- -~ 
source  text --3 
usd 
COMPILER 
INTERPRETER --~ 
COMPUTER 
ta rget  text 
F ig .  3 
or  in symbols : 
(INTERPRETER : ((CG:uld) : usd)) : text -~ text 
We now turn  to the kind of  de f in i t ions  
which we sha l l  want to in t roduce  in to  th i s  
system.  We decompose the funct ion  of  the 
machine not iona l ly  in to  cont ro l  funct ions  and 
data  man ipu la t ion  funct ions  ( th i s  decompos i t ion  
i s  impor tant  because of  the great  importance of  
pat tern -d i rec ted  computat ions  in ~rr). 
In fo rmal ly ,  in de ference  to the in terna l  
o rgan isat ion  of  more convent iona l  mach ines ,  we 
sometimes re fer  to the funct iona l i ty  of  these  
two parts with the terms CPU and MMU, 
respectively. What we want to do is to make the 
"empty" kerne l  machine in to  a complete and 
e f fec t ive  computing dev ice  by the  add i t ion  of  a 
se t  o f  de f in i t ions  which : 
a l low the kerne l  in terpreter  to d i s t ingu ish  
between cont ro l  operat ions  and data  
operat ions  in an input  language const ruct ;  
de f ine  the complete set  of  cont ro l  
operat ions ;  
de f ine  the domain of  lega l  data  
conf igurat ions  and operat ions  on them. 
With these  add i t ions ,  the complete 
arch i tec ture  has the form : 
FP : cont ro lde f  - -~  
REL : datadef  - -~  
languages  
usd 
LR(k) : uld -~  CG --~ COMPILER 
inner  prog. 
CPU l 
I 
I 
~ w 
! 
! 
KERNEL I 
$ 
COMPUTER 
F ig .  4 
or  symbo l i ca l ly ,  wr i t ing  "adder"  fo r  the name 
of  the funct ion  which adds de f in i t ions :  
(((adder : controldef,datadef ) : KERNEL) 
: ((CG : uld) : usd)) : text -~ text 
Capitalized symbols denote components 
which are part of the system generator, while 
lower case symbols denote definitions to 
generate a system instance. 
An alternative way of describing Fig 4. is 
to see the system generator as consisting of a 
set of generators (languages and programs). 
The languages of the generator are : 
a. an LR(k) language for defining the user 
language syntax (cf Knuth 1965); 
b. a funct iona l  programming (FP) language fo r  
de f in ing  the semant ics  of  the user  supp l ied  
cont ro l  ( fo r  FP cf  Backus 1978); 
c. a re la t lona l  language (REL) fo r  de f in ing  
the semant ics  of  user  de f ined  pat tern  
descr ip t ions ;  
d. the de f in i t ion  of  the inner  program 
syntax  (see  APPENDIX). 
The programme of  the system,  which ,  
supp l ied  w i th  the appropr ia te  de f in i t ions ,  
w i l l  generate  sys tem ins tances ,  are  : 
e. a compiler-compiler defined functionally 
by a. and d. in such a way that for each token 
of user  language syntax  de f in i t ion  and each 
token of  user  program expressed  in th i s  syntax  
i t  w i l l  generate  a un ique token of  inner  
program. 
f. a CPU, which is essentially an FP system, 
to be complemented with the definitions of 
point b. The CPU is responsible for 
interpreting the scheduling (control) parts of 
231  
the user program. It can pass control to the 
MMU at defined points. 
g. a MMU to be complemented with the 
definitions of point c. The MMU is responsible 
for manipulating the data upon request of the 
CPU. 
Given the above scheme, a token of  a 
problem or iented  system for  processing user  
programs is obtained by supplying the de f in i t ion  
o f  : 
- the user language syntax;  
- the semantics of the control descriptions; 
- the semantics of the data pattern 
descriptions; 
- the expansion of certain nonterminal 
symbols of the inner program syntax.  
Note that a primitive (rule-)execution 
scheme ( i .e .  a grammar),  i s  obta ined  recurs ive ly  
in the same way, modulo the mod i f i ca t ion  
necessary  g iven the d i f fe rent  meaning of  the 
cont ro l  def in i t ion .  
I I I .  FORMAL DEFINITION OF THE 
SYSTEM GENERATOR'S ARCHITECTURE 
This section presupposes some knowledge of 
FP and FFP (cf. Backus cit, Williams 1982). 
Readers unfamiliar with these formalisms may 
skip this section. 
We now give a formal definition of the 
generator's arch i tec ture  by funct iona l ly  
de f in ing  a mon i to r  M fo r  the machine dep ic ted  in 
F ig.  4. We w i l l  do so by de f in ing  M as an FFP 
funct iona l  ( i .e .  h igher  o rder  funct ion)  (c f .  
Backus c i t ,  Williams c i t ) .  
An FP system has a set of functions which 
is fully determined by a set of primitive 
functions, a set of functional forms, and a set 
of definitions. 
The main difference between FP systems and 
FFP systems is that in the latter objects (e.g. 
sequences) are used to represent functions, 
which has as a consequence that in FFP one can 
create new functionals. The monitor M is just 
the definition of one such'functional. 
Sequences in FFP represent functionals in 
the following way : there is a representation 
function D (which belongs to the representation 
system of FFP, not to FFP itself) which 
associates objects and the functions they 
represent. 
The association between objects and 
functions is given by the following rule 
(metacompos i t ion)  : 
(p <x l  . . . . .  xn>)  : y = 
(o xl)  :~x l  . . . . .  xn> ,y> 
The formal definition of the overall 
architecture of the system is obtained by the 
following FFP definition of its monitor M : 
D ~M,  uld, cd, dd~ : usd = ~M):<<pM, uld, cd, 
dd >, usd> wi th  : 
M E app ly . \ [capp ly , l ' \ [app ly l "  
\ [app ly2" \ [  yapp ly ,2 -1 \ ]  , 23, 
apply.\[~(3-1), 'CD3 , 
app ly ' \ [~(4" l ) , 'DDT\ ] \ ]  
where : 
M is the name of the system monitor 
uld is the user language definition in BNF 
cd is the control definition (controldef in 
Fig 4.) 
dd is the data definition (datadef in Fig 4.) 
usd is the user solution definition 
The meaning of the definition is as 
follows : 
M is defined to be the application of 
capply to the internal programe ip 
apply : <capply, ip.> 
capply is the semantic definition of the 
machine's CPU (see below). 
ip is obtained in the following way : 
app ly l  : ~app ly2  : ~yapp ly ,u ld>,  usd> 
Where apply2 : Cyapp ly ,  uld~ yields the 
COMPILER which is then applied to the usd. 
For a definition of applyl, apply2, yapply 
see the section on the implementation. 
apply" \[;(3-1), 'CD\] 
and 
apply" \[4(4"1), 'DD \] 
just add definitions to the control, reap. 
data definition stores of the CPU and the MMU 
respectively. 
is the 'store' functional of FFP. 
A. Semantic Definition of the CPU 
As mentioned earlier, the bare CPU 
consists essentially of the semantic 
definition of an FP-type application 
mechanism, the set of primitive functions and 
functionals being the ones defined in standard 
FP. 
232 
The app l i ca t ion  mechanism of  the CPU i s  
ca l led  capp ly ,  and i t s  de f in i t ion  i s  as fo l lows  : 
p(x) = x s A ~ ? ;  
x = <xl . . . . .  xn> ~ (~x l  . . . . .  ~xn > ; 
? = (y:z) 
(yeA & (~:DD) = T ~ mapply:~y,z> ; 
yea & (~:CD) = # ->~((py) (~z)); 
yaA & (~:CD) = w ->~(w:z); 
y = <y l  . . . . .  yn)~(y l :<y ,z> ); 
~(~y:z ) ) ;  
be ing the FFP semant ic  funct ion  de f in ing  the 
meaning of  ob jec ts  and express ions  (which 
be longs  to the descr ip t ive  system of  FFP, not  to  
FFP i t se l f ,  ( c f  Backus c i t ) ) .  
The funct iona l i ty  o f  ~ is  
: Express ion  -> Ob ject  
that  i s ,  ~ assoc ia tes  to each FFP express ion  an 
ob jec t  which i s  i t s  meaning. It i s  de f ined  in 
the fo l low ing  way : 
x i s  an ob jec t  -> ~x = x 
e = <e l  . . . . .  en> is  an express ion  -> 
~ef~e l  ..... pen> 
i f  x ,y  are  ob jec ts  -> ~(x :y )  = ~(~:y)  
where OX is  the funct ion  represented  by the 
ob jec t  x. 
i s  the FFP funct iona l  ' fe tch '  
DD is  the de f in i t ion  s tore  of  the MMU 
CD is  the de f in i t ion  s tore  of  the CPU 
# i s  the resu l t  o f  an unsucces fu l  search  
mapply is  the apply  mechanism of  the MMU 
The execut ion  of  a pr imi t ive  ( i .e .  a 
granuuar) represents  a recurs ive  ca l l  to  the 
mon i to r  M, modulo the d i f fe rent  funct ion  of  the 
cont ro l  in terpreter  ( the  CPU). 
For the res t ,  as fa r  as the user  language 
def in i t ion  is  concerned th ings  remain unchanged 
(remember that  i f  appropr la te , the  language fo r  
express ing  knowledge ins ide  a gratmuar as we l l  as 
the  data  s t ruc ture  can be redef ined  fo r  
d i f fe rent  p r imi t ives ) .  
The recurs ive  ca l l  o f  M is  caused by capp ly  
whose def in i t ion  has to  be augmented by 
inser t ing  a f te r  l ine  6 Of the de f in i t ion  g iven 
above ~he fo l low ing  eondt%ion|  
y = app lypr lm 9 <M,uld,cd,dd) :x 
where x i s  the spec i f i ca t ion  of  the pr imi t ive  
(e .g .  the  ru le  set ) .  
IV. EXPERIMENTAL IMPLEMENTATION 
An exper imenta l  imp lementat ion  of  the  
arch i tec ture  descr ibed  above has to  accomodate 
two d is t inc t  a ims.  F i r s t ,  i t  must re f lec t  the 
proposed  funct iona l i ty ,  which i s  to say ,  
rough ly ,  that  the par ts  out  o f  which i t  i s  
made cor respond in content ,  in funct ion  and 
in ter re la t ionsh ip  to  those  la id  down in the  
des ign .  Second, i t  must ,  when supp l ied  wi th  a 
set  of  de f in i t ions ,  generate  a system ins tance  
that  i s  both cor rect ,  and su f f i c ient ly  robust  
to be re leased  in to  the user  community to  
serve  as an exper lmenta l  too l .  
The ent i re  imp lementat ion  runs  under ,  and 
i s  par t ly  de f ined  in terms of  the Unix* 
operat ing  system.  The main reason  fo r  th i s  
cho ice  is  that  from the  s tar t ,  Unix has been 
conce ived as a funct iona l  a rch i tec ture .  What 
the user  sees  i s  externa l ly  de f ined ,  be ing the  
resu l t  of  app ly ing  the Unix kerne l  to  a she l l  
program. Fur thermore ,  the s tandard  she l l ,o r  
csh , i t se l f  p rov ides  us w i th  a language which 
can both descr ibe  and const ruct  a complex 
system,  essent ia l l y  by having the vocabu lary  
and the const ructs  to  express  the  
decompos i t ion  of  the  whole in to  more pr imi t ive  
par ts .  We sha l l  see some examples of  th i s  
below. 
Another  reason  fo r  the cho ice  of  Unix i s  
the  ava i lab i l i ty  o f  su i tab le ,  ready-made 
so f tware  that  has turned  out  to  be su f f i c ient ,  
in la rge  measure ,  to  const ruct  a respectab le  
first approximation to the system. Finall~, 
the  decent ra l i sed  nature  of  our  p ro jec t  
demands that  exper imenta l  imp lementat ions  
shou ld  be maximal ly  d i s t r ibutab le  over  a 
potent ia l l y  la rge  number of  d i f fe rent  hardware 
conf igurat ions .  At p resent ,  Unix i s  the on ly  
pract i ca l  cho ice .  
A. System Components 
The system consists of 4 main parts, these 
be ing  : 
a. A user  language compi le r  generator .  
b. A cont ro l  de f in i t ion  generator .  
c.  a kerne l  CPU. 
d. A data  de f in i t ion  generator .  
These modules ,  together  w i th  a user  
language descr ip t ion ,  a cont ro l  descr ip t ion ,  
and a data  descr ip t ion ,  are  su f f i c ient  to  
spec i fy  an ins tance  of  the system.  
1. User  Language Compi ler  Generator  
YACC 
After rev iewing  a number of 
compi le r -compi le rs ,  i t  was dec ided to  use YACC 
* UNIX i s  a t rademark  of  the Be l l  Laborator ies  
233 
(Johnson 1915). Quite apart from its 
availability under Unix, YACC accepts an LALR(1) 
grammar, a development of LR(k) 
grammars (Knuth cit; Aho & Johnson (1974). LALR 
parsers (Look Ahead LR) give considerably 
smaller parsing tables than canonical LR 
tables. The reader is referred to Aho & Ullman 
(1977) which gives details of how to derive LALR 
parsing tables from LR ones. 
LEg 
LEX (Lesk 1975) generates lexlcal anslysers, 
end is designed to be used in conjunction with 
YACC. LEg accepts a specification of lexical 
rules in the form of reBular expressions. 
Arbitrary actions may be performed when certain 
strings are recognised, although in our case, 
the value of the token recognised is passed, and 
an entry in the symbol table created. 
2. Control Generator 
A user programe presupposes, and an inner 
program contains a number of control constructs 
for organlslng the scheduling of processes, end 
the performance of complex database 
manipu la t ions .  The meaning that  these  
const ruc ts  sha l l  have i s  determined  by the  
de f in i t ions  present  in the  cont ro l  s to re  o f  the  
kernel. 
The language in which we have chosen to 
define such constructs is FP (Backus cit). It 
follows that the generator must provide 
compilations of these defintions in the language 
of the kernel machine. The implementation of 
the control generator is an adaptation of 
Baden 's  (1982) FP in terpreter .  Th is  i s  a 
stand-alone program that essentially translates 
FP definitions into kernel language ones. 
3. Kernel CPU 
We are currently using the Unix Lisp 
interpreter (Foderaro & Sklower 1982) to stand 
in for FFP, although an efficient interpreter 
for the latter is under development. Notice 
that an FFP (or Lisp) system is necessary to 
implement the appllcative schema described in 
section Ill, since these systems have the power 
to describe their own evaluation mechanisms; FP 
itself does not. 
4. Data Definition Generator 
Unfortunately, we know of no language as 
suitable for the description of data as FP for 
the description of control. The reason is that 
at this moment, we are insufficiently confident 
of the basic character of data in this domain to 
make any definitive claims about the nature of 
an ideal data description \]anguage. 
We have therefore chosen to express data 
definitions in the precise, but over general 
te rms  o f  f i r s t  o rder  log ic ,  wh ich  are  then  
embedded w i th  very  l i t t le  syntact i c  
transformation into the database of a standard 
Prolog implementation (Pereira & Byrd 1982). 
The augmented interpreter then constitutes the 
MMU referred to above. The data definition 
for the current experiment presents the user 
with a database consisting of an ordered 
collection of trees, over which he may define 
arb i t ra ry  transductions. 
The CPU and MMU run in parallel, and 
communicate with each other through a pair of 
Unix pipelines usin 8 a defined protocol that 
minlmises the quantity of information passed. 
A small bootstrap program initlelises the MMU 
and sets up the pipelines. 
B. ConstructinK the System 
The decomposition of a system instance 
into parts can be largely described within the 
shell language. Figure 5. below summarises 
the organisation using the convention that a 
module preceded by a colon is constructed by 
executing the shell commands on the next 
l i ne .  The runnab le  vers ion  o f  f igure  4. ( that  
conta ins  ra ther  more odd symbols )  conforms to  
the  input  requ i rements  o f  the  Unix 'make '  
program.  
targettext : 
( (cpu<bootstratp)< eurotra)< sourcetext 
> targettext / *capp ly* /  
eurotra : 
compi le r  < usd  >eurot ra  / *app ly  I * /  
COMPILER : 
yacc <u ld  \[ cc~compi le r  / *app ly  2* /  
cont ro lde f  : 
fpcomp < cd> cont ro lde f  
MMU : 
echo ' save(mmu) '  I pro log  dd 
CPU : 
echop '(damplisp cpu)' I l isp<controldef  
F ig .  5 
V. CONCLUSION 
We have arBued for the need of 
theory-specific software for computational 
linguistics. 
In cases where, as in MT, such a theory is 
not available from the beginning of a project. 
hut rather, is expected as a result of it, we 
have argued for the need of a problem-oriented 
system generator .  
234 
We have proposed a so lu t ion  by which,  
s ta r t ing  from the not ion  of  a compi le r  generator  
d r iven  by an externa l  de f in i t ion ,  one ar r ives  at  
a way of  bu i ld ing  runnab le ,  p rob lem-or iented  
systems which are a lmost  ent i re ly  externa l ly  
de f ined .  In our v iew, th i s  approach has the 
advantage,  fo r  a domain where the c lass  of  
problems to  be so lved  is  underdetermined ,  that  
the semantics of the underlying machine can be 
redefined rapidly in a clean and elegant way. 
By a care fu l  cho ice of def in i t ion  languages ,  we 
can use the de f in i t ions  s imul taneous ly  as input  
to a generator  fo r  exper imenta l  p ro to type  
imp lementat ions  and as the cent ra l  par t  o f  a 
formal  spec i f i ca t ion  of  a par t i cu la r  
app l i ca t ion -or iented  machine.  
VI  REFERENCES 
Aho, A.V & Johnson,  S.C. (1974) - LR 
pars ing .  Computing Surveys 6 : 2 
Aho, A.V .  & Ul lman,  J .V .  (1977)  - 
P r inc ip les  of Compiler Design.  Addison-Wesley.  
Backus, J (1978) - Can programming be 
l iberated  from the von Neumann s ty le?  Comm. ACM 
21 : 8. 
Baden, S. (1982) - Berke ley FP User ' s  
Manual, rev 4 .1 .  Department of  Computer 
Sc ience ,  Un ivers i ty  of  Ca l i fo rn ia ,  Berke ley .  
Davis ,  R. & King, J . J .  (1977) - An overv iew 
of  p roduct ion  sys tems,  in : E lcock,  E.W. & 
Michie,  D. (eds) -  Machine In te l l igence  B: 
Machine representat ion  of  knowledge, E l l i s  
Horwood. 
Foderaro J.K. & Skowler K. (1982). The 
Franz Lisp Manual. University of California. 
Georgeff, M.P. (1982) - Procedura l  cont ro l  
in p roduct ion  sys tems.  Ar t i f i c ia l  In te l l igence  
18 : 2. 
J ohnson ,  S.C. (1975) - Yacc : Yet another  
Compi le r -Compi le r ,  Computing Sc ience Techn ica l  
Report  No. 32, Be l l  Laborator ies ,  NJ 
Knuth, D.E. (1965) - On the translat ion of 
languages from left to right. Information and 
Control 8:6. 
Lesk, M.E. (1975) -Lex  : a Lex ica l  
Ana lyzer  Generator ,  Computing Sc ience Techn ica l  
Report  No. 39, Be l l  Laborator ies ,  NJ. 
Pere i ra  & Byrd (1982) - C -Pro log ,  Ed CAAD, 
Department of  Arch i tec ture ,  Un ivers i ty  of  
Ed inburgh.  
R ichards ,  M & Whi tby -St revens ,  C. (1979) - 
BCPL: The language and i t s  compi le r ,  Cambridge 
Un ivers i ty  Press. 
Wi l l iams,  (1982) - Notes on the  FP 
funct iona l  s ty le  of  programming,  i n :  
Dar l ington ,  J . ,  Henderson,  P. and Turner ,  D.A. 
(eds) ,  Funct iona l  programming and i t s  
app l i ca t ions ,  CUP. 
Wirth, N. (1976) - Algorithms + Data 
Structures = Programs, Prentice Hall, 
Englewood Cliffs, New Jersey. 
VI I .  APPENDIX 
Below we g ive a BNF def in i t ion  of  the 
inner  program syntax .  Cap i ta l i zed  symbols 
denote non- termina l  symbols ,  lower ease  
symbols denote te rmina ls .  
PROC : :=  <quI~> 
QUINT ::= ~NAME EXPECTN FOCUS BODY 
GOALL> 
NAME ::= IDENTIF IER  
IDENTIFIER ::= "" 
EXPECTN ::= PAT I nil 
FOCUS ::= VARPAIR 
VARPAIR ::= ~ARG ARG> 
VAR ::= VARID 
VARID ::= ** 
BODY ::= <nonpr im CEXP~pr im PRIMSP> 
CEXP ::= COMPLEX I SIMPLEX 
COMPLEX ::= ~CONTRLTYP CEXP+> 
SIMPLEX ::= NAME 
CONTRLTYP ::= serial \[ paral lel  J lterate 
PRIMSP ::= ~RULE+> 
RULE ::= <PAT PAT> 
GOALL : := <PAT z 
PAT : :ffi ~ SYMBTAB ASSERT > 
SYMBTAB : : = ARGL 
ARGL ::= <ARG + > 
ASSERT ::= ~b ASSET ASSRT>I 
<vASSRT ASSRT ~(~ASSI~> 
ASSET ::= SIMPLASSRT I ASSERT 
SIMPLASSRT ::= ~EELNAM TERML> 
EELNAM : := >1< I =l *l 
IDENTIFIER\[ 
prec \ [  domJpre f ix  I 
su f f i x  I in f ix  
TERML : : ffi <TERN ~ > 
TE~ : := ~G ! <FUSC TERm. > 
ARG ::= (TYP  VAR>\[ LITERAL null 
L ITERAL ::ffi "* 
FUNC ::ffi IDENTIFIER I length 
TYP : := node I t ree  i cha in  I bound 
For each ins tance  of  the system,  there  i s  
an ins tance  of  the inner  program syntax  which 
d i f fe rs  from the bare  inner  program syntax  in 
that  cer ta in  symbols are  expanded d i f fe rent ly  
depending on o ther  de f in i t ions  supp l ied  to  the  
system.  
** t r iv ia l  expans ions  omi t ted  here . :=  PAT* 
235 
