Using Constraints in a 
Constructive Version of GPSG 
Wilhelm WEISWEBER 
Technical University of Berlin 
Institute for Software and Theoretical Computer Science 
Project Group KIT 
Sekr. FR 5-12 
Franklinstr. 28/29 
D-1000 Berlin 10 
Email: weisweb@db0tuil 1.bitnet 
Abstract 
Complex categories are caracteristic of unification grammars as for 
example GPSG \[Shieber86a\]. They are sets of pairs of feature.s and 
values. The unification, which can be applied to two or more 
categories, is the essential operation. 
The papers of \[Shieber85\], \[Barton85\] and \[Ristad86\] deal with the 
influence of complex categories on the efficiency of the parsing 
algorithm. This is one problem from using complex categories, 
another one arises when using a constructive version of GPSG (see 
\[Busemann/Hanensehild88\] in thisvolume). Namely that the appli- 
cation of admissibility conditions, e.g. LP statements and FCRs 1, to 
a local tree t is prevented because particular feature values of eat- 
egories in t are not yet specified, but they will be instantiated later 
somewhere else in the complete tree. Similar problems are described 
? in \[Karttunen86\] for D-PATR. 
This work describes the latter problem and will present a solution 
working with computation, evaluation and propagation of 
constraints within local trees (depth 1). The constraint evaluation 
will reject local trees if the constraints of the subtrees of the 
daughters are violated. 
1 Introduction 
First of all some fundamentals of a constructive version of GPSG 
which has been developed within the projects K1T-NASEV and its 
successor KIT-FAST 2 will be described (for details see \[Hanen- 
1 LP = Linear Precedence; FCR = Feature Co-oecmenee R striction 
KIT-FAST (FAST = Functor-Argument Structure for Translation; KIT = 
Kilnstliche Intelligenz Lind Textvexsteben = Artificial Intelligence and Text 
Understanding) as well as ils predecessor KIT-NASEV (NASEV = Neue 
Analyse-und Syntheseveffahrm zur masehinellea 0bersetzang = New 
Metheds of Analysis and Synthesis fc~ Machine Translation) constitute he 
Berlin component of the complementary ~ h  project of EUROTRA-D, 
which reeeive~ gnmts by the Federal Minister for Research and Technology 
under eontra~t 1013211. 
738 
schild/Busemann88\], \[Keller87\], \[Busemann87\] and \[Weis- 
weber87\]). The reader's familarity with the fundamental knowledge 
of GPSG as presented in \[GKPS85\] will be assumed. 
1.1 The Grammar Format 
The ID/LP format of the grammar allows the explicit formulation of 
generalizations about the partial order of the daughters of the ID 
rules via LP statements. ID rules are tuples of the form ((mother) ---) 
(daughters)), for example (S ~ {NP, VP}), where (daughters) is a 
multi-set of categories which can be dominated by the category 
(mother). Lexical rules are of the form ((mother) ---? (wordform)). 
LP statements are of the form '(categoryt) < (categorY2)', for 
example the LP statement NP < VP requires that the category NP 
must precede the category VP in a sequence of daughters of any 
local tree licensed by an ID rule of the grammar. 
For every grammar a set F = {f~, f2 ..... fn} of syntactic features 
exists with I FI = n. The number 'n' of features can vary from 
grammar to grammar, but for a particular grammar it is constant. 
Each feature fi has its domain D(fi). A complex category C is an n- 
tuple with C ~ D(f 1) x D(f2) x ... x D(fn) and the position T of the 
tuple represents he value of the feature fi. 
Example : F = {N, Vr BAR, PER, PLU, GEN} 
position i feature fi domain D(f l) 
1 N {+,-} 
2 v {+,-} 
3 BAR 10,1,2} 
4 PER { 1,2,3 } 
5 PLU {+,-} 
6 CAS { nom,gen,dat, ec } 
The category C = \[+N,-V,BAR 2,nom\] will be represented as 
(+,-,2,X,_,nom). C is the category traditionally called a nominative 
NP. If a feature Value of,a ea/tegory is not specified, like PER a~d 
/ /11 ? / PLU in C, it will be noted as ~ variable 3. ~e  value of ~ feature fl of 
3 A variable f ature value will be noted as a capital letter (e.g. X, Y, Z) when the 
same variable value is needed atanother place, otherwise it will be noted as '.. 
the category C can be expressed with C(fl), e.g. C(CAS) =nom or 
C(PER) = X. It is possible that a feature can have a category as its 
value, e.g. SLASH. 
In the following some predicates on feature values are used. They 
are 'spec', 'atom' and 'cat'. The semantics of them is as follows: 
spec(C(f)) ?~ C(f) is specified either with an atom or a category 
atom(C(t)) ?~ C(f) is specified with an atom 
cat(C(f)) ?:~ C(f) is specified with a category 
1.2 Feature lnstant iat ion 
The Feature Instantiation Principles 4 are not the subject of this 
paper. Only one thing needs to be said at this point, that is that the 
FIPs are not only regarded as filters for local trees as in \[GKPS85\], 
but in the constructive version of GPSG they propagate values of 
features within a local tree from the mother to the daughters and 
vice versa, or from one daughter to another if this feature value is 
affected by one of the FIPs (i.e. it is a HEAD, FOOT or agreement 
feature; a brief outline of the work which is done by the AP is given 
in section 2.1). In this case the FIPs are construction principles 
which propagate information from one point of a local tree to 
possibly many other points which require this information. In cases 
where a value is not specified (i.e. it is a variable), the variable is 
propagated. The FIPs are also filters for local trees and will reject 
local trees which have categories where the values of one of the 
features are not consistent. 
Before discussing the Feature Co-occurrence Restrictions (FCRs) 
two definitions are necessary to be able to define legal categories. 
Definition: extension 
A category E is the extension of a category C (C ~ E) iff 
(i) V f e F: atom(C(f)) ~ atom(E(f)) A C(f) = E(f) 5 and 
(ii) V f e F: cat(C(f)) ::?. cat(E(f)) ^  C(f) ~_ E(f) 
Definition: unifiable 
Two categories A and B are unifiable (A II B) ?:~ 
V f ~ F: ~spec(A(f)) v ~spec(B(f)) v
((atom(A(f)) A atom(B(t))) ~ (Aft) = B(f))) v 
((cat(A(f)) A cat(B(f))) ~ (Aft) ld B(f))) 
The FCRs in the constructive version of GPSG are not only 
predicates on categories, they are also modified to become more 
functional by instantiating variable feature values if necessary. FCRs 
are implications of the form (n, A D B). 'n' is the number of this 
FCR, 'A' is the condition category for the application of this FCR 
4 Ia the following they.are called FIPs. 1"he FIPs are the Foot Feature Principle 
(FFP), the Agreement,Principle (AP) and the Head Feature Convention (I-IFC). 
For detailed discussion of the FIPs see \[Busemanng7\], \[Hauenschild/ 
Busemann881 and \[Weisweber87\]. 
5 ',,', 'v'. '-4, '~' and '~' are the logical operators 'and', 'or', 'not', 'equivalence' 
and 'implicatioff, respectively, 
and 'B' is the consequence category. This FCR is applicable to a 
category C if C is an extension of A and, if so, C has to be unifiable 
with B. If C and B are not unifiable the category C is not legal. 
Definition: legal 
A category C is legal ?:~ 
V (n,A ~ B) E FCR: (A ~ C) v (A _E C A B 13 C) 
If the FCRs are applied to the category C and an FCR (n, A D B) is 
applicable to C and the consequence category B is unifiable with C 
and at least one feature f exists where ~spec(C(f)) and spec(B(f)) 
(B ~ C), then all those values C(f) are instantiated with B(f) 
(C(f) := B(f)). The FCRs have to be applied to a category C until no 
feature values of C are instantiated by them any longer, because the 
instantiation may cause other FCRs to be applicable. 
1.3 The Admissibility of Trees 
To generate syntactic structures (trees) during analysis or synthesis, 
ID rules are mapped into local trees in which all categories are legal. 
This mapping is called a projection. 
Definition: projection 
The projection ? ~ ID ? LT is a relation from the set ID of ID rules 
to the set LT of local trees. A tuple (r,t) is an element of ? ((r,t) e 
~)  where r = (r', C0 --> {Cl ..... Cn}) and 
_/?\ 
iff it meets the condition ~(C i) = ~ with 0 _< i,j ~ n where the total 
one-to-one, onto function ~ maps the set {C o ..... C,~} of categories 
of the ID rule r' into the set {C~ ..... C, t} of categories of the local 
tree t: 
0: {Co ..... c .} -~{C6 ..... c~} 
The function ?p meets the following conditions: 
?(C0) = C~ A ?p(Ct) = q A 1 < i,j < n A 
V ~(Ck): 0 < k < n A ?~(C k) is legal a (C k E_ O(Ck) ) 
When a local tree has been proved to be a projection of an ID rule, 
the FIPs are applied to it. Despite the fact that the projection already 
includes the application of the FCRs to the categories of a local tree, 
they still have to be applied everytime one of the FIPs (FFP, AP, 
HFC) has been applied to the local tree, because ach of them may 
instantiate a feature value of a category of the local tree and 
therefore another FCR may be applicable to that category. The las t  
check for admissibility is the application of the LP statements. The 
sequence of the daughters of the local tree must not conflict with 
any LP statement of the grammar (it has to be LP-consistent). 
Before 'LP-consistency' can be defined, the transitive LP-relation 
(LP +) has to be defined. 
Definition: transitive LP.relation 
1) (Ci < Ca) ? LP =~ (121 ~ C2) E LP + 
2) (C 1 ~ C2) ? LP + A (C~ ~ C~) E LP ? A C~ ~_ C2 =* 
(C1 t C3) ? LP + 
739 
With the help of this definition we are able to define LP- 
consistenc~'. 
Deflnitloni LP.consistency 
A local tree t is LP-consistent with respect o a grammar with the 
transitive LP-relation ~ iff 
V CI,C\]: 1 < ij < n ^ ~ precedes ~ 
-~3 C\[,Cj: C i ~ C\[ A Cj ~_ q A (Cj ~: C I) e LP + 
In other words, when a category C\[ precedes a category Oj in a local 
tree t, they must not conflict with the transitive LP-relation (C\], and 
must not be extensions of two categories C I and Cj, respectively, 
where Cj must precede CI). 
Now the definition of the admissibility of trees can be given. 
Definition: admissibility oftrees 
A tree is admissible iff all of its local trees are admissible. A local 
tree is admissible iff it is a projection of a lexical rule or iff it 
- is the projection of an ID rule and 
- satisfies all of the FIPs and 
- is LP-consistent. 
2 LP-Consistency and Legality 
The first chapter of this paper illustrates how to build up the 
syntactic structure (a tree) in the constructive version of GPSG, but 
it also sketches roughly the way this can generally be done in 
, unification grammars. First of all complex categories are assembled 
to form a local tree and subsequently the feature values of the 
categories are instantiated by different procedures (for example in 
GPSG by the FIPs and in the Lexical Functional Grammar (LFG) 
described in \[Bresnan/Kaplan82\] by the evaluation of the f- 
descriptions). The admissibility of those local trees is determined by 
some predicates (in GPSG by the LP statements and the FCRs and 
in LFG by existential constraints with the operator '=c' and the 
negative xistential constraints with the special value 'none'). These 
predicates can only be applied when particular feature values are 
specified. But when the admissibility of a local tree is to be proved, 
it cannot be guaranteed that all feature values have been locally 
instantiated. In some cases it is possible that. a feature value is not 
locally instantiated rather that it is instantiated somewhere lse in 
another local tree belonging to the complete tree and therefore the 
admissibility of a local tree is not a local matter anymore. 
In this chapter the problems which arise from checking the LP- 
consistency and the legality in the constructive version of GPSG are 
described in the sections 2.2 and 2.3 respectively. Section 2.4 briefly 
outlines the two possible solutions proposed by \[Keller87\]. But first 
of all a sample grammar is given to be used for examples. 
2.1 A Sample Grammar 
To illustrate the problems arising from checking the LP-consistency 
of a sequence of complex daughter categories and from ehecldng the 
legality of complex categories of a local tree, a sample grammar is 
given here. 
740 
The set of syntactic features is F = {fl, f2, f3}. A category is a triple 
C e D(f I) x D(f2) x D(f3). 
Features: f, D(f,) = {a,b,c,d,e} 
f2 D(f2) = {+'"* } 
f3 D(f3) = { 1,2,3} 
ID = { ((a,X,l) --~ {Co,Y,1), (c,Z,2)}), (I) 
((b,X,_) ~ {(d,Y,3), (e,*,1)}) } (2) 
Lexical rules: { ((e,_,_) --~ e), ((d~_,_) --~ d), 
((c,-,_) --~ cm), ((e,+J --~ cp) } 
LP = { (_,*,_) < (_,+,_), LP + = { (--,*,-) ~ (-,+~),. (1) 
(_,-,_3 < (_:,_) } (_,-,_) ~ C,*,-3, (2) 
C,-,_) ~ C,+,_) } (3) 
FCR = { (1, Co,-,_.) D (_,_,l)), (2, (d,+,_) D (_,_,2)) } 
Suppose that the feature f2 is an agreement feature and that a local 
tree t which is a projection of this ID rule has been constructed, then 
the Agreement Principle (AP) forces X = Y = Z and therefore the 
AP has to consider three cases 6: 
1) If at least two values are instantiated with different values then 
the AP has to reject (thepredicative iew of the F1Ps which is 
still preserved in the constructive rsion of GPSG). 
2) If at least one value is instantiated then the other variable values 
are instantiated with that value by the AP (propagation of 
instantiated feature values). 
3) If all values are not specified, i.e. they are variables, then the AP 
will identify all values with one variable (propagation of variable 
feature values). 
Whenever an admissible local tree t is a projection of ID rule (1), the 
values of the feature f2 (X, Y, Z) have to be identical and we can 
apply case (3) to the local tree t. 
2.2 ID/LP Specific Problems 
In this section only LP-consistency is considered and the legality of 
categories i  ignored. In some cases there are categories of local 
trees which have feature values not yet specified when the LP- 
consistency has to be checked, and this possibly means that one or 
more (transitive) LP statements cannot be applied to the given 
sequence of daughters. 
There axe two strategies for processing natural language with ID/LP 
grammars ODLPG): 
1) The indirect method, where an IDLPG is translated into an equiv- 
alent context-free grammar (CFG) (see \[Kilbury84\]). 
2) The direct method, where the ID rules and LP statements are used 
directly during processing (see \[Shieber84\], \[Kilbury84\], [Dtrre/ 
Momma85\], \[Busemann87\] and \[Weisweber87\]). 
No matter which method is used some problems arise. Firstly the 
6 For the sake of simplicity the AP of the constructive version of GPSG is not 
described in detail here (see footnote 4), 
problems in using the indirect method are described. Suppose ID 
rule (2) is to be translated into equivalent context-free rules. In order 
to do that, all permutations of the daughters have to be computed 
and the LP-consisteney of the resulting sequences has to be proved. 
Tiros the possible candidates for context-free rules are the following: 
(2a) ((b,X,_) ---> (e,*,l)(d,X,3)) and (2b) ((b,X,_) ---) (d,X,3)(e,*,l)) 
To prove the LP-consisteucy of (2a), (C 1 ~ Ca) must not be an 
element of LP +, where C1 ~ (d,X,3) and C a E (e,*,l). If such an 
element exists, the sequence of daughters in (2a) is not LP- 
consistent and has to be rejected. The only candidate from LP + is 
(2), but it cannot be applied because (_,~,_) ~ (d,X,3), and so (2a) is 
a valid context-free rule. But when X is instantiated with '-' later on 
during processing, the local tree tl which is licensed by (2a) has to 
be rejected because itviolates the transitive LP statement (2). 
tl: /(b,-,_)....>.. 
(e,\]el) (d=3) 
The same problem arises when the direct method is used. Suppose 
the string 'e d cm' is to be analysed, After the terminal symbol 'e' has 
been read, it .is reduced to (e,~,_). This category can be dominated in 
ID rule (2) b~canse (e,_,_) and (e,*,l) are unifiable. Then 'd' is read 
and reduced to (d,_,_) which can also be dominated in ID role (2) 
and it is unifiable with (d,X,3). Now tile daughters of ID rule (2) are 
complete and before they can be reduced to the mother category 
(b,X,1), the l,P-consistency of the sequence '(e,*,l)(d,X~) ' as above 
has to be proved. For the above mentioned reason ",his sequence is
LP-consistent and is reduced to (b,X,1). This category can be 
dominated in ID rule (1) and up to this point the following partial 
tree t2 can be constructed. 
t'2: / (b ,X ,~(  a'X' 1) (c--~c,X,2) (d ,ld,3) 
Every local tree in the partial tree t 2 is LP-consistent. Now the 
telxninal symbol 'era' is read and reduced to (c,-,_). This category is 
unifiable with (c,X,2) in t 2 and the local tree licensed by a lexical 
rule can be added to t a. Wlmn the two categories are unified 7 the 
variable X is instantiated with '-' everywhere in t 2. The result is that 
the sequence of daughters '(e,*,l)(d,-,3)' is not LP-eonsistent 
anymore, beeanse now it violates the transitive LP statement (2). If 
instead the next input symbol after the string 'e d' is 'cp', no 
problems with the LP-consistency arise. 
2?3 FCR Specific Problems 
Similar problems like those with the LP..consistency appear when 
the FCRs are applied to the categories of a local tree. Suppose that 
In the constructive rsion of GPSG, unification is used for tree formation. In
the version of \[GKPS85\] the root category R of a subtree has to be identical 
with a &mghter category C of a local tree (i.e. R __. C and C ~ R). 
the partial tree t 2 has already teen constructed. All of its categories 
are legal. 
Suppose that the next input symbol after the string 'e d' is 'cp'. This 
terminal symbol is reduced to (c,+,_) which can be unified with 
(c,X,2) in t. 2 and the variable X is instantiated with '+'. Thus all 
variables X in t~ have to be replaced by '+' and the category (d,X,3) 
becomes (d,+,3). Now FCR 2 is applicable because (d,+,3) is an 
extension of the condition category (d,+,_) ((d,+,_) c (d,+,3)), but it 
is not unifiable with the consequence ategory (_,_,2) (-~((d,+,3) \[J
( . . . .  2))) and thus it is not legal and has to be rejected. 
2.4 Two Possible Solutions 
According to \[Keller87\], the problems described in the sections 2.2 
and 2.3 can be solved in two ways. One way would be to check the 
LP-consistency of all local trees and the legality of all categories 
after the entire tree for the input string has been constructed. The 
other way would be to restrict he grammar format and/or the FIPs. 
The disadvantage of the former solution is its inefficency. The 
checks have to be done in addition after the processing of the input 
string is terminated because some trees have not already been 
rejected, although it would have been possible to do so. 
The disadvantage of the latter solution is made obvious by two 
examples. The format of the categories, for example, can be 
restricted by assuring that the mother category in a local tree is fully 
specified, i.e. a feature must not have a variable as its value. This 
would involve a loss of the grammar's descriptive power. Another 
way would be to restrict the FIPs by assuring that they don't 
propagate variable feature values, which would involve GPSG 
losing some of its generality. 
3 Constraints 
In both cases (LP-consistency and legality) the problems are caused 
by categories of local trees which are not extensions of tile 
categories in the LP statements o1" of the condition categories in the 
FCRs, but which have been unifiable with them. This is the case 
when a feature of a category of the local tree has a variable as its 
value and the same feature value is specified in the corresponding 
category of the LP statements or the FCRs. 
This fact means that the LP statements or the FCRs are not locally 
applicable in some cases, and so the admissibility of the local trees 
can only be assured with certain constraints which can be fulfilled 
later on, when the variable is instantiated during processing. 
3.1 Computing Constraints from LP 
To compute the constraints resulting from the LP statements, the 
above mentioned cases have to be first identified. Suppose that the 
sequence 'A B' of categories i to be checked for LP-consisteney and 
an LP statement B":< A' exists where B \[J B' and B' \[~ B and A' ~_ A. 
This LP statement is not applicable to 'A B' because B' ~ B, though 
B' H B. This means that at least one feature f exists, where 
spec(B'(f))and --,spec(B(f)). Thus the sequence 'A B' is LP- 
741 
consistent under the constraint that B( f i ) ,  B'(fi) for all features fi 
with the above mentioned condition, and since all values B(fl) for 
those features fl are variables (~spec(B(fi))) , they must not be 
instantiated with the values B'(fi) which are already specified. When 
the values B(fi) are instantiated by the FIPs or by the FCRs in the 
local tree, there is no problem in determining the admissibility. But 
when the variable feature values B(fi) are propagated to the mother 
by the FIPs, they can possibly be instantiated in another local tree 
and those variable values B(fi) have to be constrained. 
Computing the set of constrqints LP c 
When the LP-consistency of a sequence of daughters in a local tree t 
is checked for every pair of daughters Q, q ,  where 1 < i < j < n, the 
set LPc(i, j) of LP constraints i computed as follows: 
1) ~ (Cj ~ Ci) E LP+: Cj ~ ~jj A C i ~ C\[ ~ t is not LP-consistent 
2) V (Cj ~: C i) ~ LP+: (CjLJ q A Cj ~ q) v (C~L\] o, ^ c~ ~ Cl) 
t is LP-consistent with the LP constraints: 
LPc(i,j) = { (Oj(f),Cj(f))l spec(Cj(f)) and ~spec(Oj(f)) } u 
{(Q(0,Ci(f))l spec(Ci(f)) and ~spec(~(f))} 
3) --~=I (Cj ~: C) ELF+: (Cj L\] C} ^  C~ IJ q) 
t is LP-consistent with LPc(i,j) = { } 
LPc(i,j) is a set of tuples (Vt,Vp) of feature values. V t is the variable 
feature ~,alue of a category of  a local tree. Vp is the specified feature 
value of the LP statement which will become applicable to the 
corresponding daughters of the subtree if the values V t of all tuples 
in LPc(id) are specified and equal to their corresponding values Vp. 
In this case the subtree has to be rejected. 
The set of all LP constraints LPc(0) for the'local tree in which C~ is 
the mother category is ?1 
LPc(0) = {LPc(i,j)\[ 1 < i < j < n} u ;L.) 4eval_lp(LPc(i)) 
where eval_lp(LPc(i)) is the evaluation of the LP constraints of the 
subtree in which the daughter ~ is the root category. The set of LP 
constraints o f  a projection of a lexical rule is LPc(0) = {}, since 
lexical rules have only one daughter (a wordform). 
The evaluation 'eval_lp' 
The evaluation 'eval lp' is either defined or undefined (.1.). If it is 
undefined, the corresponding local tree is rejected, because one of 
the subtrees of the daughters of that local tree is not LP-consistent. 
1) eval_lp(LPc(i)) = .L ?:~ 
3 C ? LPc(i): (V (Vt,V2) E C: spec(V 1) A spec(V 2) ^  V 1 = V2) 
2) eval_lp(LPc(i)) = LPc(i) - 
{C ~ LPc(i)l 3(V1,V 2) ~ C: spec(V 0 A spec(V2) A V 1 ~ V2} 
3) eval lp(LPc(i)) = {CI (C = C' - M) ^ C" ~ LPc(i) ^  C ? { } } 
where M = {(Vl,V2) \[ spec(V 1) ^  spec(V 2) A V 1 = V2} 
The first case (1) means that if one set C of tuples exists in the set 
LPc(i) of one daughter of the local tree, where all values of all tuples 
are specified and equal, then an LP statement will be applicable 
somewhere in the subtree of this daughter, and it will reject the 
subtree because some sister categories in the subtree are not LP- 
consistent anymore. 
742 
The second case (2) removes all sets S of tuples from LPc(i ) of one 
daughter which include one tuple with two different specified 
values. This means that the LP statement which has caused the 
computation of S will not be applicable anymore. 
The third case (3) removes all tuples with two equally specified 
values from all sets of tuples in LPc(i) of one daughter, because they 
need not be evaluated for a second time. 
3.2 Computing Constraints from FCRs 
To compute constraints resulting from FCRs, the categories have to 
be identified which are not an extension of a condition category of 
an FCR, but unifiable with it. Suppose that the FCRs are to be 
applied to the category C, and that an FCR (n, A ~ B) exists 
where A \[3 C and A ~ C. The FCR 'n' is not applicable to C. This 
may change if a feature value is instantiated. It is the same situation 
as in section 3.1, but here the computing of constraints i somewhat 
different, because the application of an FCR to a category may cause 
that another FCR will become applicable to that category. FCR 
constaaints only have to be computed when ~(B L\] C), or B l_J C and 
B ~ C (the case ~(B H C) means that if the FCR will be applicable 
to C, it will reject C, and the second case means that if the FCR will 
become applicable to C, it will instantiate one or more features in C, 
but the category always remains legal with respect to this FCR). The 
case ~(B II C) is the crucial one, because the legality of the category 
C can only be assured with the constraint that the set of possibly 
applicable FCRs, with the above mentioned conditions on the 
consequence ategory, still have to be checked for applicability. 
Computing the set of constraints FCR c 
For all categories C\[ where 0 < i < n in a local tree t the set APP(i) of 
all numbers of FCRs which may still be applicable to Q is computed 
as follows: 
1) 3 (k,A D B) ~ FCR: A E Q A -~(B \[3 C D =~ C I not legal 
2~V (k)A ~ B) ~ FCR: AL Jq  ^ A~ qA 
(-~(B L\] q )  v ((B LJ CD ^  (B ~ q))) ~ q legal and k ~ AFP(i) 
3) V (k,A ~ B) ~ FCR: ~(A LJ q )  v (A _E C) ^  B II q )  
q is legal and APP(i) = { } 
The set of all FCR constraints FCRc(0) for the local tree in which C8 
is the mother category is 
11 
FCRc(0) = { (C8) APP(0)) } u .L) eval fcr(FCRc(i)) 
where eval fcr(FCRc(1)) is the evaluation of the FCR constraints 
from the subtree in which the daughter q is the root category. 
FCRc(0) is a set of tuples (Ci, APP(i)). Ci is a copy of a category of 
the subtree in which C 8 is the root category and APP(i) includes the 
numbers of all FCRs which may still be applied to C i if particular 
feature values of this category are going to be instantiated. The only 
new set APP in a local tree is computed from the mother) because 
the evaluation of the FCR constraints on the subtre~s of the 
daughters includes the application of the applicable FCRs to the 
daughter categories (because they are the root categories of the 
subtrees). Thus the remaining tuples of the daughters and their 
subtrees will be computed by the evaluation. The set of FCR 
constraints on a projection of a lexical rule is FCRc(0 ) = {(C~, 
APP(O))}. 
The evaluatim~ 'evaljcr' 
The evaluation 'eval for' is either defined or undefined (.L). If it is 
undefined, the con'esponding local tree is rejected, because one or 
more categories of the subtrees of the daughters of that local tree are 
not legal. 
1) eval fcr(FCRc(i)) = .L ?=:, 3 (C,APP) ~ FCRc(i): k e APP ^ 
(k,A ~ B) e FCR ^ A c C ^ -,(B \[J C) 
2) eval fcr(FCRc(i)) = {(C,M) I (M = APP - S) ^  
(C,APP) e FCRc(i ) ^ M e { } } where 
S = {k\[ (k,A ~ B) e FCR ^ (-~(AH C) v (A  c_ C ^ B \[J C))} 
The first case (1) means that if the set FCRc(i) of a subtree of one 
daughter C\[ includes one tuple (C,APP) in which the category C is 
not legal with respect o the FCR (k,A ~ B) where 'k' is in the set 
APP of numbers of FCRs, then the subtree has to be rejected, 
because the category C in this subtree is no longer legal. 
The second case (2) removes all the numbers 'k' of  FCRs from the 
set APP of all tuples in FCRc(i), where the FCR (k,A D B) is no 
longer applicable to the category C or where it has been successfully 
applied to the corresponding category. 
3.3 Evaluation and Propagation 
After a local nee t has been proved to be a projection of an ID rule, 
all F1Ps are applied to t, the FCRs to its mother, and the set APP(0) 
of the numbers of all FCRs which possibly will be applicable to the 
mother, is computed. After that the FCR constraints on the subtrees 
of the daughters are evaluated, which means that all applicable 
FCRs are applied to the daughters and to all other categories of their 
stthtrecs. The remaining FCR constraints from the evaluation, and 
the FCR con:;traint (C~, APP(0)) on the mother, will then be 
combined to form the new FCR constraint set FCRc(0) on the 
gubtree in which C~ is the root category. The new FCR constraint set 
is propagated tothe mother. 
Next the LP-.consistency of the daughters has to be checked, and 
during this check the new LP constraints on the daughters are 
computed. These constraints are combined with the LP constraints 
resulting fl'om the evaluation of the LP constraints on the subtrees of 
the daughters, to form the entire set of LP constraints LPc(0) on the 
subtree in which C/~ is the root category which is then also 
propagated tothe mother. 
4 Conclusion 
With this method of constraint computation, evaluation and 
propagation," a new definition of the admissibility of trees is 
necessary. 
Definition: admissibility of trees 
A tree is adndssible iff all of its local trees are admissible and the 
evaluations 'eval fcr' and 'eval lp' of constraints of theroot category 
are defined and both are the empty set {}. A local tree t is 
admissible iff it is a projection of a lexical rule or iff it 
- is a projection of an ID rule with the FCR constraint (C~, APP(0)) 
on the mother C/~ and 
- satisfies all of the FlPs and 
- is LP-consistent with the LP constraints LPc(i,j) on all daughters C\[ 
and ~ which ,are propagated tothe mother where 1 _< i < j < n and 
- the evaluation 'eval_fcr(FCRc(i))' of every daughter C\[ isdef ined 
where 1 ~ i < n and their results are propagated tothe mother and 
- the evaluation 'eval_lp(LPc(i))' of every daughter C i is defined 
where 1 ~ i ~ n and their results are propagated tothe mother. 
The consequence for the root category R of an entire tree of one 
input string of a natural anguage will be the fact that all features fi
of R, where ~spec(R(fi)), and where fl is needed for the evaluation 
of the constraints of the tree, have to be instantiated according to 
their domain D(fi) because such a tree represents a class of 
ambiguous olutions. After that the constraints on every tree of this 
class are evaluated and only the trees where FCRc(0 ) and LPc(0 ) are 
defined and their evaluation is { } are admissible. 
References 
\[Barton85\] : G.E. Barton Jr.; "The Computational Difficulty of ID/LP Parsing"; 
23rd Ann. Meet. of the ACL at University of Chicago; Chicago 1985 
\[Bresnau/Kaplan82\] : J. Bresnun, R.M. Kaplan; "Lexical Functional Grmnmar: A 
Formal System of Grammatical Representation"; i : MIT Press Series on 
Cognitive Theory and Mental Repr. pp.173-28 I; Cambridge 1982 
\[Busemann87\] : S. Busemann; "Generierung mit GPSG"; in: K. Morik(ed.) 
Proceedings of the llth German Workshop on Artifical Intelligence 
pp.355-364; Springer-Verlag; Geseke 1987 
\[Busemann/Hauensehild88\] : S. Busemann, C. Hauenschild; "A Constructive 
View of GPSG or How To Make It Work"; 12th International 
Conference on Computational Linguistics, Budapest 1988 
\[DSrre/Momma851 : J. D~rre, S. Momma; "Modifikationen des Earley- 
Algorithmus und ihre Verwendung flit ID/LP-Grammatiken"; Manuscript 
of the Department for Linguistics/ Romanistics at the University of 
Stuttgart 1985 
\[GKPS85\] : G. Gazdar, E. Klein, G. Pullum, I. Sag; "Generalized Phrase Structure 
Grammar"; Oxford; Blackwell 1985 
\[Hanenschild/Buse,nann88\] : C. Hanenschild, S. Busemann; "A Constructive 
Version of GPSG for Maschine Translation" in Steiner, Schmidt, 
Zelinsky-Wibbelt (eds.) "From Syntax to Semantics-Insights from 
Maschina Translation", Frances Pinter 
\[Karttunen84\] : L. Karttunen; "D-PATR: A Development Environment for 
Unification-Based Grammars"; llth International Conference on 
Computational Linguistics, Bonn 1986 
\[Keller87\] : W. Keller; "An Overview of the Project NASEV Parser"; Manuscript, 
University of Sussex 1987 
\[Kilbury84\] : J. Kilbury; "Earley-basierte Algorithmen filr direktes Parsen mit 
ID/LP-Grammatiken"; KIT-Report 16; T(.I Berlin 1984 
\[Ristad86\] : E.S. Ristad; "Computational Complexity of Current GPSG Theory"; 
24th Ann. Meet. of the ACL at Columbia University; New York 1986 
\[Shieber84\] : S.M. Shieber; "Direct Parsing of ID/LP Grammars"; Linguistics and 
Philosophy 7 1984 pp.135-154 
\[Shieber86al : S.M. Shieber; "An Introduction toUnification-based Approaches to
Grammar"; CSLI Lecture Notes Number 4, Ventura Hall, Stanford 
University, Stanford 1986 
lShieber86b\] : S.M. Shieber; "A Simple Reconstruction f GPSG"; Proceedings of
the llth International Conference on Computational Linguistics; Bonn 
1986 pp.211-215 
? \[Weisweber87\] : W. Weisweber; "Ein Dominanz-Chart-Parser fiir genemlisierte 
Phrasenstrukturgrammatiken"; KiT-Report 45, TU Berlin 
743 
