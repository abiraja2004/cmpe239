A Semant ic -Head-Dr iven  Generat ion A lgor i thm 
for Un i f icat ion-Based Formal isms 
Stuart  M. Shieber," Ger t jan  van Noord, t Robert  C. Moore," 
and Fernando C. N. Pereira.* 
"Artif icial  Intel l igence Center  
SRI  In ternat iona l  
Menlo Park,  CA 94025, USA 
tDepar tment  of Linguistics 
Ri jksunivers i te i t  Utrecht  
Utrecht,  Nether lands 
Abstract 
We present an algorithm for generating strings 
from logical form encodings that improves upon 
previous algorithms in that it places fewer restric- 
tions on the class of grammars to which it is ap- 
plicable. In particular, unlike an Earley deduction 
generator (Shieber, 1988), it allows use of seman- 
tically nonmonotonic grammars, yet unlike top- 
down methods, it also permits left-recursion. The 
enabling design feature of the algorithm is its im- 
plicit traversal of the analysis tree for the string 
being generated in a semantic-head-driven fashion. 
1 Introduction 
The problem of generating a well-formed natural- 
language xpression from an encoding of its mean- 
ing possesses certain properties which distinguish 
it from the converse problem of recovering a mean- 
ing encoding from a given natural-language ex- 
pression. In previous work (Shieber, 1988), how- 
ever, one of us attempted to characterize these 
differing properties in such a way that a sin- 
gle uniform architecture, appropriately parame- 
terized, might be used for both natural-language 
processes. In particular, we developed an archi- 
tecture inspired by the Earley deduction work of 
Pereira and Warren (1983) but which generalized 
that work allowing for its use in both a parsing 
and generation mode merely by setting the values 
of a small number of parameters. 
As a method for generating natural-language 
expressions, the Earley deduction method is rea- 
sonably successful along certain dimensions. It 
is quite simple, general in its applicability to a 
range of unification-based and logic grammar for- 
malisms, and uniform, in that it places only one 
restriction (discussed below) on the form of the lin- 
guistic analyses allowed by the grammars used in 
generation. In particular, generation from gram- 
mars with recursions whose welbfoundedness relies 
on lexical information will terminate; top-down 
generation regimes such as those of Wedekind 
(1988) or Dymetman and Isabelle (1988) lack this 
property, discussed further in Section 3.1. 
Unfortunately, the bottom-up, left-to-right pro- 
cessing regime of Earley generation--as it might 
be called--has its own inherent frailties. Efficiency 
considerations require that only grammars pos- 
sessing a property of semantic monotonicity can 
be effectively used, and even for those grammars, 
processing can become overly nondeterministic. 
The algorithm described in this paper is an at- 
tempt to resolve these problems in a satisfactory 
manner. Although we believe that this algorithm 
could be seen as an instance of a uniform archi- 
tecture for parsing and generation--just as the 
extended Earley parser (Shieber, 1985b) and the 
bottom-up generator were instances of the general- 
ized Earley deduction architecture= our efforts to 
date have been aimed foremost oward the devel- 
opment of the algorithm for generation alone. We 
will have little to say about its relation to parsing, 
leaving such questions for later research.1 
2 Applicability of the Algo- 
rithm 
As does the Earley-based generator, the new algo- 
rithm assumes that the grammar is a unification- 
based or logic grammar with a phrase-structure 
backbone and complex nonterminMs. Further- 
more, and again consistent with previous work, 
we assume that the nonterminals associate to the 
phrases they describe logical expressions encoding 
their possible meanings. We will describe the al- 
gorithm in terms of an implementation f it for 
definite-clause grammars (DCG), although we be- 
I Martin Kay (personal communication) has developed 
a parsing algorithm that seems to be the parsing correlate 
to the generation algorithm presented here. Its existence 
might point the way towards a uniform architecture. 
lieve the underlying method to be more broadly 
applicable. 
A variant of our method is used in Van No- 
ord's BUG (Bottom-Up Generator) system, part 
of MiMo2, an experimental machine translation 
system for translating international news items of 
Teletext, which uses a Prolog version of PATI~-II 
similar to that of Hirsh (1987). According to Mar- 
tin Kay (personal communication), the STREP 
machine translation project at the Center for the 
Study of Language and Information uses a ver- 
sion of our algorithm to generate with respect o 
grammars based on head-driven phrase-structure 
grammar (HPSG). Finally, Calder et al (1989) 
report on a generation algorithm for unification 
categorial grammar that appears to be a special 
case of ours. 
3 Problems with Existing 
Generators 
Existing generation algorithms have efficiency or 
termination problems with respect to certain 
classes of grammars. We review the problems of 
both top-down and bottom-up regimes in this sec- 
tion. 
3.1 P rob lems w i th  Top-Down Gen-  
e ra tors  
Consider a naive top-down generation mechanism 
that takes as input the semantics to generate from 
and a corresponding syntactic ategory and builds 
a complete tree, top-down, left-to-right by apply- 
ing rules of the grammar nondeterministically to 
the fringe of the expanding tree. This control 
regime is realized, for instance, when running a 
DCG "backwards" as a generator. 
Clearly, such a generator may not terminate. 
For example, consider a grammar that includes 
the rule 
siS --> np/NP, vp(gP)/S. 
(The intention is that verb phrases like, say, 
"loves Mary" be associated with a nonterminal 
vp(X)/love(X, mary).) Once this rule is ap- 
plied to the goal s / love( john ,  mary), the sub- 
goal np/NP will be considered. But the generation 
search space for that goal is infinite and so has 
infinite branches, because all noun phrases, and 
thus arbitrarily large ones, match the goal. This 
is an instance of the general problem known from 
logic programming that a logic program may not 
terminate when called with a goal less instanti- 
ated than what was intended by the program's 
designer. Dymetman and Isabelle (1988), not- 
ing this problem, propose allowing the grammar- 
writer to specify a separate goal ordering for pars- 
ing and for generation. For the case at hand, 
the solution is to generate the VP first--from the 
goal vp(NP)/loves(john, mary)--in the course 
of which the variable NP will become bound so 
that the generation from np/NP will terminate. 
Wedekind (1988) achieves this goal by expanding 
first nodes that are connected, that is, whose se- 
mantics is instantiated. Since the NP  is not con- 
nected in this sense, but the VP  is, the latter will 
be expanded first. In essence, the technique is a 
kind of goal freezing (Colmerauer, 1982) or im- 
plicit wail declaration (Naish, 1986). For cases in 
which the a priori ordering of goals is insufficient, 
Dymetman and Isabelle also introduce goal freez- 
ing to control expansion. 
Although vastly superior to the naive top-down 
algorithm, even this sort of amended top-down ap- 
proach to generation based on goal freezing under 
one guise or another fails to terminate with cer- 
tain linguistically plausible analyses. For example, 
the "complements" rule given by Shieber (1985a, 
pages 77-78) in the PATR-II formalism 
VP1 ~ VP2 X 
(VPI head) = (VP2 head) 
(VP2 syncat first) = (X) 
(VP2 syncat rest) - (VP1 syncat) 
can be encoded as the DCG-style rule: 
vp(Head, Synca~) --> 
vp(Head, \[CompllSyncat\]), Compl. 
Top-down generation using this rule will be forced 
to expand the lower VP before its complement, 
since Comp1 is uninstantiated initially. But appli- 
cation of the rule can recur indefinitely, leading to 
nontermination. 
The problem arises because there is no limit to 
the size of the subcategorization list. Although 
one might propose an ad hoc upper bound for lexi- 
ca/entries, even this expedient may be insufficient. 
In analyses of Dutch cross-serial verb construc- 
tions (Evers, 1975; Huybrechts, 1984), subcate- 
gorization lists such as these may be appended by 
syntactic rules (Moortgat, 1984; Steedman, 1985; 
Pollard, 1988), resulting in indefinitely long lists. 
Consider the Dutch sentence 
dat \[Jan \[Marie \[de oppasser \[de olifanten 
that John Mary the keeper the elephants 
\[zag helpen voeren\]\]\]\] 
saw help feed 
that John saw Mary help the keeper feed the 
elephants 
The string of verbs is analysed by appending their 
subcategorization lists as follows: 
V \[e,k,md\] 
v \[mj\] V \[e,k,m\] 
zag 
sato 
v \[k,m\] V \[e,k\] 
I I 
helpen voeren 
help feed 
Subcategorization lists under this analysis can 
have any length, and it is impossible to predict 
from a semantic structure the size of its corre- 
sponding subcategorization list mereiy by exam- 
ining the lexicon. 
In summary, top-down generation algorithms, 
even if controlled by the instantiation status of 
goals, can fail to terminate on certain grammars. 
In the case given above the well-foundedness of the 
generation process resides in lexical information 
unavailable to top-down regimes. 
3.2 Problems with Bottom-Up 
Generators 
The bottom-up Earley-deduction generator does 
not fall prey to these problems of nontermination 
in the face of recursion, because lexical informa- 
tion is available immediately. However, several im- 
portant frailties of the Earley generation method 
were noted, even in the earlier work. 
For efficiency, generation using this Earley de- 
duction method requires an incomplete search 
strategy, filtering the search space using seman- 
tic information. The semantic filter makes gen- 
eration from a logical form computationally feasi- 
ble, but preserves completeness of the generation 
process only in the case of semantically monotonic 
grammars - -  those grammars in which the seman- 
tic component of each right-hand-side nonterminal 
subsumes some portion of the semantic omponent 
of the left-hand-side. The semantic monotonicity 
constraint itself is quite restrictive. Although it is 
intuitively plausible that the semantic ontent of 
subconstituents ought to play a role in the seman- 
tics of their combination--this  just a kind of 
compositionality claim--there are certain cases in 
which reasonable linguistic analyses might violate 
this intuition. In general, these cases arise when a 
particular lexical item is stipulated to occur, the 
stipulation being either lexical (as in the case of 
particles or idioms) or grammatical (as in the case 
of expletive xpressions). 
Second, the left-to-right scheduling of Earley 
parsing, geared as it is toward the structure 
of the string rather than that of its meaning, 
is inherently more appropriate for parsing than 
generation. ~ This manifests itself in an overly high 
degree of nondeterminism in the generation pro- 
tess. For instance, various nondeterministic pos- 
sibilities for generating a noun phrase (using dif- 
ferent cases, say) might be entertained merely be- 
cause the NP occurs before the verb which would 
more fully specify, and therefore limit, the options. 
This nondeterminism has been observed in prac- 
tice. 
3.3 Source of the Problems 
We can think of a parsing or generation process 
as discovering an analysis tree, 3 one admitted by 
the grammar and satisfying certain syntactic or se- 
mantic conditions, by traversing a virtual tree and 
constructing the actual tree during the traversal. 
The conditions to be satisfied--possessing a iven 
yield in the parsing case, or having a root node la- 
beled with given semantic information in the case 
of generation--reflect the different premises of the 
two types of problem. 
From this point of view, a naive top-down parser 
or generator performs a depth-first, left-to-right 
traversal of the tree. Completion steps in Earley's 
algorithm, whether used for parsing or generation, 
correspond to a post-order traversal (with predic- 
tion acting as a pre-order filter). The left-to-right 
traversal order of both of these methods is geared 
towards the given information in a parsing prob- 
lem, the string, rather than that of a generation 
problem, the goal logical form. It is exactly this 
mismatch between structure of the traversal and 
2Pereira and Warren (1983) point out that  Earley de- 
duct ion  is not  restr icted to a left-to-right expansion of 
goals, but  this suggestion was not fol lowed up with a spe- 
cific a lgor i thm addressing the problems discussed here. 
3We use the term "analysis tree" rather than  the more 
familiar "parse tree" to make clear that  the source of the 
tree is not  necessarily a parsing process; rather  the tree 
serves on ly  to codify a part icular analysis of the structure 
of the str ing. 
9 
structure of the problem premise that accounts for 
the profligacy of these approaches when used for 
generation. 
Thus for generation, we want a traversal order 
geared to the premise of the generation problem, 
that is, to the semantic structure of the sentence. 
The new algorithm is designed to reflect such a 
traversal strategy respecting the semantic struc- 
ture of the string being generated, rather than the 
string itself. 
4 The New Algor i thm 
Given an analysis tree for a sentence, we define 
the pivot node as the lowest node in the tree such 
that it and all higher no.des up to the root have the 
same semantics. Intuitively speaking, the pivot 
serves as the semantic head of the root node. Our 
traversal will proceed both top-down and bottom- 
up from the pivot, a sort of semantic-head-driven 
traversal of the tree. The choice of this traversal 
allows a great reduction in the search for rules used 
to build the analysis tree. 
To be able to identify possible pivots, we dis- 
tinguish a subset of the rules of the grammar, 
the chain rules, in which the semantics of some 
right-hand-side element is identical to the seman- 
? tics of the left-hand side. The right-hand-side ele- 
ment will be called the rule's semantic head. 4 The 
traversal, then, will work top-down from the pivot 
using a nonchain rule, for if a chain rule were used, 
the pivot would not be the lowest node sharing 
semantics with the root. Instead, the pivot's se- 
mantic head would be. After the nonchain rule 
4 In case there axe two right-hand-side el ments hat are 
semantically identical  to the left -hand side, there is some 
freedom in choosing the semantic head, although the choice 
is not without ramifications. For instance, in some analyses 
of NP  structure, a rule such as 
np/NP--> det/NP, nbar/NP. 
is postulated. In general, a chain rule is used bottom-up 
from its semantic head and top-down on the non-semantic- 
head siblings. Thus, if a non-semantic-head subconstituent 
has the same semant ics  as the left-hand-side, a recursive 
top-down generation with the same semantics will be in- 
voked. In theory, this can lead to nonterrnination, unless 
syntactic factors eliminate the recursion, as they would in 
the rule above regardless of which element is chosen as se- 
mantic head. In a rule for relative clause introduction such 
as the following (in highly abbreviated form) 
nbarlg --> nbarlN, sbar/N. 
we can (and must) choose the nominal as semantic head 
to effect termination. However, there are other problem- 
atic cases, such as verb-movement analyses of verb-second 
languages, whose detailed discussion is beyond the scope of 
this paper. 
is chosen, each of its children must be generated 
recursively. 
The bottom-up steps to connect he pivot to the 
root of the analysis tree can be restricted to chain 
rules only, as the pivot (along with all interme- 
diate nodes) has the same semantics as the root 
and must therefore be the semantic head. Again, 
after a chain rule is chosen to move up one node 
in the tree being constructed, the remaining (non- 
semantic-head) children must be generated recur- 
sively. 
The top-down base case occurs when the non- 
chain rule has no nonterminal children, i.e., it 
introduces lexical material only. The bottom-up 
base case occurs when the pivot and root are triv- 
ially connected because they are one and the same 
node. 
4.1 A DCG Implementat ion  
To make the description more explicit, we will de- 
velop a Prolog implementation f the algorithm for 
DCGs, along the way introducing some niceties of 
the algorithm previously glossed over. 
In the implementation, a term of the form 
node(Cat, P0, P) represents a phrase with the 
syntactic and semantic information given by Cat 
starting at position P0 and ending at position P in 
the string being generated. As usual for DCGs,  a 
string position is represented by the list of string 
elements after the position. The  generation pro- 
cess starts with a goal category and attempts to 
generate an appropriate node, in the process in- 
stantiating the generated string. 
gen(Cat, String) :- 
generate (node (Cat, String, \[\] ) ). 
To  generate from a node, we nondeterministi- 
cally choose a nonchain rule whose left-hand side 
will serve as the pivot. For each right-hand-side el- 
ement, we recursively generate, and then connect 
the pivot to the root. 
generate(Root) :- 
choose nonchain rule 
appl icable_non_chain_rule (Root, 
Pivot, RHS), 
generate all subconstituents 
generate _rhs ( RHS ), 
generate material on path to root 
connect (Pivot, Root). 
The  processing within genera'ce_rhs is a simple 
iteration. 
generate_rhs(D). 
10  
generate_rhs(\[First \[ Rest\]) :- 
generate (First), 
generat e_rhs (Rest). 
The connection of a pivot to the root, as noted 
before, requires choice of a chain rule whose 
semantic head matches the pivot, and the re- 
cursive generation of the remaining right-hand- 
side. We assume a predicate app l i cab le_cha in_  
rule(Semrlead, LHS, Rool;, RHS) that holds if 
there is a chain rule admitting a node LHS as the 
left-hand-side, SeraHead as its semantic head, and 
RHS as the remaining right-hand-side nodes, such 
that the left-hand-side node and the root node 
Root can themselves be connected. 
cormect (Pivot, Root) : -  
choose chain rule 
applicable_chain_rule (Pivot, LHS, 
Root, RHS), 
generate remaining siblings 
generate_rhs (RHS), 
~$ connect the new parent to the root 
connect. (LItS, Root). 
The base case occurs when the root and the 
pivot are the same. Identity checks like this one 
must be implemented correctly in the generator 
by using a sound Unification algorithm with the 
occurs check. (The default unification in most 
Prolog systems is unsound in this respect.) For 
example, a grammar with a gap-threading treat- 
ment of wh-movement (Pereira, 1981; Pereira and 
Shieber, 1985) might include the rule 
np(Agr, \[np(Agr)/SemlX\]-X)/Sem---> \[\]. 
stating that an NP with agreement Agr and se- 
mantics Sera can be empty provided that the list of 
gaps in the NP can be represented as the difference 
list \[np(Agr)/SemlX\]-X, that is the list contain- 
ing an NP gap with the same agreement features 
Agr (Pereira and Shieber, 1985, p. 128). Because 
the above rule is a nonchain rule, it will be consid- 
ered when trying to generate any nongap NP, such 
as the proper noun np(3-s ing,G-G) / john.  The 
base case of connecl; will try to unify that term 
with the head of the rule above, leading to the at- 
tempted unification of X with l'np(Agr)/SemIX\], 
an occurs-check failure. The base case, incorpo- 
rating the explicit call to a sound unification algo- 
rithm is thus as follows: 
cozmect(Pivot, Root) : -  
% trivially connect pivot to root 
unify(Pivot, Root). 
11 
Now, we need only define the notion of an ap- 
plicable chain or nonchain rule. A nonchain rule 
is applicable if the semantics of the left-hand-side 
of the rule (which is to become the pivot) matches 
that of the root. Further, we require a top-down 
check that syntactically the pivot can serve as the 
semantic head of the root. For this purpose, we 
assume a predicate chained_nodes that codifies 
the transitive closure of the semantic head rela- 
tion over categories. This is the correlate of the 
link relation used in left-corner parsers with top- 
down filtering; we direct the reader to the discus- 
sion by Matsumoto et al (1983) or Pereira and 
Shieber (1985, p. 182) for further information. 
applicable_non_chain_rule (Root, Pivot, 
RHS) :- 
7o semantics of  root and pivot are same 
node_semantics (Root, Sem), 
node_semantics(Pivot, Sem), 
~o choose a nonchain rule 
non_ehain_rule(r.HS, RttS), 
~$ ...whose lhs matches the pivot 
unify(Pivot, LHS), 
make sure the categories can connect 
chained_nodes(Pivot, Root). 
A chain rule is applicable to connect a pivot to a 
root if the pivot can serve as the semantic head 
of the rule and the left-hand-side of the rule is 
appropriate for linking to the root. 
applicable_chain_rule (Pivot, Parent, 
Root, RHS) :- 
70 choose a chain rule 
chain_rule(Parent, RHS, SemHead), 
... whose sere. head matches pivot 
unify(Pivot, SemHead), 
make sure the categories can connect 
chained_nodes(Parent, Root). 
The information eeded to guide the generation 
(given as the predicates chain_rule,  non_chain_- 
ru le ,  and chained_nodes) can be computed au- 
tomatically from the grammar; a program to com- 
pile a DCG into these tables has in fact been im- 
plemented. The details of the process will not be 
discussed further. The careful reader will have no- 
ticed, however, that no attention has been given 
to the issue of terminal symbols on the right-hand 
sides of rules. During the compilation process, the 
right-hanOi side of a rule is converted from a list of 
categories and terminal strings to a list of nodes 
connected together by the difference-list threading 
technique used for standard DCG compilation. At 
that point, terminal strings can be introduced into 
sentence/decl(S) ---> s ( f in i te) /S .  (1) 
sentence/imp(S) ---> vp(nonfinite,\[np(_)/you\])/S. 
s(Form)/S ---> Subj, vp(Fona,\[Subj\])/S. (2) 
vp(Form,Subcat)/S ---> vp(Form,\[Compl\[Subcat\])/S, Compl. (3) 
vp(Form,\[Subj\])/S ---> vp(Forl,\[Subj\])/VP, adv(VP)/S. 
vp(finite,\[np(_)/O,np(3-sing)/S\])/love(S,O) ---> \[loves\]. 
vp(finite, \[np(_)/O,p/up,np(3-sing)/S\])/call_up(S,O) ---> \[calls\]. (4) 
vp(finite,\[np(3-sing)/S\])/leave(S) ---> \[leaves\]. 
np(3-sing)/john ---> \[john\]. (5) 
np(3-p1)/friends ---> \[fr iends\].  (6) 
adv(VP)/often(VP) ---> \[often\]. 
det(3-sing,X,P)/qterm(every,X,P) ---> \[every\]. 
n(3-sing,X)/friend(X) ---> \[friend\]. 
n(3-pl,l)/friend(X) ---> \[friends\]? 
. . ?  
p/up-- -> \[up\]. (7) 
p/on ---> \[on\]. 
? Figure 1: Grammar Fragment 
the string threading and need never be considered 
further. 
4 .2  An  Example  
We turn now to a simple example to give a sense 
of the order of processing pursued by this genera- 
tion algorithm? The grammar fragment in Figure 
1 uses an infix operator / to separate syntactic and 
semantic ategory information. Subcategorization 
for complements is performed lexically. 
Consider the generation from the category 
sen~ence/dec1(call_up(john,friends) ). The 
analysis tree that we will be implicitly traversing 
in the course of generation is given in Figure 2. 
The rule numbers are keyed to the grammar. The 
pivots chosen during generation and the branches 
corresponding to the semantic head relation are 
shown in boldface. 
We begin by attempting to find a nonchain rule 
that will define the pivot? This is a rule whose 
left-hand-side semantics matches the root seman- 
tics decl  ( cal l_up (john, f r iends  ) ) (although its 
syntax may differ)? In fact, the only such nonchain 
rule is 
sentence/decl(S) ---> s ( f in i te ) /S .  (1) 
We conjecture that the pivot is labeled 
sent ence /dec l (ca l l _up( j  ohn, f r iends)  ). In 
terms of the tree traversal, we are implicitly choos- 
ing the root node \[a\] as the pivot? We recursively 
generate from the child's node \[b\], whose category 
is s(f inite)/cal l_up(john,fr iends). For this 
category, the pivot (which will turn out to be node 
If\]) will be defined by the nonchain rule 
vp(f in i te , \ [np(_) /0,  
p/up, 
np(3-sing)/S\]) 
/call_up(S,0) ---> \ [ca l ls \ ] .  
(4) 
(If there were other forms of the verb, these would 
be potential candidates, but would be eliminated 
by the chained_nodes check, as the semantic head 
relation requires identity of the verb form of a sen- 
tence and its VP head.) Again, we recursively gen- 
erate for all the nonterminal elements of the right- 
hand side of this rule, of which there are none. 
We must therefore connect the pivot \[f\] to 
the root \[b\]. A chain rule whose semantic head 
12 
\[a\] sentence 
/decl(call_up ( john,fr iends)) 
(:) 
\[b\] s ( f in i te)  
/call_up ( john, friends ) 
\[c\] np(3-sing) 
/ john  
If/ 
(s) 
John 
\[d\] vp(fini~e,\[np(3-sing)/john\]) 
/call_up(john,friends) 
\[e\] vp(finite,Cp/up,np(3-s?ng)/john\]) 
/call_up(john,friends) 
vp ( finite, \[np (3- pl)/friends, 
p/up,np(3-sing)/john\]) 
/call_up (john,friends) 
(4) 
calls 
np(3-pl) 
/friends 
I (81 
friends 
p/up  \[h\] 
(T) 
up 
\[g\] 
Figure 2: Analysis Tree Traversal 
matches the pivot must be chosen. The only choice 
is the rule 
vp (Form, Subcat)/S ---> 
vp (Form, \[Compl I Subcat \] ) IS, Compl. 
(z) 
Unifying in the pivot, we find that we must re- 
cursively generate the remaining RttS element 
np(_) / f r iends,  and then connect he left-hand 
side node \[e\] with category 
vp (finite, \[lex/up, 
np (3-s ing)/j ohn\] ) 
Icall_up (j ohn, friends) 
to the same root \[b\]. The recursive generation 
yields a node covering the string "friends" follow- 
ing the previously generated string "calls". The 
recursive connection will use the same chain rule, 
generating the particle "up", and the new node 
to be connected \[d\]. This node requires the chain 
rule 
s(Form)IS ---> 
Subj, vp(Form, \[Subj\])/S. 
(2) 
for connection. Again, the recursive generation for 
the subject yields the string "John", and the new 
node to be connected s ( f in i te ) /ca l l _up( john ,  
f r iends) .  This last node connects to the root \[b\] 
by virtue of identity. 
This completes the process of generating 
top-down from the original pivot senl;ence/ 
decl(call_up(john,friends)). All that re- 
mains is to connect this pivot to the original root. 
Again, the process is trivial, by virtue of the base 
case for connection. The generation process is thus 
completed, yielding the string "John calls friends 
up". The drawing summarizes the generation pro- 
cess by showing which steps were performed top- 
down or bottom-up by arrows on the analysis tree 
branches. 
13 
The grammar presented here was perforce triv- 
ial, for expository reasons. We have developed 
more extensive xperimental grammars that can 
generate relative clauses with gaps and sentences 
with quantified NPs from quantified logical forms 
by using a version of Cooper storage (Cooper, 
1983). We give an outline of our treatment of 
quantification i Section 6.2. 
5 Important Properties of 
the Algorithm 
Several properties of the algorithm are exhibited 
by the preceding example xample. 
First, the order of processing is not left-to-right. 
The verb was generated before any of its comple- 
ments. Because of this, the semantic information 
about the particle "up" was available, even though 
this information appears nowhere in the goal se- 
mantics. That is, the generator operated appropri- 
ately despite a semantically nonmonotonic gram- 
mar. 
In addition, full information about the subject, 
including agreement information was available be- 
fore it was generated. Thus the nondeterminism 
that is an artifact of left-to-right processing, and 
a source of inefficiency in the Earley generator, is
eliminated. Indeed, the example here was com- 
pletely deterministic; all rule choices were forced. 
Finally, even though much of the processing is 
top-down, left-recursive rules (e.g., rule (3)) are 
still handled in a constrained manner by the algo- 
rithm. 
For these reasons, we feel that the semantic- 
head-driven algorithm is a significant improve- 
ment over top-down methods and the previous 
bottom-up method based on Earley deduction. 
6 Extensions 
We will now outline how the algorithm and the 
grammar it uses can be extended to encompass 
some important analyses and constraints. 
6 .1  Completeness  and  Coherence  
Wedekind (1988) defines completeness and coher- 
ence of a generation algorithm as follows. Suppose 
a generator derives a string w from a logical form 
s, and the grammar assigns to w the logical form 
a. The generator is complete if s always subsumes 
a and coherent if a always subsumes . The gen- 
erator defined in Section 4.1 is not coherent or 
complete in this sense; it requires only that a and 
s be compatible, that is, unifiable. 
If the logical-form language and semantic in- 
terpretation system provide a sound treatment of 
variable binding and scope, abstraction and appli- 
cation, completeness and coherence will be irrele- 
vant because the logical form of any phrase will not 
contain free variables. However, neither semantic 
projections in lexical-functional grammar (LFG) 
(Halvorsen and Kaplan, 1988) nor definite-clause 
grammars provide the means for such a sound 
treatment: logical-form variables or missing argu- 
ments of predicates are both encoded as unbound 
variables (attributes with unspecified values in the 
LFG semantic projection) at the description level. 
Then completeness and coherence become impor- 
tant. For example, suppose a grammar associated 
the following strings and logical forms. 
eat(john, X) 
'John ate' 
ea~: (j  olin, banana) 
'John ate a banana' 
eat ( john ,  n ice(ye l low(banana)) )  
'John ate a nice yellow banana' 
The generator of Section 4.1 would generate any 
of these sentences for the logical form eat ( john,  
X) (because of its incoherence) and would generate 
'John ate' for the logical form eat ( john,  banana) 
(because of its incompleteness). 
Coherence can be achieved by removing the con- 
fusion between object-level and metalevel vari- 
ables mentioned above, that is, by treating logical- 
form variables as constants at the description level. 
In practice, this can be achieved by replacing each 
variable in the semantics from which we are gen- 
erating by a new distinct constant (for instance 
with the numbervaxs predicate built into some im- 
plementations of Prolog). These new constants 
will not unify with any augmentations to the se- 
mantics. A suitable modification of our generator 
would be 
gen(Cat, String) :- 
cat_semantics (Cat, Sem), 
numbervaxs (Sere, O, _), 
generate(node(Cat,String, \['1 ) ). 
This leaves us with the completeness problem. 
This problem arises when there are phrases whose 
semantics are not ground at the description level, 
but instead subsume the goal logical form or gener- 
ation. For instance, in our hypothetical example, 
the string 'John eats' will be generated for seman- 
tics eat ( john ,  banana). The solution is to test 
at the end of the generation procedure whether the 
14 
feature structure that is found is complete with re- 
spect to the original feature structure. However, 
because of the way in which top-down information 
is used, it is unclear what semantic information is 
derived by the rules themselves, and what seman- 
tic information is available because of unifications 
with the original semantics. For this reason, so- 
called "shadow" variables are added to the gener- 
ator that represent he feature structure derived 
by the grammar itself. Furthermore a copy of the 
semantics of the original feature structure is made 
at the start of the generation process. Complete- 
ness is achieved by testing whether the semantics 
of the shadow is subsumed by the copy. 
6.2 Quantifier Storage 
We will outline here how to generate from a quan- 
tiffed logical form sentences with quantified NPs 
one of whose readings is the original logical form, 
that is, how to do quantifier-lowering automati- 
cally. For this, we will associate a quantifier store 
with certain categories and add to the grammar 
suitable store-manipulation rules. 
Each category whose constituents may create 
store elements will have a store feature. Further- 
more, for each such category whose semantics can 
be the scope of a quantifier, there will be an op- 
tional nonchain rule to take the top element of an 
ordered store and apply it to the semantics of the 
category. For example, here is the rule for sen- 
tences: 
s(Form, GO-G, Store)/quant(Q,X,R,S) ---> 
s(Form, GO-G, \[qterm(Q,X,R) JStore\])/S. 
The term quant (C~, X, R, S) represents a quantified 
formula with quantifier Q, bound variable X, re- 
striction R and scope $, and cltez~(Q,X,R) is the 
corresponding store element. 
In addition, some mechanism is needed to com- 
bine the stores of the immediate constituents of a 
phrase into a store for the phrase. For example, 
the combination of subject and complement s ores 
for a verb into a clause store is done in one of our 
test grammars by lexical rules such as 
vp(linite, \[np(_, SO)/O, 
np(3-sing, SS)IS\], SC) 
llove(S,O) ---> 
\[loves\], {shuffle(SS, SO, SC)}. 
which states that the store SC of a clause with 
main verb 'love' and the stores SS and S0 of the 
subject and object the verb subcategorizes for sat- 
isfy the constraint shuf:fle(SS, SO, SC), mean- 
ing that SC is an interleaving of elements of SS and 
S0 in their original order, s 
Finally, it is necessary to deal with the noun 
phrases that create store elements. Ignoring the 
issue of how to treat quantifiers from within com- 
plex noun phrases, we need lexical rules for deter- 
miners, of the form 
det(3-sJ.ng,X,P, \[qterm(every,X,P)\] )/X ---> 
\[every\]. 
stating that the semantics of a quantified NP  is 
simply the variable bound by the store element 
arising from the NP. For rules of this form to work 
properly, it is essential that distinct bound logical- 
form variables be represented as distinct constants 
in the terms encoding the logical forms. This is an 
instance of the problem of coherence discussed in 
the previous section. 
The rules outlined here are less efficient than 
necessary because the distribution of store ele- 
ments among the subject and complements of a 
verb does not check whether the variable bound 
by a store element actually appears in the seman- 
tics of the phrase to which it is being assigned, 
leading to many dead ends in the generation pro- 
cess. Also, the rules are sound for generation but 
not for analysis, because they do not enforce the 
constraint hat every occurrence of a variable in 
logical form be outscoped by the variable's binder. 
Adding appropriate side conditions to the rules, 
following the constraints discussed by Hobbs and 
Shieber (Hobbs and Shieber, 1987) would not be 
difficult. 
6.3 Postponing Lexical Choice 
As it stands, the generation algorithm chooses par- 
ticular lexical forms on-line. This approach can 
lead to a certain amount of unnecessary nonde- 
terminism. For instance, the choice of verb form 
might depend on syntactic features of the verb's 
subject available only after the subject has been 
generated. This nondeterminism can be elimi- 
nated by deferring lexical choice to a postprocess. 
The generator will yield a list of lexical items in- 
stead of a list of words. To this list a small phono- 
logical front end is applied. BUG uses such a 
mechanism to eliminate much of the uninterest- 
ing nondeterminism in choice of word forms. Of 
course, the same mechanism could be added to any 
of the other generation techniques discussed to in 
this paper. 
5Further details of the use of shuffle in scoplng are 
siren by Pereira and Shieber (1985). 
15 
7 Fur ther  Research  
Further enhancements to the algorithm are envi- 
sioned. First, any system making use of a tabular 
link predicate over complex nonterminals (like the 
chained_nodes predicate used by the generation 
algorithm and including the link predicate used 
ill the BUP parser (Matsumoto et al, 1983)) is 
subject to a problem of spurious redundancy in 
processing if the elements in the link table are 
not mutually exclusive. For instance, a single 
chain rule might be considered to be applicable 
twice because of the nondeterminism of the call 
to chained_nodes. This general problem has to 
date received little attention, and no satisfactory 
solution is found in the logic grammar literature. 
More generally, the backtracking regimen of our 
implementation f the algorithm may lead to re- 
computation of results. Again, this is a general 
property of backtrack methods and is not partic- 
ular to our application. The use of dynamic pro- 
gramming techniques, as in chart parsing, would 
be an appropriate augmentation to the implemen- 
tation of the algorithm. Happily, such an augmen- 
tation would serve to eliminate the redundancy 
caused by the linking relation as well. 
Finally, in order to incorporate a general facility 
for auxiliary conditions in rules, some sort of de- 
layed evaluation triggered by appropriate instanti- 
ation (e.g., wait declarations (Nalsh, 1986)) would 
be desirable. None of these changes, however, con- 
stitutes restructuring of the algorithm; rather they 
modify its realization i  significant and important 
ways. 
Acknowledgments 
Shieber, Moore, and Pereira were supported in 
this work by a contract with the Nippon Tele- 
phone and Telegraph Corp. and by a gift from 
the Systems Development Foundation as part of 
a coordinated research effort with the Center for 
the Study of Language and Information, Stanford 
University; van Noord was supported by the Euro- 
pean Community and the Nederlands Bureau voor 
Bibliotheekwezen en Informatieverzorgin through 
the Eurotra project. We would like to thank Mary 
Dalrymple and Louis des Tombe for their helpful 
discussions regarding this work. 
Bibliography 
Jonathan Calder, Mike Reape, and Hank Zeevat. 
1989. An algorithm for generation i unification 
categorial grammar. In Proceedings of the ~th 
16 
Conference of the European Chapter of the As- 
sociation for Computational Linguistics, pages 
233-240, Manchester, England (10-12 April). 
University of Manchester Institute of Science 
and Technology. 
Alain Colmerauer. 1982. PROLOG II: Manuel 
de r~ference et module th~orique. Technical re- 
port, Groupe d'Intelligence Artificielle, Facult~ 
des Sciences de Luminy, Marseille, France. 
Robin Cooper. 1983. Quantification and Syntac- 
tic Theory, Volume 21 of Synthese Language Li- 
brary. D. Reidel, Dordrecht, Netherlands. 
Marc Dymetman and Pierre Isabelle. 1988. Re- 
versible logic grammars for machine transla- 
tion. In Proceedings of the Second International 
Conference on Theoretical and Methodologi- 
cal Issues in Machine Translation of Natural 
Languages, Pittsburgh, Pennsylvania. Carnegie- 
Mellon University. 
Arnold Evers. 1975. The transformational cycle 
in German and Dutch. Ph.D. thesis, University 
of Utrecht, Utrecht, Netherlands. 
Per-Kristian Halvorsen and Ronald M. Kaplan. 
1988. Projections and semantic description 
in lexical-functional grammar. In Proceedings 
of the International Conference on Fifth Gen- 
eration Computer Systems, pages 1116-1122, 
Tokyo, Japan. Institute for New Generation 
Computer Technology. 
Susan Hirsh. 1987. P-PATR, a compiler for uni- 
fication based grammars. In Veronica Dahl and 
Patrick Saint-Dizier, editors, Natural Language 
Understanding and Logic Programming, II. El- 
sevier Science Publishers. 
Jerry R. Hobbs and Stuart M. Shieber. 1987. 
An algorithm for generating quantifier scopings. 
Computational Linguistics, 13:47-63. 
Riny A.C. Huybrechts. 1984.. The weak inad- 
equacy of context-free phrase structure gram- 
mars. In G. de Haan, M. Trommelen, and 
W. Zonneveld, editors, Van Periferie naar 
Kern. Forts, Dordrecht, Holland. 
Yuji Matsumoto, Hozumi Tanaka, Hideki Hi- 
rakawa, Hideo Miyoshi, and Hideki Yasukawa. 
1983. BUP: a bottom-up arser embedded in 
Prolog. New Generation Computing, 1(2):145- 
158. 
Michael Moortgat. 1984. A Fregean restriction on 
meta-rules. In Proceedings of NELS 14, pages 
306-325, Amherst, Massachusetts. University of 
Massachusetts. 
Lee Naish. 1986. Negation and Control in Pro. 
log, Volume 238 of Lecture Notes in Computer 
Science. Springer-Verlag, Berlin, Germany. 
Fernando C.N. Pereira and Stuart M. Shieber. 
1985. Prolog and Natural-Language Analysis, 
Volume 10 of CSLI Lecture Notes. Center for 
the Study of Language and Information, Stan- 
ford, California. Distributed by Chicago Uni- 
versity Press. 
Fernando C.N. Pereira and David H.D. Warren. 
1983. Parsing as deduction. In Proceedings 
of the 21st Annual Meeting, Cambridge, Mas- 
sachusetts (June 15-17). Association for Com- 
putational Linguistics. 
Fernando C.N. Pereira. 1981.  Extraposi- 
ties grammars. Computational Linguistics, 
7(4):243-256 (October-December). 
Carl Pollard. 1988. Categorial grammar and 
phrase structure grammar: an excursion on 
the syntax-semantics frontier. In R. Oehrle, 
E. Bach, and D. Wheeler, editors, Categorial 
Grammars and Natural Language Structures. D. 
Reidel, Dordrecht, Holland. 
Stuart M. Shieber. 1985a. An Introduction 
to Unification-Based Approaches to Grammar, 
Volume 4 of CSLI Lecture Notes. Center for the 
Study of Language and Information, Stanford, 
California. Distributed by Chicago University 
Press. 
Stuart M. Shieber. 1985b. Using restriction to 
extend parsing algorithms for complex-feature- 
based formalisms. In 28rd Annual Meeting of 
the Association for Computational Linguistics, 
pages 145-152, Morristown, New Jersey. Asso- 
ciation for Computational Linguistics. 
Stuart M. Shieber. 1988. A uniform architecture 
for parsing and generation. In Proceedings of 
the 12th International Conference on Compu- 
tational Linguistics, pages 614-619, Budapest, 
Hungary. 
Mark Steedman. 1985. Dependency and coordi- 
nation in the grammar of Dutch and English. 
Language, 61(3):523-568. 
Jiirgen Wedekind. 1988. Generation as structure 
driven derivation. In Proceedings of the 12th In- 
ternational Conference on Computational Lin- 
guistics, pages 732-737, Budapest, Hungary. 
17 
