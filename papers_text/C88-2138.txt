~ ,=~ ~{:,,j:b~\[i- . . . . .  ,i ~ H '{~,~ ~ ~:!i+~,~_~ - 
el'tiler i~ti' \[Vtai}bliit~ -i rrii'l.sl:l{ii~n 
and 
Oeitlpalt~r {-Ji}ieiic~, 8ap~i~r~i~)itl; 
Oaii t ~!gi~J- ~'iellc~li Ui~iwtrsil 7
Pltl~_~bt!rgli, i~Ait;41,'l, t.ISA 
l.e~icoii-drtvert forinalisi'ns (e,{I. Categorial Gramm~r, ili',8C4 arid 
(~l-J (\[ti'~rna r), which dn r~ol have e?plicil phrase slitil~ilJre tales, ai'~ 
sutlable for higher le, vel syritax but eel far low level b.liigu~ljo- 
spoclfi(; ooii~trtlclions Stlch as dales (Jely l{;th, 15,-JUL-19{17, at,;), 
wlitch sootri to require lhe power of phrase .~iti?!Jollire rrilos. 'Fhlt,; 
fJ~'~i)ei' t31"r).'lenl!~ an h+iiploi~iolilaihiu nloll'ied itJ ceiTil:~llle lext0ul!., 
ddvoii parsllig ~lild phras(t D, triJcluro parsing, with a si)cclal riitl~liis 
~;alled ~#raph.,sfiuctisr'ed stack. 
I.fo~>get llngui,~;lic ~rafnrear toeilalisms earl be classilled halo Iwe 
f~liillles, pht~\]se-,<;tructure-based or lexlcorkdriven. -\[bt~ phrase ? 
~trl.lCtuie.i)ased foriiialisrlis hiclude Oeflnile Clause (-lrarnn-lar \[IJ\], 
Le?fcal Ftnctioaal Granimar\[3\], Gerleralized Phrase L~tructuro 
(~raiillTlar \[.'J, 6 i alld F:tinclierial Uriificatioa Granlmar t7\]. \ ]hey all 
are h~,,.;~-i(; eu context-free phrase structure rules wliich ar~-) 
~ugieelltet'~ iH ella way or arlether. On lbe olher 1lend, Io?icoli- 
driw;ii tei'inalh~i~s iucledo Catogorial OraaIrrlar\[l\], tlead-diivoli 
Phi'a~Jo f~trdclere (-iralnnlar \[9, 10| arid GtJ-(71rammar \[4, 13\]. All e! 
tliese lexicoll..drivon forMalislos do riot have any explioil ptiadltJ 
stuJClllre rillos, but lulorfuatioe about bow to ceicbirie oorisilllleii~f~ 
inlo a high~;r coastlitJerlt is ella:cried ill each lexicoe or COilSiitLl~!~lit 
which is I(i be combined. It Is elicit argued that Ioxicerl.-ddverl 
trll'lrl~rtlisnls cEIn haiidle sonI?7 Iieguistlc pll(.~rlOlllentt lJtlCl/ a{'l free- 
word-order Ifiero elogaritly, aud also they can capture uriiversalily (if 
rnlilliple languages, as described, for exarriple, by Wehili t14\]. 
Iil section 2, on lhe other I'land, it is argued that, while lexioon- 
driven forinalisins might be suitable 1o cope will\] linguistically 
"intereslh'ig" phenonioea, they lack the power to express 
linguistically "enieteresting" phenoe~eaa which are ellen very 
specific to a pallicular language, Unfollunaiely, in order to build a 
praclical pai~er for a "real" taxi, one must haudle wry  irlany 
"uainteresting" low level pPlenornena which canaot be ea,,ill 7 
~ormalized hi the lexicon-driveri way. Heriee, tf we Wahl Io build ~ 
praclical p~lrser wllh ~ theory behind lhe Ioxicori-drlven tor,i~alisms, 
iheri it ls ttssenllal to eat'tibiae lexicon-driven parshlg (for higher 
level synti~,") and phlase-structere-based parsing (lor low level delall 
and other liingeago-specilic/exceptioiral coiistrtictioris). 
In seelion 3, we geaeralize lho compulalleaal models of all the 
iexicoe-driveu urid phrase..st reclure-based terrnaltsiris as 
shift.reduce parsing. 8eclioa 4 hllreduces the 9raph-structur~Jd 
stack to handle rlori-deterrniaisrn in shill-reduce parsing, in soclloes 
<5 r!ud 6, we doscrib~J the use of tile grapli..sltuclured slack Iri 
I..exlcou ddvon and i:~llrase-strucltne-based parsiug, respecllvely. 
We then diucuss trlow to cembiae lhese lwo kinds of parsinfj wilh lho 
graph--struclurod stack, in secllen 7. 
lit It)rau{ical af)pllcatieii.% llii)lii seriterictt,-J have> iliaiiy Jali\[flll!,.j~:, 
~-ip~.cilic ph~)ilOlilOili~ ihal aro riot Iin.quislioaliy 'iiltoiu~lin{j'L 
COl isidt~r iIi{+, t .ill~:whl~} s~ntendo8: 
"i'ak~ lwo tabletu uf asl~irirt i'O~lr thrlo:, a day. 
{\]cite(bile. a riioelhi(.j wiih LJoctorJait)le (;aib(l~l~Jl# 
itu July J Sth freiil <'J,':70 I ~\[V\]. 
All ef those ~;ci~lenu~s ctliltt~in i'lO hitereslin{! '~yrltax i:/,icaioin~!i:~, 
hul have a lot of h~i~geage-,spccific luw.l~vol cen<~tiuctiu~,<;, :~dch ~s 
"tiJl.lr ttlflOS ~ day". ~\[ ocelus the.it lhere i~ tin be/tur w~v te siJ,~cif,/ 
this palleei lhtln a pt~rase strllottiro itllo: 
<lrequtJiit;y> .:-.-. <inte.ger> <lilacs> <hiletie~> <tiiNc).uilit> 
atl{irnerltod iu one way ~rf ~inotlier to clieck nlllnber tt{ji%oni(,qli ~lil 
.~Jinlilar ar(jeMents carl be tllado fer telos: 
<p~3i'SOrloilaele> <-(-- <:title:. <first riarnit> <last-llaine> 
<time> <-- <hiteuer> ":" <integer::, ("AM" I "PIVl") 
t i iese OOliStM(;iierls are "llliiiiiorebtill\[j i' boc~.iiise wo all i,'.ii~,w theft i? 
IS radices ta specily Ihiit;o pilt~lieinljna, r~ii(I il is tit,st a m{iti~)r uf 
uifliil(~ (1uvtlll alid wrilifig rules, litlorelei(-), for lh(,, I)tlrt)~l,4~ af 
Ihiguistic sludt, lliey c~il he jusl ignored, hi pi'~lciical at)plff;atio~l~? 
htlwever, we ciillno~. Ignero IIiolii by lilly II/O{tlIS, Ifi loci, iliiJilt 
s~iileuces are iilll of tlieso "ttiiinieiestin(j" pbel lOllit;lie, 
tlrifolttlri,'.llel 7, More lhari hall of \[{liglish L~lid J{lpr_liieso (ji{~ftlfli~li" 
rules lor OlVtU's nlachine trallslaiioli proj~.,ct, tot Oxaiiiplo, ale 
lall.q, ea{te-Sl)eoitic "uIIiaterosliug" lew-lev~;I rtlles. It is extJocte, d/iiat, 
tu (-lily priloticai system, there iliiJst be a bunch el i'ele.<~ like tli(~so 
.bOiilev?ilero hi the ',;ysteiil; ellie~wise tile sy~lelil siiriply do(~,,J ilet 
wail(, 
Loxleoil-diiw-~ll torrnallsll'is ~ire all nreliv;:itud b 7 Ihitjuisiicc.illy 
"iilterestirig 'l phonoineua, arid they are riot slJltod lot {li(~.'io 
lari{luage-n|~)cific low level conslructicns. It doe.,; iiel inalto {lily 
sense to try to write Illose roles In tile iexicen-driveri way, oven if il 
is niatheillalically passible. It is clear lll~t lhe power ul plira,so 
Stil,icture is necessary far praclical applications, h, ilia iollet;,~iilfj 
scalieris, we describe Ilow te COiFiblilo le?icoil.driv~li palshlC i ;~lrlil 
pllraSe-StrtlClUre..based paisitlr i. 
3? ~}hif l -~:teduco Pa~'slil!~ 
Lot iis con.~ider belb Io?icurv.cMvel~ and pllrase.sltttisltJic~bctscd 
parsing to be sllifl-reduce parshrg. In tJliifl-rol:luco parshi~i, tbero i,~; ~ 
stack, arid all wolds hi lho input senieiico are pu,<Jhod (shiiiod) ~JJit~ 
Ilie slacl( frnin loft io 7'i,(jlil. lil dohig ue, the first ii coii<.tilucJili.~s (el 
words) from the lop of the sf~-~ck are ucc~.~ioilally eombinc.d 
(r~duced), by popping tile li coii.slittioiiis irorn the stai.'k, t;/ilspttlin U
~t n~w coristituent lrore ttro constiteonls, alid iJiJsliiiig iiio ii~w 
COli~IIIileill cilia tile stack. A shili, rodllce parser rio6'ds lo iJ_J 
(,.41 
controlled to determine when and how constituents should be 
reduced, and when a word should be shifted. 
In phrase-structure=based parsing, it Is controlled by a set of 
language-specific rules, typically a context-.free phrase structure 
grammar, augmented in one way or another. 
In lexicon-driven parsing, it is controlled by information encoded 
in each constituent o be reduced, and (if arly) a set of language 
universal rules which reside inside the parser permanently, but with 
no language-specific outside rules. In the Categorlal Grammar 
formalism, this Information is encoded as complex categodes with 
functor and argument features. Two elements can be reduced If 
and only it the category of one element is the same as the argument 
feature of the other element, and the category of the new element 
will be the functor of the latter element. In GB Parsing, categories 
are encoded In accordance with the X-bar theory, and some 
language-universal rules (often called principles) are fired to decide 
whether a particular pair of elements can be reduced. 
In bolh phrase-structure-based and lexicon-driven parsing, there 
are cases where it cannot be uniquely determined whether the next 
action should be reduce or shift, or cases where more than one 
reduce action is possible at the same time. This means that the 
parser must handle some non-determinism, and naive techniques 
such as simple back tracking or breath first search would require 
exponential time. The parsing time, however, can be reduced to 
polynomial with a graph-structured stack, which is described In the 
following section. 
4. The Graph-St ructured  Stack  
The graph-structured stack was introduced in the Genera/Ized LR 
Parsing algorithm \[11, 12\], to handle non-determinism In LR parsing 
in polynomial time. In this section, three key notions, splitting, 
combining and local ambiguity packing, are described. 
4.1. Splitt ing 
When a stack needs to be reduced (or popped) In more than one 
way, the top of the stack Is split as in the following example. 
Suppose that the stack Is In the following state, The left most 
element, A, is the bottom of the stack, and the right most element, 
E, is the top of the stack. In a graph-structured stack, there can be 
more than one top, whereas there can be at most one bottom. 
A - - -  B - - -  C - - -  D - - -  E 
Suppose that the stack needs to be reduced in the following three 
different ways. 
F < - - D E  
G < - - D E  
H<- -  C D E 
Then after the three reduce actions, the stack looks like: 
/ - - r  
/ 
/ 
A ~- -  B - - -  C . . . .  G 
\ 
\ 
\ . . . . . . . .  l~ 
4.2. Combining 
When an element needs to be shifted (pushed) onto two or more 
tops of the stack, It Is done only once by combining the tops of the 
stack. For example, If "1" is to be shifted to F, G and H in the above 
example, then the stack will look like: 
/ - -  r - - - \  
/ \ 
/ \ 
A - - -  B - - -  C . . . .  G . . . .  
\ / 
\ / 
\ . . . . . . . .  H - - /  
4.3. Local Ambiguity Pecking 
If two or more branches of the stack turned out to be Identical, 
then they represent local ambiguity; the Identical state of stack has 
been obtained in two or more different ways. They are merged and 
treated as a single branch. Suppose we have two rules: 
J< - -  T I 
J< - -  G ~ 
After applying these two rules to the example above, the stack will 
look tlke: 
A- - -  B . . . .  C - - -  J 
\ 
\ 
\ - -  H - - -  z 
The branch of the stack, "A-B-C-J", has been obtained In two ways, 
but they are merged and only one Is shown in the stack. 
5. Lex icon-Dr iven  Pars ing  wi th  a Graph-St ructured  
Stack  
There is an obvious way to implement a lexicon-driven parser 
with the graph-structurad stack. Basically, the parser parses a 
sentence strictly from left to dght, shifting a word onto the stack erie 
by one. The tops of the stack are Inspected to see If there are any 
ways to reduce the stack (remember, there are no outside phrase 
structure rules In lexicon-driven parsing). The stack gets reduced 
non-destructive~y, wherever possible. A non-destructive reduce 
action simply adds a new branch to the stack, without removing the 
old branch of the slack that has been reduced. The following 
example shows the stack before and after the reductions of C and D 
into E, and 8 and E into F. 
A - - -  B - - -  C - - -  D 
/ . . . . . . . . . . .  F 
/ 
/ I . . . . . . .  z 
/ / 
/ / 
A- - -  B - - -  C - - -  D 
Repeat until no further reduce action Is possible (note that one 
reduce action can trigger another reduce action). When no further 
reduce action Is possible, the next word is shifted. When a word Is 
shifted, all tops of the stack are inspected whether they can be 
shifted the word onto. Even when a word has been shifted onto 
more than one top of the stack, there is at most one element on tim 
top of the stack, due to stack combining descdbed In the previous 
668 
section. Thus, If a word G ts shifted onto F, E and D, then the stack 
will look like: 
/ . . . . . . . . . . .  r -~ \  
/ \ 
/ / / 
/ / / 
a . . . .  B . . . .  c ~- -  D . - /  
When an how top elements can be reduced Is determined by 
Informatk~n encoded In each element Itself, and the method vartes 
from one formalism to another, as described in section 2. 
6. Phrase-St ructure .Based  Pars ing  w i th  a 
Graph-St ructured  Stack  
Tonrita \[11, 12\] Introduced a generalized LR parsing algorithm, 
which is an LR parsing algorithm generalized to handle arbitrary 
context-free grammars with the graph-structured stack, The 
standard (not generalized) LR parsing algorithm is one of the most 
efficient parsing algodlhms. It Is totally deterministic, no 
backtracking or search is involved, and it runs in linear time. This 
standard LR parsing algorithm, however, can deal with only a small 
subset of context-free grammars called LR grammars, which Is often 
sufliclent for programming languages but clearly not for natural 
languages. I1, for example, a grammar is ambiguous, then Its LR 
table would have multiple entries, and hence deterministic parsing 
would be no longer possible. By Introducing the graph-structured 
stack, however, mulUple entries can be handled efficiently In 
polynomhd time. 
Figures 6-1 and 6-2 show an example of a non-LR grammar and 
Ils LR table. Grammar symbols starting with "*" represent pro- 
terminals. Entries "sh n" In the action table (tile left part of tire table) 
Indicate that the action "shift one word from Input buffer onto the 
slack, and go to stale n". Entries "re n" indicate that the action 
"reduce constituents on the stack using rule n", The entry "acc" 
stands for the action "accept", and blank spaces represent "error". 
The goto table (the right part of the table) decides to what slate tire 
parser should go alter a reduce action. The LR parsing algorithm 
pushes state numbers (as well as constituents) onto tile stack; the 
state number on lhe top of the stack indicates the current state. The 
exact definition and operation of the LR parser can be found in Aho 
and Ullman \[2\]. 
We can see that there are two multiple entdes in the action table; 
on the rows of slate 11 and 12 at the column labeled "*prep", 
Roughly speaking, thts Is the situation where the parser encounters 
a preposition of a PP right after a NP. If this PP does not modlly the 
NP, then the parser can go ahead to rednce the NP to a higher 
nontermlaal such as PP or VP, using rule 6 or 7, respectively (re6 
and re7 In lhe multiple entries). If, on the other hand, the PP does 
modify the NP, then the parser must wait (sh6) until the PP Is 
completed so It can build a higher NP using rule 5. 
With a graph-structured stack, we can handle these non- 
deterministic phenomena nicely. Figure 6-3 shows the graph- 
structured stack dghl after shifting the word "with" in the sentence "1 
(i) s - -> NP vP 
(2) s - -> s ~P 
(3) NP - -> *n 
(4) NP - -> *det *n 
(5) NP ---> NP PP 
(6) PP --'> *prep NP 
(7) VP - -> *v NP 
Figure 6-1 : An Example Ambiguous Grammar 
State  *dot *n *v *prep $ NP PP VP S 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
0 sh3 sh4 2 i 
i sh6 ace 5 
2 sh7 sh6 9 8 
3 shl0 
4 re3 re3 re3 
5 re2 re2 
6 sh3 sh4 ii 
7 sh3 sh4 12 
8 rel tel  
9 re5 re5 re5 
10 re4 re4 re4 
Ii re6 re6, sh6 re6 9 
12 re7 ,sh6  re7 9 
F igure  6-2:  LR Parsing Table with Multiple Entries 
(derived from the grammar In fig 6-1) 
/ . . . . . . . . . . . . . .  s . . . . . . . . . . . . . . . . . . . .  1 . . . . . . . . . . . . . .  \ 
/ \ 
/ . . . . . . . . . . . . .  s . . . . . . . . . . . . . . . . .  z . . . . . .  \ \ 
/ \ \ 
/ / . . . . . . . . .  .~ . . . . . .  12 . . . . . . .  \ \ 
/ / \ \ 
0---NP--2---v--=7==-NP--12--~p---6---NP--ll---p--=6---NP--ll---p---6 
\ \ / \ / / 
\ . . . . .  s . . . .  z . . . .  \ . . . . . . . . . . .  / \ . . . . . . . . .  up . . . . . . . . .  / / 
\ / 
\ . . . . . . . . .  NP . . . . . . . . . . . . . .  6 . . . . . . . . . . . .  / 
F igure 6-3:  A Greph-Structumd Stack 
669 
~a~v a man or\] the bed i~ th,~ apartme=~t with a tolesc~pa." i~,~,~',~ 
discassions on the generalized I.F{ pa~*Jlng algorithm can be fo~.~ 
in Tornlta \[1 "1, IV-\]. 
7. Combh=ing  Phr~e-~ructure ,B~sed and  
Lex icon-Dr iven  P~l~tg  
In th:~ prevlou,~ sections, we have de~crib~d th~ e.~e of th~ g~-a~h- 
structured stack for lexicon-driven and phrr~se-;;truciure.ba~e~i 
parsing. It is now rather obvious that we can combine texicoa- 
driver~ and phrase-structure-based p~r~ing; there are two way,\]. 
We can enhance the generalized Lt~ parsing algoriihm by 
allowing Io?icons to (optionally) have le?icon-driv~n rules. That Is, 
the stack is periodically inspected to see il any parl of the stack c~n 
be reduce by a lexicon-driven rule inside lexicons. Thl,~ way I.'.~ 
preferable if a system has re.any phrase structure roles, with ~ few 
lexicon?driven rules io I~andle certain linguistic phe.~omen,~ more 
easily. 
Alternatively, we can enhance lexicon-driven parsing described ia 
section 5 by allowing tbe parser to reduce tops of the stack u~l~g 
out~ide phr~.-~se structure rules as well. That is, the stack i~ 
periodically inspected to see if any part of the stack can he reduced 
using one of the phrase-structure rules. This way is preferable ff ~ 
system is heavily lexicon-driven, with a few phrase structure rule~ to 
handle low level and/or exceptional phenomena. 
8. Summary  
This paper first argued that if is neces~r,/ to enhance lexic{~l- 
driven parsing witl~ phrase structure rules in practical applications. 
We then suggested a shift-reduce implementation of lexicon-driven 
parsing with a graph-structured stack, which is readily combinable 
with a shift-reduce implementation of phrase~struclm~-bas~d 
parsing with a graph-structured stacl< (i.e, the generalized LH 
algorithm). 
\[1\] AO~,, A. E. ~ad Steed6a~, ~'~'J. J.
On the Ord~r of Word~. 
Llt,.(}ei:~lic~ arid Philosophy 4(4):5t 7-SSft, t 98~. 
\[;:21 Ahn, A. V. ~nd UUmau, J. O. 
fb#~ciple.~ of Compiler De~i~J. 
A~::i~lsen We~dey, 1977. 
t.exical-.F~_~ctloaal Gra~n~r: A Formal 8yste~ fo~' 
Oran~ati~al ~3epr~-~sent~t~ot\]. 
The Mental flepresent~tiott of (:;rammatic,~l f el:JtY~n~. 
r~lT Press, Oaa'lb~ldge, Mas.~anhu~et|~, "i~}t)2, p~,g~cJ f~. 
! 73-26 l. 
\[4\] Cl/olfl~ky, N. 
Lecturet~ on Government arid BMding. 
l-:e~ls P~b!lcatlons, t98t. 
\[5\] Oaz.da~, O. 
Phrase Structure Gmmmar~ and Natural Langu~ge. 
F'roco~dlng~ of MCA183 v.'t, Aug~st, 1983. 
~(6\] Dowry, D. FL, Kar~ur~en, L. arid Zwicl~', A. IV,'. (~ditoi'). 
Generalized Phrase Sl~tctut~ Grammar: 
Harvard University Press, C, amb~idge, Mass., t 985. 
\[7\] Kay, IVl. 
Parsing ii~ FuncUonal Unification Grammar. 
Natural Language Parsing: P~ychological, GompetaEot~al 
and Iheot~tical Perspectives. 
Cambridge University Press, Carnbddge, England, t 985, 
pages 251 ..278, Chapter 7; 
\[8\] Perelra, P. and Warren, D. 
Definite Clause Grammar lot LaHguage Analysis. 
At~ificial Intelligence 13:pp231-278, May, 1980. 
\[9\] Pollard, C. 
Gor~eralized Phra.~ Structure) Grammars, \ [ l~d  Ot'~mm~m, 
attd Nataral Languages. 
PhD thesis, Stanford Universtly, 1984. 
\[t0\] Pollard, G. 
Locturo Notes on Head-driven Phrase-~tructnre Grammar. 
1985. 
\[t 1} Ten, Ira, t~l. 
Efficient Parsing for Natural Langu,~ge. 
Klawer Academic Publishers, Boston, IVtA, 1985. 
\[~2\] Tomlt~, ~. 
An Efficient Augmented-Context-Free Parsing Algorithm. 
Computational Linguistics 13(1-2):31..46, January-Juno, 
t 987. 
\[ ' i~ W~hdl, E. 
A Govemment-Blndirto Parser for FTench. 
Working Paper 48, Instliut pour los Eludes Semantlque8 et 
Cogrtltlves, Univer~lt~ de Cohere, 1984. 
\[t4\] Wehdl, E. 
Pa~'slng with a GB-grammar. 
1987. 
670 
