CATEGORIAL SEMANTICS AND SCOPING 
Fernando C. N. Pere i ra  
AT & T Bell Laboratories 
600 Mountain Ave. 
Murray Hill, N J  07974 
Certain restrictions on possible scopings of quantified noun phrases in natural language are usually expressed 
in terms of formal constraints on binding at a level of logical form. Such reliance on the form rather than the 
content of semantic interpretations goes against the spirit of compositionality. I will show that those scoping 
restrictions follow from simple and fundamental facts about functional application and abstraction, and can 
be expressed as constraints on the derivation of possible meanings for sentences rather than constraints of 
the alleged forms of those meanings. 
1 AN OBVIOUS CONSTRAINT. 9 
Treatments of quantifier scope in Montague grammar 
(Montague 1973; Dowty et al 1981; Cooper 1983), trans- 
formational grammar (Reinhart 1983; May 1985; Heim 
1982; Roberts 1987), and computational linguistics (Hobbs 
and Shieber 1987; Moran 1988; Alshawi et al 1989) have 
depended implicitly or explicitly on a constraint on possible 
logical forms to explain why examples 1 such as 
1. *A woman who saw every man disliked him 
are ungrammatical, nd why in examples such as 
2. Every man saw a friend of his 
3. Every admirer of a picture of himself is vain 
the every. . ,  noun phrase must have wider scope than the a 
? . .  noun phrase if the pronoun in each example is assumed 
to be bound by its antecedent. What exactly counts as 
bound anaphora varies between different accounts of the 
phenomena, but the rough intuition is that semantically a 
bound pronoun plays the role of a variable bound by the 
logical form (a quantifier) of its antecedent. Example (1) 
above is then "explained" by noting that its logical form 
would be something like 
3 w.woman(w) /k (Vm.man(m) ~ saw(w, m)) 
/~ disliked(w, m) 
but this is "ill-formed" because variable m occurs as an 
argument of disliked outside the scope of its binder Vm.2 
As for Examples (2) and (3), the argument is similar: wide 
scope for the logical form of the a . . .  noun phrase would 
leave an occurrence of the variable that the logical form of 
every. . ,  binds outside the scope of this quantifier? For lack 
of an official name in the literature for this constraint, I will 
call it here the free-variable constraint? 
In accounts of scoping possibilities based on quantifier 
raising or storage (Cooper 1983; van Eijck 1985; May 
1985; Hobbs and Shieber 1987) the free-variable con- 
straint is enforced either by keeping track of the set of free 
variables free (q) in each raisable (storable) term q and 
when x ~ free (q) blocking the raising of q from any 
context Bx.t in which x is bound by some binder B, or by 
checking after all applications of raising (unstoring) that 
no variable occurs outside the scope of its binder. 
The argument above is often taken to be so obvious and 
uncontroversial that it warrants only a remark in passing, if 
any (Cooper 1983; Reinhart 1983; Partee and Bach 1984; 
May 1985; van Riemsdijk and Williams 1986; Williams 
1986; Roberts 1987), even though it depends on nontrivial 
assumptions on the role of logical form in linguistic theory 
and semantics. 
First of all, and most immediately, there is the require- 
ment for a logical-form level of representation, either in the 
predicate-logic format exemplified above or in some tree 
format as is usual in transformational grammar (Heim 
1982; Cooper 1983; May 1985; van Riemsdijk and Williams 
1986; Williams 1986; Roberts 1987). 
Second, and most relevant o Montague grammar and 
related approaches, the constraint is given in terms of 
restrictions on formal objects (logical forms), which in turn 
are related to meanings through a denotation relation? 
However, compositionality as it is commonly understood 
requires meanings of phrases to be functions of the mean- 
ings rather than the forms of their constituents? This is a 
problem even in accounts based on quantifier storage (Coo- 
per 1983; van Eijck 1985), which are precisely designed, as 
van Eijck puts it, to "avoid all unnecessary reference to 
properties o f . . .  formulas" (van Eijck 1985, p. 214). In 
fact, van Eijck proposes an interesting modification of 
Cooper storage that avoids Cooper's reliance on forbidding 
vacuous abstraction to block out cases in which a noun 
phrase is unstored while a noun phrase contained in it is still 
in store? However, this restriction does not deal with the 
case being addressed here. 
Computational Linguistics Volume 16, Number 1, March 1990 1 
Fernando C.  N .  Pereira Categorial Semantics and Scoping 
It is also interesting to observe that a wider class of 
examples of forbidden scopings would have to be consid- 
ered if raising out of relative clauses were allowed, for 
example in 
4. An author who John has read every book by arrived 
In this example, if we did not assume the restriction against 
raising from relative clauses, the every . . .  noun phrase 
could in principle be assigned widest scope, but this would 
be blocked by the free-variable constraint as shown by the 
occurrence of a free as an argument of book-by in 
Vb.book-by(b, a) =:- (3 a.author(a) 
A has-read(john, b) A arrived(a)) 
That is, the alleged constraint against raising from rela- 
tives, for which many counterexamples xist (Vanlehn 
1978), blocks some derivations in which otherwise the 
free-variable constraint would be involved, specifically those 
associated to syntactic onfigurations of the form 
\ [NP  i " " " N\[g-  ? ? \ [NP j .  ? ? X i ? ? . \ ] -  ? - \ ] "  ? - \ ]  
where X~ is a pronoun or trace coindexed with NPt and NPj 
is a quantified noun phrase. Since some of the most exten- 
sive Montague grammar fragments in the literature (Dowty 
et al 1981; Cooper 1983) do not cover the other major 
source of the problem, PP complements of noun phrases 
(replace S by PP in the configuration above), the question is 
effectively avoided in those treatments. 
Conversely, it could be argued that the free-variable 
constraint is responsible for forcing a quantifier to raise 
outside a relative clause in examples such as 
5. The slush fund that every minister needs is kept by his 
private secretary. 
Here, the coindexing of every minister and his forces the 
former to be scoped outside the main clause, and thus 
outside the relative clause in which it occurs. 
The main goal of this paper is to argue that the free- 
variable constraint isactually aconsequence of basic seman- 
tic properties that hold in a semantic domain allowing 
functional application and abstraction, and are thus inde- 
pendent of a particular logical-form representation. As a 
corollary, I will also show that the constraint is better 
expressed as a restriction on the derivations of meanings of 
sentences from the meanings of their parts rather than a 
restriction on logical forms. The resulting system is related 
to the earlier system of conditional interpretation rules 
developed by Pollack and Pereira (1988), but avoids that 
system's use of formal conditions on the order of assump- 
tion discharge. 
2 CURRY'S CALCULUS OF FUNCTIONALITY 
Work in combinatory logic and the k-calculus is concerned 
with the elucidation of the basic notion of functionality: 
how to construct functions, and how to apply functions to 
their arguments. There is a very large body of results in this 
area, of which I will need only a very small part. 
One of the simplest and most elegant accounts of func- 
tionality, originally introduced by Curry and Feys (1968) 
and further elaborated by other authors (Stenlund 1972; 
Lambek 1980; Howard 1980) involves the use of a logical 
calculus to describe the types of valid functional objects. In 
a natural-deduction format (Prawitz 1965), the calculus 
can be simply given by the following two rules: 
a a--"/5 /5 
The first rule states that the result of applying a function 
from objects of type a to objects of type/5 (a function of 
type ,~ ---*/5) to an object of type a is an object of type/5. 
The second rule states that if from an arbitrary object of 
type a it is possible to construct an object of type/5, then 
one has a function from objects of type a to objects of type 
/5. In this rule and all that follow, the parenthesized formula 
at the top indicates the discharge of an assumption intro- 
duced in the derivation of the formula below it. Precise 
definitions of assumption and assumption discharge are 
given below. 
The typing rules can be directly connected to the use of 
the k-calculus to represent functions by restating them as 
follows: 
(x :~)  
u:a  v :a - - . /5  u:/5 
\[app\] . v(u) :/5 \[abs\] : kx.u : a --"/3 
A formula u: a will be called a type assignment, assigning 
the type a to term u. Thus, the two rules above state that if 
u has type a and v has type a --~/5 then v(u) has type/5, and 
if by assuming that x has type a, we can show that u 
(possibly containing x) has type/5, then the function repre- 
sented by kx.u has type a--~/5. In the rest of this paper, the 
term functionality rules will refer to these rules. 
Notation As usual in categorial analyses of natural an- 
guage, types are built from the basic types e for individuals 
and 1: for propositions. In function types, the constructor 
associates to the right. Following this type system (no tuple 
types) expressions will be written in a "curried" notation. 
For example, a binary relation r over individuals will have 
type o ~ e ----- t and its application to arguments x and y 
will be written r(x)(y) .  Since the usual semantic analysis 
has a transitive verb combining first with its object and then 
with its subject, the meaning of sentence such as "John 
loves Mary" will be represented by loves(m)(j). 
For a first example of how the functionality rules may be 
used in semantic interpretation, I will consider the deriva- 
tion in Figure 1 of a simplified meaning for the topicalized 
2 Computational Linguistics Volume 16, Number 1, March 1990 
Fernando C. N. Pereira Categoriai Semantics and Scoping 
John j:..e 
hates hates: e---,e-,t x: e 1 
Mary m: e \[app\] hates(~ e--~t 
\[app! hates(x)(m): t 
\[abs\] Lx.hates(x)(m): e--,t 1 
/ 
\[app\] hates(j)(m): t 
Figure 1 Using the Functionality Rules. 
sentence "John, Mary hates". 3 The derivation is repre- 
sented by a tree in which leaf nodes are labeled by assump- 
tions and nonleaf nodes are labeled by the results of rule 
applications. Several aspects of the overall approach ap- 
pear in this example. Each type assignment in the deriva- 
tion is associated to one phrase whose meaning it repre- 
sents, and is derived by applying the functionality rules to 
type assignments associated with the constituents of the 
phrase. The meanings of words in the sentence nter as 
assumptions in the derivation, which are left undischarged. 
In the figure, type assignments are labeled either by the 
lexical item that led to their introduction as assumptions or
by the name of the rule applied to derive the type assign- 
ment. Superscripts are used to link the result of an applica- 
tion of rule \[abs\] to the assumptions discharged by that 
application. The derivation follows closely the syntax of the 
sentence. Specifically, the assumptions j : e, m : e, and 
hates : e --~ e ~ i correspond to the words "John," "Mary," 
and "hates" in the sentence, and the assumption x :e  
corresponds tothe topicalization trace. 
To make precise what inferences are possible in the 
calculus of functionality, we need a precise notion of deriva- 
tion. It turns out that seemingly small differences in this 
have important consequences a to what type assignments 
can be derived. The following definition is adapted from 
that of Prawitz (1965). A derivation is a tree with each 
node n labeled by a type assignment q~(n) (the conclusion of 
the node) and by a set F(n) of type assignments giving the 
assumptions o f  ~(n). In addition, a derivation D satisfies 
the following conditions: 
1. Each leaf node n has its labeling type assignment as 
single assumption, that is F(n) = {q~(n)}. 
2. Each nonleaf node n corresponds either to an applica- 
tion of \[app\], in which case it has two daughters m and m' 
with (a(m) =- u : a, 4~(m') =- v: a --~ /3, 4~(n) =- v(u)  : 13 
and F(n) = r (m)  U r (m') ,  or to an application of \[abs\], 
in which case n has a single daughter m, and q~(m) ~- u :/3, 
4~(n) =- Xx.u : a ~/3 ,  and r(n)  = F(m) - {x : a}. 
3. No node assumption set contains two assumptions x : a 
and x :/3 for the same variable x. 
If n is the root node of a derivation D, we say that D is a 
derivation of ~b(n) from the assumptions r(n)  and write 
r(n) k ~(n). 
Condition 2 allows empty abstraction, that is, the appli- 
cation of rule \[abs\] to some type assignment u : 13 even if x: 
a is not one of the assumptions ofu :/3. This is necessary for 
the Curry calculus, which describes all typed X-terms, 
including those with vacuous abstraction, such as the poly- 
morphic K combinator Xx.Xy.x : a --~ (/3 --~ a). However, in 
the present work, every abstraction eeds to correspond to 
an actual functional dependency of the interpretation of a 
phrase on the interpretation of one of its constituents. 
Condition 2 can be easily modified to block vacuous abstrac- 
tion by requiring that x : a ~ r (m)  for the application of 
the \[abs\] rule to a derivation ode m. 
Condition 3 is a technical restriction to ensure that a 
given variable is not abstracted more than once. That this 
restriction does not affect the class of well-typed functions 
follows immediately from the observation that any Mterm 
can be a-converted to an equivalent one in which all bound 
variables are distinct. 
The definition of derivation can be generalized to arbi- 
trary rules with n premises and one conclusion by defining a 
rule of inference as a n + 1-place relation on pairs of type 
assignments and assumption sets. For example, elements of 
the \[app\] relation would have the general form ((u : a, 
r l ) ,  iv:  a-~-/3, r2), iv (u)  :/3, F 1 U r2)),  while elements 
of the \[abs\] rule without vacuous abstraction would have 
the form ((u :/3, r ) ,  (kx.u : a--~/3, r - {x:a})) when- 
ever x : a ~ F. This definition should be kept in mind when 
reading the derived rules of inference presented informally 
in the rest of the paper. 
The natural-deduction format we have been using is 
intuitively quite appealing but does not make it easy to 
discriminate among different possible treatments ofassump- 
tions, and their effects on what types are derivable. For this, 
it is better to use a Gentzen-style s quent format in which 
the assumptions for a type assignment are carried explic- 
itly. In a fairly general setting, a sequent r k A is a pair of a 
sequence F of assumptions and a type assignment A, with 
the intuitive meaning that A follows from the assumptions 
I ~. The rules of application and abstraction take then the 
form 
x :a ,  Fku : /3  FFu:a  Akv :a - -~/3  
r k Xx.u : a --* fl r ,  A ~ v(u) : fl 
It is easy to see that, except for the use of sequences rather 
than sets, these two rules correspond irectly to the opera- 
tions of type assignments and assumptions sets described 
under condition 2 above. Furthermore, condition 1 corre- 
sponds in this system to making each sequent A I- A, where 
A is some type assignment, an axiom. Finally, the fact that 
we are interested in assumptions sets rather than assump- 
tion sequences i encoded by the following three structural  
rules (Girard et al 1989): 
r ,  A,  B, A k C 
\[exchange\] : F, B, A, A l- C 
Computational Linguistics Volume 16, Number 1, March 1990 3 
Fernando C. N. Pereira Categorial Semantics and Scoping 
A,A, FF B 
\ [ cont ract ion \ ]  . A, FFB 
FbB 
\[weakening\] : A, F b B 
The exchange rule allows us to ignore assumption order, so 
the collection of assumptions forms a bag rather than a set. 
Adding contraction permits us to ignore the number of 
occurrences of an assumption, that is, the assumption 
collection is treated as a set. Without contraction, no 
variable can have more than one occurrence. Finally, weak- 
ening allows irrelevant elements to be added to the assump- 
tions without changing what follows from them. Without it, 
vacuous abstraction is not possible, since weakening pro- 
vides the only means of introducing a variable in an assump- 
tion without having it also in the conclusion (as axioms 
require). 
Choices of structural rules and other constraints on 
allowed sequents lead to a categorial hierarchy whose 
members are systems with varying semantic powers of 
semantic ombination (Moortgat 1988; van Bentham 1989). 
If we ignore the associated X-expressions and consider only 
the types, the types derivable using the full set of rules are 
exactly the consequences of the three axioms a ---- a, 
~ (3--* a), and (a--* (3--" 3')) --~ ((a--~ 3) --* 
(a--~ y)), which are the polymorphic types of the three 
combinators I, K, and S that generate all the closed typed 
X-calculus terms. Furthermore, if we interpret --~ as impli- 
cation, these theorems are exactly those of the pure implica- 
tional fragment of intuitionistic propositional logic (Curry 
and Feys 1968; Anderson and Belnap Jr. 1975). In con- 
trast, without weakening (vacuous abstraction) we have the 
weaker system of pure relevant implication R ~ (Anderson 
and Belnap 1975). 
3 SEMANTIC COMBINATIONS AND THE 
CURRY CALCULUS 
In one approach to the definition of allowable semantic 
combinations, the possible meanings of a phrase are exactly 
those whose type can be derived by the rules of a semantic 
calculus from axioms giving the types of the lexical items in 
the phrase. However, this is far too liberal in that the 
possible meanings of English phrases do not depend only on 
the types involved but also on the syntactic structure of the 
phrases. A possible way out is to encode the relevant 
syntactic onstraints in a more elaborate and restrictive 
system of types and rules of inference. The prime example 
of a more constrained system is the Lambek calculus 
(Lambek 1958) and its more recent elaborations within 
categorial grammar and semantics (van Benthem 1986a, 
1986b; Hendriks 1987; Moortgat 1988). In particular, 
Hendriks (1987) proposes a system for quantifier aising, 
which however is too restrictive in its coverage to account 
for the phenomena of interest here. 
Instead of trying to construct a type system and type 
rules such that free application of the rules starting from 
appropriate l xical axioms will generate all and only the 
possible meanings of a phrase, I will instead take a more 
conservative route related to Montague grammar and early 
versions of GPSG (Gazdar 1982), and use syntactic analy- 
ses to control semantic derivations. 
First, a set of derived rules will be used in addition to the 
basic rules of application and abstraction. Semantically, 
the derived rules will add no new inferences, ince they will 
merely codify inferences already allowed by the basic rules 
of the calculus of functionality. However, they provide the 
semantic ounterparts ofcertain syntactic rules. 
Second, the use of some semantic rules must be licensed 
by a particular syntactic rule and the premises in the 
antecedent of the semantic rule must correspond in a 
rule-given way to the meanings of the constituents com- 
bined by the syntactic rule. As a simple example using a 
context-free syntax, the syntactic rule S ~ NP VP might 
license the function application rule \[app\] with e the type 
of the meaning of the NP and e ~ t the type of the 
meaning of the VP. 
Third, the domain of types will be enriched with a few 
new type constructors, in addition to the function type 
constructor ---~. From the semantic point of view, these type 
constructors add no new types, but allow a convenient 
encoding of rule applicability constraints motivated by 
syntactic considerations. This enrichment of the formal 
universe of types for syntactic purposes is familiar from 
Montague grammar (Montague 1973), where it is used to 
distirguish different syntactic realizations of the same se- 
mantic type, and from categorial grammar (Lambek 1958; 
Steeclman 1987), where it is used to capture syntactic word 
order constraints. 
Together, the above refinements allow the syntax of 
language to restrict what potential semantic ombinations 
are actually realized. Any derivations will be sound with 
respect o lapp\] and \[abs\], but many derivations allowed 
by these rules will be blocked. 
4 DERIVED RULES 
For the derived rules, we enrich the type system with a 
formal type constructor quant (q), where q is a quantifier, 
that is, a value of type (e ----, t) ---, t, and two type constants 
(nullary constructors) pron for pronoun assumptions and 
trace, for traces in relative clauses. It is important to 
observe that the types resulting from the application of 
these constructors are not to be taken as being subtypes of 
e, and thus the rules involving them should not be seen as 
type subsumption rules. Instead, the new formal type con- 
structors erve to constrain possible derivations in a similar 
way to the directed function type constructors of Lambek 
calc~:lus (Lambek 1958) or the extraction constructor used 
by Moortgat o handle long-distance dependencies (Moort- 
gat 1988). 
Because of their particular nature, the formal type con- 
structors are handled in a special way diverging somewhat 
4 Computational Linguistics Volume 16, Number 1, March 1990 
Fernando C. N. Pereira Categorial Semantics and Seeping 
from the usual structure of natural-deduction proof sys- 
tems. Specifically, each formal type constructor is intro- 
duced as an assumption by appropriate syntactic licensing. 
However, the types resulting from the formal constructors 
do not combine with any other types, so the only way of 
having the associated variables participate in a derivation is 
to apply immediately licensing rules that replace the for- 
mal type by an appropriate semantic type (e in all cases 
considered here). Paired with these rules we have abstrac- 
tion rules that discharge formal type assumptions by ab- 
straction. Nevertheless, we will see that from a derivation 
involving these rules where all the formal type assumptions 
have been discharged, it is straightforward to construct a
derivation in the functionality calculus starting from the 
same lexical assumptions and yielding the same result. 
4.1 TRACE LICENSING AND ABSTRACTION 
The following two rules deal with traces and the meaning of 
relative clauses: 
(x : trace) 
x : t race  r : t 
\ [ t race - l i c \ ]  : \ [ t race -abs \ ]  : 
x :e  hx.r : e--~ t 
Rule \[trace-l ic\] is licensed by the occurrence of a trace in 
the syntax, and rule \[trace-abs\]  by the construction of a 
relative clause from a sentence containing a trace. 4 
Since no rule can derive an expression of type trace, 
expressions of that type can only appear as assumptions. 
Furthermore, no rule except \[trace-lie\] accepts premises of 
that type. Therefore, in a completed erivation any occur- 
rence of an expression of type trace must be a premise of 
\[trace-l ie\] and be later discharged by a use of \ [ t race-abs\ ] .  
That is, use of the trace rules will always lead to derivations 
matching the following schema 
x : trace \] 
x :e  
Consequently, any type assignment derived with the help of 
the trace rules could already have been derived with lapp\] 
and \[abs\] alone, as was claimed in the previous ection. 
Figure 2 shows the application of the trace rules to the 
derivation of an interpretation for the N "car that John 
owns," with the assumption that the relative pronoun "that" 
has type that: (e - -*  t) --* (e--~ t) --- (e - -*  t), that is, a 
function that combines two properties into a property. 
With the further assumption that "that" corresponds in 
this case to property conjunction 
that ~ Xr.Xn.Xx.n(x) /~ r(x), 
the result of the derivation can be reduced to the more 
familiar form 
Xx.car(x) A own(x)(j) 
that is, the property of being a car that John owns. 
4.2 BOUND ANAPHORA LICENSING AND 
ABSTRACTION 
The analysis of bound anaphora brings up a wide range of 
issues in syntax, semantics, and pragmatics, most of which 
I will ignore in this paper. I will assume that possible 
coreferences are determined elsewhere and that the role of 
the bound anaphora rules here is simply to derive the 
appropriate semantic interpretation for phrases involving 
pronouns. Two approaches are possible here. Working with 
the functionality rules alone, a noun phrase will be associ- 
ated to an assumption of the form u : e. The interpretation 
of a pronoun coindexed with that noun phrase will be 
another occurrence of the assumption. When the anteced- 
ent is a trace or a quantified noun phrase (interpretation of
quantified noun phrases is discussed in the next section), 
the assumption will eventually be discharged. The defini- 
tion of derivation in Section 2 ensures that all occurrences 
of u will be bound by the same application of \[abs\]. 
The second approach relies on a pair of derived rules, 
pronoun licensing and abstraction. These rules of course do 
not add new semantic consequences, but facilitate the 
representation of the syntactic licensing of bound ana- 
r : t  
Xx.r : e - - -~  t l 
But this can be mapped irectly into the schematic deriva- 
tion 
x :e  I 
r : t  
Ax.r : e ---* t 1 
y: trace 
I 
owns own: e-->e-~t y: e \[trace-lie\] 
John j :e  own(y):~--~t \[appl 
own(y)O): t \[appl I 
that that:(~--~t)--*(e~t)-~(e~t) ~.y.own(y)(j): e--~t \[trace-ebsl 
car car:~--~t that(~.y.own(y)(j)): (e---~t)~(e~t) \[app\] 
that(~.y.own~)(j))(car): e--~t \[appl 
Figure 2 Using the Trace Rules. 
Computational Linguistics Volume 16, Number 1, March 1990 5 
Fernando C. N. Pereira Categoriai Semantics and Seoping 
phora. The two rules are as follows: 
(x : pron) 
x :pron  s: .a u : f l  
\[pron-lic\] : x:  e \[pron-abs\] : (~x .s ) (u )  : ot 
The pronoun resolution rule \[pron-abs\] applies only when 
u : fl is an undischarged assumption ofs : a such that either 
fl is trace or quant (q) for some quantifier q, or the 
assumption is licensed by some proper noun. 
These rules deal only with the construction of the mean- 
ing of phrases containing bound anaphora. In a more 
detailed grammar, the licensing of both rules would be 
further estricted by linguistic onstraints on coreference-- 
for instance, those usually associated with c-command 
(Reinhart 1983), which seem to need access to syntactic 
information (Williams 1986). In particular, the rules as 
given do not by themselves enforce any constraints on the 
possible antecedents of reflexives. 
The soundness of the rules can be seen by noting that the 
schematic derivation 
x : pron ~ 
x :e  
S:o/ U:~ 
(Xx .s ) (u )  :a  t 
corresponds simply to a schematic derivation involving 
multiple uses of the assumption u : fl 
u:~. . .u :# 
six~u\] : ,~ 
where s \[x/u\] denotes the result of substituting u for every 
free occurrence ofx in s. 
Figure 3 shows a simple derivation involving the pronoun 
rules. The last derivation ode in the figure is the applica- 
tion of \[pron-abs\] to the assumption to be discharged 
x : pron and the antecedent assumption j : e, with result 
(kx.bored (x)( j ) ) ( j )  --- bored (j)( j) .  A more interesting 
case, involving interactions between pronoun and quantifier 
assumptions, occurs in the derivation of Figure 5 for sen- 
tence (2). 
4.3 QUANTIFIER RAISING 
The rules discussed earlier provide some of the auxiliary 
machinery required to illustrate the free-variable con- 
straint. However, the main burden of enforcing the con- 
bored 
John 
himself x:. pron l 
I 
b o r e d ~  e \[pron-lie\] 
j : ~  e--~t \[app\] 
bored(x)(j): t \[app\] 
bored(j)(j): tl \[pron-abs\] 
Figure 3 Using the Pronoun Rules. 
straint falls on the rules responsible for quantifier aising, 
and therefore I will cover in somewhat greater detail the 
derivation of those rules from the basic rules of functional- 
ity. 
I will follow here the standard view (Montague 1973; 
Barwise and Cooper 1981) that the meanings of natural 
language determiners are generalized quantifiers, with 
type (e ---* t) ---, (e ---* t) ~ t. For example, the meaning of 
every would be Xr.ks.Vx.r(x) =~ s(x),  and the meaning of 
the noun phrase every man hs.Vx.man(x)=~ s(x).  To 
interpret the combination of a quantified noun phrase with 
the phrase containing it that forms its scope, we apply the 
meaning of the noun phrase to a property s derived from the 
meaning of the scope. The purpose of devices such as 
quantifying-in Montague grammar, Cooper storage, or 
quantifier raising in transformational grammar is to deter- 
mine a scope for each noun phrase in a sentence. From a 
semantic point of view, the combination of a noun phrase 
with its scope, most directly expressed by Montague's 
quantifying-in rules, s corresponds to the following sche- 
matic derivation in the functionality calculus 
x :e  1 
s : t  
Xx.s :e~t  1 q: (e~t ) - - * t  
6. q(Xx.s) : t 
where the assumption x : e is introduced in the derivation 
at a position corresponding to the occurrence in the sen- 
tence of the noun phrase with meaning q. In Montague 
grammar, this correspondence is nforced by using a notion 
of syntactic ombination that does not respect the syntactic 
structure of sentences with quantified noun phrases. Coo- 
per storage was in part developed to cure this deficiency. 
The following derived rules achieve the same effect: 
6 Computational Linguistics Volume 16, Number 1, March 1990 
Fernando C. N. Pereira Categorial Semantics and Seoping 
\ [quant - l i c \ ]  : 
q: (e~t )~t  x :quant(q)  
x :e  
(x : quant(q)) 
form 
y :a  I 
s : t  
\[quant-abs\] : q(Xx.s)  : t 
Rule \[quant-lic\] is licensed by a quantified noun phrase. 
Rule \[quant-abs\] is not keyed to any particular syntactic 
construction, but instead may be applied whenever its 
premises are satisfied. It is easy to see that any use of 
\[quant-lic\] and \[quant-abs\] in a derivation 
q : (e - -~t )~t  x :quant(q)  2
x :e  
U:fl  1 
q: (e - - - * t )~t  x :quant(q)  l 
x :e  
s : t  
q(Xx.s)  : t 1 
can be justified by translating it into an instance of the 
schematic derivation (6). Furthermore, quantifier assump- 
tions can only arise and be discharged in this way. 
Figure 4 shows the use of the quantification rules in a 
derivation for the preferred reading of the sentence "Every 
guest brought a dish." The other reading could be derived 
in a similar manner. 
Now, the free-variable constraint plays a role in situa- 
tions in which the quantifier itself depends on assumptions 
that must be discharged, and forbids derivations of the 
every guest 
every: (e-->t)-->(e--~t)--~t guest: e~t  
\[appl every(guest): (e-*t)--*t g. quant(every(guest)) 2 
a dish \[quanl-lie\] g: e a: (e-.-~t)---~(e-~t)--4t dish:e--->t 
~ ~ d:quant(a(dish)) t 
~ brought 
X ~ g h t : ~  d:e 
\[app\] brough~ e~t  
I 
\[quant-abs\] a(dish)(7~d.brought(d)(g)):  1 
I 
\[quant-abs\] every(guest)O.g.a(dish)(Xd.brought(d)(g))):  
Figure 4 Using the Quantifier Rules. 
s : t  
q(Xx.s)  : t z 
that is, derivations in which an assumption is discharged 
after assumptions it depends on. But such a derivation 
maps to the following in the functionality calculus: 
x :e  2 
v:-y (a) 
Xy.v : a --~ 71 
u : ~ (b) y : a l  
s : t  
Xx.s  : e ---- t 2 q : (e ---, t) --, t 
q(Xx.s)  :t  
The problem with this derivation is that assumption y : a is 
discharged at (a), but it is not an assumption for the 
premise v : 3' of (a). Even if we allow vacuous abstraction so 
that an assumption y : a can be discharged at that point, 
that discharge will not include the assumption y : a (b) for 
the quantifier q, which will thus be left undischarged. In the 
Gentzen-style rules given in Section 2, step (a) can only 
arise after an application of weakening to introduce y :/3, 
but on the other hand, assumption (b) can only, be elimi- 
nated independently b  abstraction, since the alternative of 
combining it by contraction with the other occurrence of 
y : a is only available after the assumptions for the left and 
right premises of the application of q to its scope. But that is 
too late, because the other occurrence of y: /3 has been 
discharged by then. Therefore, there is no choice but to 
Computational Linguistics Volume 16, Number 1, March 1990 7 
Fernando C. N. Pereira Categorial Semantics and Scoping 
discharge (b) after q is combined with its scope. Put in 
another way, q cannot be raised outside the scope of 
abstraction for the variable y occurring free in q, which is 
exactly what is going on in Example (4) ("An author who 
John has read every book by arrived.") A correct schematic 
derivation is then 
x : e 1 (b) yct 2 
s : t  
Xx.s : e - -~  t I q : (e  -- - ,  t )  - - ,  t 
q(Xx.s) : t 
u:# 
Xy.u : .~  ~ ~ 
The free-variable constraint is reduced to a constraint on 
derivations imposed by the basic theory of functionality, 
dispensing with a logical-form representation f the con- 
straint. Figure 5 shows a derivation for the only possible 
scoping of sentence (2) when every man is selected as the 
antecedent ofhis. To allow for the selected coreference, the 
pronoun assumption must be discharged before the quanti- 
fier assumption (a) for every man. Furthermore, the con- 
straint on dependent assumptions requires that the quanti- 
fier assumption (c) for a fr iend o f  his be discharged before 
the pronoun assumption (b) on which it depends. It then 
follows that assumption (c) will be discharged before as- 
sumption (a), forcing wide scope for every man. 
every man his 
every: (e~t)~(e~t)---~t rnan:e-~t h pron 
friend of 
nt'ever man 3 \[app\] every(man): (e--*t)--*t m: qua t Y( )) f r iend-o f :~h:  e 
a 
\[quant-lic\] m: e a: (e--4t)---~(e~t)--*t \[app\] fi'iend-of(h): e--*t 
~ lapp\] a(friend-of(h)): (e-~t)~t f: quant(a(friend-of(h))) \ 
\[appl saw(/) (re)it 
\[quant-abs\] a(friend-of(h) (Zf.saw(\[)(m)): t1 
I 
\[pron-abs\] a(friend-of(m) )(~.f.saw(f)(m)): t z 
I 
\[quant-abs\] every(man)(km.a(friand-of(m))(~.saw(l)(m))): t 3 
Figure 5 Derivation Involving Anaphora nd 
Quantification. 
5 DISCUSSION 
The approach to semantic interpretation outlined above 
avoids the need for manipulations of logical forms in deriv- 
ing the possible meanings of quantified sentences. It also 
avoids the need for such devices as distinguished variables 
(Gazdar 1982; Cooper 1983) to deal with trace abstraction. 
Instead, specialized versions of the basic rule of functional 
abstraction are used. To my knowledge, the only other 
approaches tothese problems that do not depend on formal 
operations on logical forms are those based on specialized 
logics of type change, usually restrictions of the Curry or 
Lambek systems (van Benthem 1986a; Hendriks 1987; 
Moortgat 1988). In those accounts, a phrase P with mean- 
ing p of type T is considered to have also alternative 
meaning p' of type T', with the corresponding combination 
possibi\]ities, if p': T' follows from p: T in the chosen logic. 
The central problem in this approach is to design a calculus 
that will cover all the actual semantic alternatives (for 
instance, all the possible quantifier scopings) without intro- 
ducing spurious interpretations. For quantifier raising, the 
system of Hendriks eems the most promising so far, but it 
is at present oo restrictive to support raising from noun- 
phrase complements. 
Formal types and derived rules are a rather special- 
purpose mechanism for constraining semantic derivations. 
A more general view, based on a notion of the possible 
relationships between syntactic and semantic algebra is 
desirable here, maybe following from the notion of projec- 
tion proposed for lexical-functional grammar (Halvorsen 
and Kaplan 1988). 
An important question I have finessed here is that of the 
compositionatity of the proposed semantic alculus. It is 
clear that the application of semantic rules is governed only 
by the existence of appropriate syntactic licensing and by 
the availability of premises of the appropriate types. In 
other words, no rule is sensitive to the fo rm of any of the 
meanings appearing in its premises. However, there may be 
some doubt as to the status of the basic abstraction rule and 
those derived from it. After all, the use of X-abstraction i
the consequent of those rules seems to imply the constraint 
that the abstracted object should formally be a variable. 
However, this is only superficially the case. I have used the 
formal operation of X-abstraction to represent functional 
abstraction i this paper, but functional abstraction itself is 
independent of its formal representation in the X-calculus. 
All that is required is a calculus of functional objects in 
which those objects atisfy their usual algebraic properties, 
such as what is provided by X-Prolog (Miller and Nadathur 
1986). For instance, in a X-Prolog realization of the pro- 
posed system, abstractions arising from the \[abs\] rule or its 
derived rule surrogates could be calculated through a com- 
bination of universal quantification i the metalanguage 
(the language in which the proof system is described) and 
higher-order functional equations olved by higher-order 
unification (Felty and Miller 1988). Syntactic manipula- 
8 Computational Linguistics Volume 16, Number 1, March 1990 
Fernando C. N. Pereira Categorial Semantics and Scoping 
tion of object-level variables and binders would be neither 
necessary nor possible. 
The investigation reported in this paper was motivated 
by the use of the free-variable constraint in an earl ier 
system of semantic- interpretat ion rules (Pollack and Pereira 
1988; Pereira and Pollack in press). Those rules operate on 
objects formally analogous to sequents, with assumptions 
for quantif ied noun phrases and pronouns as well as for 
some other purposes. It would be worth seeing to what 
extent those formal operations on sequent-l ike objects can 
be mapped onto the sequent rules for some version of the 
functional ity calculus. 
Verb-phrase llipsis and gapping constructions provide 
another possible area of application for the kind of catego- 
rial semantics ketched in this paper. A semantic account 
of those constructions requires the extraction of the mean-  
ing of elided material  from the meaning of a source clause. 
Intermediate results of appropriate type in derivations of 
the meaning of the source clause may provide the possible 
meanings of the elided material.  In other words, possible 
antecedent meanings would be obtained by semantic reanal- 
ysis of the source clause, where a semantic reanalysis of the 
source clause is just an alternative categorial derivation of 
the source clause's meaning.  Init ial  results along these lines 
will be reported elsewhere (Dalrymple t al. 1990). 
ACKNOWLEDGMENTS 
The work described here was carried out in part at SRI International and 
supported by a contract with the Nippon Telephone and Telegraph 
Corporation and a gift from the Systems Development Foundation as part 
of a coordinated research effort with the Center for the Study of Language 
and Information, Stanford University, Stanford, CA. Mary Dalrymple, 
David Israel, Aravind Joshi, Dale Miller, Martha Pollack, and Stuart 
Shieber made useful suggestions and comments. This paper is a revised 
and expanded version of "A Calculus for Semantic Composition and 
Scoping" presented at the 1989 meeting of the Association for Computa- 
tional Linguistics (Pereira 1989). 
REFERENCES 
Anderson, A. R. and Belnap, Jr., N. D. 1975 Entailment: The Logic of 
Relevance and Necessity, Volume I. Princeton University Press, Prince- 
ton, NJ. 
Alshawi, H.; Carter, D. M.; van Eijck, J.; Moore, R. C.; Moran, D. B.; 
Pereira, F. C. N.; Pulman, S. G.; and Smith, A. G. 1989 "Research 
Programme in Natural Language Processing: Final Report." Technical 
report, Cambridge Research Centre, SRI International, Cambridge, 
U.K. 
Barwise, J. and Cooper, R. 1981 "Generalized Quantifiers and Natural 
Language." Linguistics and Philosophy, 4:159-219. 
Curry, H. B. and Feys, R. 1968 Combinatory Logic, Volume L North- 
Holland, Amsterdam, Netherlands. 
Cooper, R. 1983 Quantification and Syntactic Theory. D. Reidel, 
Dordrecht, Netherlands. 
Dalrymple, M.; Shieber, S. M.; and Pereira, F. C. N. 1990 "Ellipsis and 
Higher-Order Unification," Unpublished paper, 1990. 
Dowty, D. R.; Wall, R. E.; and Peters, S. 1981 "Introduction to Montague 
Semantics," Volume 11 of Synthese Language Library. D. Reidel, 
Dordrecht, Netherlands. 
Felty, A. and Miller, D. 1988 Specifying Theorem Provers in a Higher- 
Order Logic Programming Language. Technical Report MS-CIS-88- 
12, Department of Computer and Information Science, University of 
Pennsylvania, Philadelphia, PA. 
Gazdar, G. 1982 "Phrase Structure Grammar," In P. Jacobson and G. K. 
Pullum (eds.), The Nature of Syntactic Representation, D. Reidel, 
Dordrecht, Netherlands, 131-186. 
Girard, J.-Y.; Lafont, Y.; and Taylor, P. 1989 Proofs and Types, Volume 
7 of Cambridge Tracts in Theoretical Computer Science. Cambridge 
University Press, Cambridge, U.K. 
Helm, I. R. 1982 The Semantics ofDefinite and Indefinite Noun Phrases. 
Ph.D. Thesis, Department of Linguistics, University of Massachusetts, 
Amherst, MA. 
Hendriks, H. 1987 "Type Change in Semantics: The Scope of Quantifica- 
tion and Coordination," In E. Klein and J. van Benthem (eds.), Catego- 
ries, Polymorphism and Unification, Centre for Cognitive Science, 
University of Edinburgh, Edinburgh, U.K., 95-120. 
Halvorsen, P.-K. and Kaplan, R. M. 1988 "Projections and Semantic 
Description in Lexical-Functional Grammar," In Proceedings of the 
International Conference on Fifth Generation Computer Systems, 
Tokyo, Japan, 1116-1122. 
Howard, W. A. 1980 The Formulae-As-Types Notion of Construction," 
In J. P. Seldin and J. R. Hindley (eds.), To H. B. Curry: Essays on 
Combinatory Logic, Lambda Calculus and Formalism, Academic 
Press, London, 479-490. 
Hobbs, J. R. and Shieber, S. M. 1987 "An Algorithm for Generating 
Quantifier Scopings." Computational Linguistics, 13:47-63. 
Lambek, J. 1958 "The Mathematics of Sentence Structure." American 
Mathematical Monthly, 65:154-170. 
Lambek, J. 1980 "From X-Calculus to Cartesian Closed Categories," In 
J. P. Seldin and J. R. Hindley (eds.), To H. B. Curry: Essays on 
Combinatory Logic, Lambda Calculus and Formalism, Academic 
Press, London, 375-402. 
May, R. 1985 Logical Form: Its Structure and Derivation, Volume 12 of 
Linguistic Inquiry Monographs. MIT Press, Cambridge, MA. 
Miller, D. A. and Nadathur, G. 1986 "Higher-Order Logic Programming," 
In E. Shapiro (ed.), Third International Conference on Logic Program- 
ming, Springer-Verlag, Berlin. 
Montague, R. 1973 "The Proper Treatment ofQuantification i Ordinary 
English," In R. H. Thomason (ed.), Formal Philosophy. Yale Univer- 
sity Press, New Haven, CT. 
Moortgat, M. 1988 Categorial Investigations: Logical and Linguistic 
Aspects of the Lambek Calculus. Ph.D. Thesis, University of Amster- 
dam, Amsterdam, Netherlands. 
Moran, D. B. 1988 "Quantifier Scoping in the SRI Core Language 
Engine," Proceedings ofthe 26th Annual Meeting of the Association 
for Computational Linguistics, 33-47. 
Partee, B. and Bach, E. 1984 "Quantification, Pronouns and VP 
Anaphora," In J. A. G. Groenendijk, T. M. V. Janssen, and M. B. J. 
Stokhof (eds.), Truth, Interpretation a d Information, Foris, Dordrecht, 
Netherlands, 99-130. 
Pereira, F. C. N. 1989 "A Calculus for Semantic Composition and 
Scoping," Proceedings ofthe 27th Annual Meeting of the Association 
for Computational Linguistics, 152-160. 
Pollack, M. E. and Pereira, F. C. N. 1988 "An Integrated Framework for 
Semantic and Pragmatic Interpretation," Proceedings of the 26th 
Annual Meeting of the Association for Computational Linguistics, 
75-86. 
Pereira, F. C. N. and Pollack, M. E. "Incremental Interpretation," 
Artificial Intelligence, in press. 
Prawitz, D. 1965 Natural DeductiorL" A Proof-Theoretical Study. Almqvist 
and Wiksell, Uppsala, Sweden. 
Reinhart, T. 1983 Anaphora nd Semantic Interpretation. Croom Helm, 
London. 
Roberts, C. 1987 Modal Subordination, Anaphora nd Distributivity. 
Ph.D. Thesis, Department of Linguistics, University of Massachusetts, 
Amherst, MA. 
Stenlund, S. 1972 Combinators, h-Terms and Proof Theory. D. Reidcl, 
Dordrecht, Netherlands. 
Computational Linguistics Volume 16, Number 1, March 1990 9 
Fernando C. N. Pereira Categorial Semantics and Scoping 
Steedman, M. 1987 "Combinatory Grammars and Parasitic Gaps." 
Natural Language and Linguistic Theory, 5(3):403-439. 
Vanlchn, K. A. 1978 Determining the Scope of English Quantifiers. M.S. 
thesis, Massachusetts Institute of Technology, Cambridge, MA. 
van Benthem, J. 1986a "Categorial Grammar and Lambda Calculus," In 
D. Skordev (ed.), Mathematical Logic and its Application, Plenum 
Press, New York, 39-60. 
van Benthem, J. 1986b "Essays in Logical Semantics," Volume 29 of 
Studies in Linguistics and Philosophy. D. Reidel, Dordrecht, Nether- 
lands. 
van Bcnthem, J. 1989 "Categoriat Grammar and Type Theory." Journal 
of Philosophical Logic, In press, 1990. 
van Eijck, J. 1985 Aspects of Quantification i  Natural Language. Ph.D. 
Thesis, University of Groningen, Groningen, Netherlands. 
van Riemsdijk, H. and Williams, E. 1986 Introduction tothe Theory of 
Grammar, Volume 12 of Current Studies in Linguistics. MIT Press, 
Cambridge, MA. 
Williams, E. 1986 "A Reassignment of the Functions of LF." Linguistic 
Inquiry, 17(2):265-299. 
NOTES 
1. In all the examples that follow, the pronoun and its intended anteced- 
ent are italicized. As usual, starred examples are supposed to be 
ungrammatical. 
2. In fact, this is a perfectly good open well-formed formula and 
therefore the precise formulation of the constraint is more delicate 
than seems to be realized in the literature. 
3. This particular example and its analysis were chosen just as the 
shortest plausible example requiring both application and abstrac- 
tion, not as making substantive linguistic or semantic claims. 
4. These rules are quite similar to the extraction i troduction rule of 
Mcortgat (1988). 
5. In :general, quantifying-in has to apply not only to proposition-type 
scopes but also to property-type scopes (meanings of common oun 
phrases and verb phrases). Extending the argument that follows to 
those cases offers no difficulties. 
10 Computational Linguistics Volume 16, Number 1, March 1990 
