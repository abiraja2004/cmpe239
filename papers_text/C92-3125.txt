A Logic Programming View of Relational Morphology 
Harvey Abramson 
Institute of Industrial Science, Univers i ty of  Tokyo 
Minato-ku,  Roppongi  7-22-1, Tokyo  106, Japan 
e-mail:  harvey@ godzi l la. i is.u-tokyo.ac. jp 
Abst rac t  
We use the more abstract term "relational morphology" 
in place of tile usual "two-level morphology" in order to 
emphasize an aspect of Koskenniemi's work which has 
been overlooked in favor of implementation issues using 
the finite state paradigm, namely, that a mathematical 
relation can be specified between the lexical and surface 
levels of a language. Relations, whether finite state or 
not, can be computed using any of several paradigms, 
and we present a logical reading of a notation for 
relational morphological rules (similar to that of 
Koskenniemi's) which can in fact be used to 
automatically generate Prolog program clauses. Like die 
finite state implementations, the relation can be 
computed in either direction, either from the surface to 
the lexieal evel, or vice versa. At rite very least, this 
provides amorphological complement tologic grammars 
which deal mainly with syntax and semantics, in a 
programming environment which is more user-friendly 
than the finite state programming paradigm. The 
morphological rules often compile simply into 
unification of the arguments in the generated 
morphology predicate followed by a recursive call of the 
said predicate. Further speed can be obtained when a 
Prolog compiler, rather than an interpreter, is used for 
execution. 
Introduction. Kimmo Koskenniemi's so called "two- 
level model" of computational morphology (1983) in 
which phonological rules are implemented asfinite state 
transducers has been the subject of a great deal of 
attention. The two-level model is based partly on earlier 
work of Johnson (1972), who considered that a set of 
"simultaneous" phonological rules could be represented by
such a transducer, and of Kaplan and Kay (1983) who 
thought that ordered generative rules could be implemented 
as a cascading sequence of such transducers. Koskenniemi 
in fact implemented the phonological rules by a set of 
finite state tranducers unning in parallel, rather than by a 
single large finite state machine into which many 
cascading machines could be combined. Subsequent to 
Koskenniemi's original work, there was a LISP-based 
implementation called KIMMO (Kartunnen 1983), and 
two-level descriptions of English, Rumanian, French and 
Japanese (Kartunnen and Wittenburg, Khan, Lun, Sasaki 
Alam 1983). A later LISP based implementation by 
Dalrymple t al (1987) called DKIMMO/TWOL helped 
the user by converting two-level rules into finite state 
transducers: in earlier implementations, and in the recent 
PC-KIMMO system (Antworth 1990), it was the user's 
task to generate the machine, s from two-level descriptions. 
However one very important contribution ofKoskeaniemi 
to morphology, namely the notion that there is a relation 
between the surface and lexical "levels", has been 
somewhat overlooked by implementation issues having to 
do with the couversion of two-level rules into fiuite state 
automata in the various KIMMO systems. The two-level 
rules according to this notion, unlike the rules of 
generative morphology which transform representations 
from one level to representations i  the other, express a
correspondence between lexical and surface levels. 
Furthermore since no directionality is implied ill the 
definition of a relation, unlike geuerative rules, the same 
set of two-level rules applies both in going from surface 
to lexieal levels and vice versa. Rather than being 
procethtral rules, they are declarative. Consequently, any 
correct implementation of the two-level rules is a 
relational program which can be used either analytically or
generatively. We will henceforth, in order to emphasize 
the fact that a relation is being defined by them, refer to 
relational morphology rules rather than to the 
mathematically neutral term "two-level rules". 
Despite the recognition that relational morphology rules 
are declarative, the main emphasis n using them has been 
obscured by the original finite state implementation 
technique. Recently, Bear (1986) has interpreted such rules 
directly, using Prolog as an implementation language. 
This, although an improvement on finite state 
implementations from the point of view of debugging and 
clarity, still misses an important aspect of relational 
morphology rules as a declarative notation, namely that if 
relational morphology rules define a relation between 
surface and lexieal levels, then that relation can be 
specified and implemented using any of several different 
relational programming paradigms. In this paper, we will 
show that logic programming, which can be viewed as a 
relational programming paradigm, can be used to give a 
declarative reading to morphological rules. Further, 
because of the execution model for logic programs, 
embodied in various logic programming languages such as 
Prolog, the declarative reading also has a convenient 
procedural reading. That is, each relational morphological 
rule may be thought of as corresponding to or generating a 
logic program clause. The entire set of logic program 
clauses generated from the relational morphological rules, 
coupled with some utility predicates, then constitutes a 
morphological nalyser which can either be used as a stand 
alone program or which can be coupled as a module to 
other linguistic tools to build a natural language 
processing system. Since the roles have been transformed 
into logic program clauses, they gain in speed of 
execution over Bear's interpretive method, and further 
speed can be gained by compiling these clauses using 
existing Prolog compilers. At the very least, this provides 
a morphological complement o logic grammars 
(Abramson and Dahl 1989) which deal mainly with syntax 
and semantics, in a programming environment which we 
believe is more user-friendly than the finite state 
programming paradigm. 
It may be argued that this is a step backwards from the 
linear efficiency of finite state processing. However, when 
ACRES DE COLING-92, N^NTES, 23-28 ^ o(rr 1992 8 5 0 PRoc. ov COI.ING-92, NANTES, AUG. 23-28, 1992 
discussing "efficiency" it is very important to be very 
precise as to where the efficiency lies and what it consists 
of. Finite state processing is linear in the sense that a 
properly implemented finite state machine will be able to 
decide whether a string of length ,~ is acceptable or not in 
a time which is O(n), ie, for large enough n, a linear 
multiple of n. For small values of u, depending on how 
much bookkeeping has to be done, "finite state 
algorithms" may perform worse titan algorithms which are 
formally O(n 2) or higher. Any processing in addition to 
recognition may involve time factors which are more than 
linear. This entirely leaves aside the question of the user- 
friendliness of the finite state computing paradigm, a
question of how "efficient" in human terms it is to use 
finite state methods. Anyone who has trieM to implement 
finite state automata of substantial size directly (as in 
Koskenniemi's original implementation, the first KIMMO 
systems, and KIMMO-PC) will have realised that 
programming finite state machines i  distastefully akin to 
directly programming Turing machines. A substantial 
amount of software is necessary iu order to provide a 
development, debugging and maintenance environment for 
ea~y use of the finite state computing paradigm. There 
also remains the theoretical question as to the 'adequacy of 
finite state morphological descriptions for all, or even 
most, human languages. However, this is a topic we shall 
not venture into in this paper. 
In our method, a relatively small Prolog program 
generates logic programming clauses from relational 
morphology rules. The generated clauses (at least in the 
experiments sofar) are readable and it is easy to correlate 
the generated clause and the original morphological rule, 
thus promoting debugging. The standard ebugging tools 
of Prolog systems (at the very least, sophisticated tracing 
facilities) seem sufficient to deal with rule debugging, and 
the readability of the generated clauses hould help in the 
maintenance and transference of morphological programs. 
Thus, from the software ngineering point of view, logic 
progrannming is a more sophisticated, higher-level 
programming paradigm than finite state methods. Also, 
should finite state descriptions in the end prove inadequate, 
or even inconvenient, for all of morphology, logic 
programming provides expressive power for reasonable 
extension of the notation of relational morphology rules. 
The current availability of Prolog compilers, even for 
small machines, provides another increment of speedy 
execution of the generated programs. Many of the 
morphological rules produce logic program clauses in 
which checking of the lexical and surface elements and 
contexts reduce to unification followed by a recursive call 
of the morphology predicate. Compiled Prolog abstract 
machine code for such clauses is usually very compact. 
Prolog compiler indexing mechanisms often make it 
possible to access the correct clause to be applied in 
constant time. 
Notational Aspects. Our tableau notation for 
relational morphology rules is as follows: 
LexLeft <= Lex => LexRight <:> 
SarfaccLeft <= Surface => SurfaceRight 
which expresses the relation between a lexical and a 
surface uait (Lex aml Surface, respectively), provided that 
the left and right contexts at both the lexical and surface 
levels (LexLeft, LexRiglnt, SurfaceLeft, and 
SuffaceRight) are satisfied. 
Another kind of relational morphology rule which is 
allowed is: 
LexLeft => Lex <= LexRight<:> 
SurfaceLeft => Surface <= SurfaceRight. 
which expresses a relationship between Lex and Surface 
providing that the left and fight contexts at the lexical 
and surface levels are different from those specified by 
LexLeft, LexRight, SuffaceLeft, and SurfaceRight. This 
means that either LexLefl or LexRight is not satisfied, 
and also that either SurfaceLeft or SurfaceRight is not 
satisfied. 
More coutpact notation is also accepted, for example: 
LexLeft:SurfaceLeft 
<=Lex:Surface=> 
LexRight:SurfaceRight. 
LexLeft:SurfaceLeft 
=>Lex:Sarface<= 
LexRight:SurfaceRight. 
In the case where a pair of lexical and surface contexts are 
identical, or if the lexical and surface elements are 
identical, they need not be repeated. Such compressed 
rules as the following are also allowed: 
Left <= Element => Right. 
Left => Element <= Right. 
Sets of symbols may be specified: set(vowel,\[a,e,i,o,u\]). 
Lexical entries may be specified as follows: 
lexicon:: {eat=noun,root= craps}. 
lexicon::{cat=noun,root= pimlo}. 
This feature notation is that used in the author's Definite 
Feature Grammars (Abramson 1991). 
Logical reading of relational morphology 
roles. Corresponding to a set of relational morphology 
rules, a binary predicate morphology/2 specifies the 
relation between a lexical and a surface stream of 
characters: 
morphology(LexStrcam,S ufface Strcarn). 
In order to specify the logic program clause which 
corresponds toa relational morphology rule, we have to 
manipulate he left and right lexical and surface contexts. 
We can find the right contexts within LexStream and 
SurfaceStream, but we have to provide a specification of
the left contexts, and we do this by defining the above 
binary predicate morphology/2 in terms of a quaternary 
predicate morphology/4: 
morphology(LexS tmanLSurfaceS tream, 
LeftLexStream,I.,eftS ur faceStream). 
ACn'ES DE COIJNG-92, NArcri;s, 23-28 Aofzr 1902 1~ 5 1 P~toc. oF COLING-92. NANTES, A~JG. 23-28, 1992 
LeftLexStream and LeftSurfaceStrcam re initially empty 
and are represented as reverse order lists of the left 
contexts which have aheady been seen. The top level 
definition of morphology/2 is: 
morphology(LexS tremn,Sur faceSt~un) :- 
raorphology(LexStream,SurfaceSu'emn,I I,\[1). 
The fundamental logic program chmse co~reslxmding toa 
relational morphology rule sneh am 
LexLeft <= Lex => LexRight<:> 
SurfaceLeft <= Surface => SurfaceRight. 
is 
morphology(LexS "tman~,S urfaceS tremn, 
LeftLexStream,l.~efiSl~'aceS "Imam) :- 
LexStream =lLllLexRest\]. 
SurfaceStream = \[SllSurfaceRestl, 
\[exeme(Lex,L1), surface(Surface,S 1), 
lex context (LexLefl,Le fd.exStre,'un ,LexRight,LexRest), 
sur face eontext(Sur faceLeft.lmftSurfaceStmam, 
S ur f~eRight,Sur fhceRest), 
NewLeftLexStreaan = \[Llll~eftLexStream\], 
NewLeftS urfaceS "tmanl = \[S 111.eftS uriaceStream\], 
morphology(LexRest,SurfaceRest, 
NewLeftLexSlaeatm ,Newl.etiS urface? hean 0. 
Here, LexStream and SurfaceStreanl are analysed as 
consisting of the first characters LI and SI, and the 
remaining streams, LexRest and SurfaceRest. It is 
verified that L1 is the lexeme specified by Lcx, and S1 
the surface character specified by Surface. (Lex, Surface, 
LexLeft, LexRight, SurfimeLeft, and SurfaceRight are as 
given iu rite morphology rule.) Contexts are checked by 
the subgoals lex_context and surface context. New left 
context streams are created by prefacing the old left 
context streams with LI ,and S1 (note again that the left 
context streams are built np in reverse order). Finally, 
the predicate morphology/4 is recursively called on the 
remainder of the lexical and surface streams, and with llu~ 
new left context streams. 
Although the logical reading of this appears to involve 
many subgoals, in fact tbr many relational morphology 
rules, the subgoals are compiled away into simple 
unifications. See the Appendix which contains at .set of 
relational morphology rules dealing with simple English 
plural forms and their corresponding logic program 
clauses. Space does not permit us to comnlent on file 
example, or how the compiler works, but the interested 
reader may contact he auttmr. Further papers will deal 
with these topics. 
Conclusions and future research. We have 
provided here in the setting of logic programming a 
morphological complement to the logic grammars which 
mostly concentrate on syntax and semantics. However, 
we have also provided anotation and a logical reading of 
that notation which suggests fi~rther exploration as to 
expressiveness and efficiency. If the context in a 
relational rule is specified by a regular expressimt, the 
appropriate context stream is parsed using a small logic 
grammar which defines such expressions. It may 
however make sen~, in approaching non-concatenative 
aspects of morphology, to be able to specify lexical 
contexts with more stnmtt~re thml regular expressions 
allow. The implementation would be easy: in place of 
the logic grammar used to parse regular expressions, a 
more complicated logic grammar (context free, at least) 
would be used for lexical context verification. It is also 
thought that metarnles (see Abramson 1988 or 
Abramson and Dahl 1989) will be u~ful in dealing with 
nonconeatenative aspects of morphology. Since the 
project is at an early stage, there is not yet an extonsive 
set of examples. We expect o develop a full set of rules 
for English morphology, and it specification of Japanese 
verb forms. 
Ackunwledgment.The author wishes to acknowledge 
the support of Ricoh Corporation as a Visiting 
Information Fusion Professor at the University of 
Tokyo's Institute of Industrial Science. The author "also 
wishes to thank Prof. Akira Ishikawa of Sophia 
University, Tokyo, for comments on this work. Also, 
thanks to Profs. lshizuka and Ishikawa for help in 
translating the abstract. 
References .  
Abramsou, tl. 1988. Metarules and an approach to 
conjunctiou in Definite Clause Translation Grammars. 
Proceedings of the Fifth International Conlerence and 
Symposium on Logic Programming. Kowalski, R,A. & 
Bowen, K.A. (editors), MIT Press, pp. 233-248, 1988. 
Abramson, H. 1991. Definite Feature Grammars for 
Natural and Formal Languages: An Introduction to the 
Formalism. Natural Language Understanding and Logic 
Programming, III, edited by C.G. Browu and G. Koch, 
North-I olland, 1991. 
Abranlson, H. and Dahl, V. 1989. Logic Grammars, 
Symbolic Computation Series, Springer-Verlag. 
Antworth, iLL. 199(I. PC-KIMMO: A two-level 
processor for morphological nalysis. Summer Institute 
of Linguistics, Dallas, Texas. 
Bear, J. 1986. A morphological recognizer with syntactic 
and phonological rules. In Proceedings of COLING '86, 
272-276. Association for Computational Liuguistics. 
Dalrymple, M. et al 1987. DKIMMO,cTWOL: a 
development environment lor morphological nalysis. 
Stanford, CA: Xerox PARC and CSLL 
Johnson, C.D. 1972. Formal aspects of phonological 
description. The \[\[ague: Mouton. 
Kaplan, R.M. and Kay, M. 1981. Phonological rules and 
finite state transdt, cers. Paper presented at the 1981 
Winter meeting of the ACL/USA. 
Kartmman, L. 1983. KIMMO: a general morphological 
processor. Texas Linguistic Formn 22:163 - 186. 
Kartammn, L. and Wittenburg, K. 1983. A twoqevel 
morphological nalysis of English. Texas Linguistics 
Forum 22:217-228. 
ACRES DE COLING-92, NANt'ES, 23-28 AOI\]: 1992 8 S 2 1';~.O{:. OI, COI,ING-92, NANI'ES, AUG. 23-28, 1992 
Khan, R. 1983. A two-level morphological analysis of 
Rumanian. Texas Linguistics Forum 22:253+270. 
Koskenuiemi,  K. 1983. Two- level  morphology:  a 
general computational model for wordqbun recognition 
and production. Publication No.  11 Helsiuki: University 
of Helsinki Department of General Linguistics. 
Lun, S. 1983. A two-level morphological  analysis of 
French. Texas Linguistics Forum 22:271-278. 
Sasaki Alum,  Y. 1983.  A two-level molphologica l  
analysis of  Japanese. Texas Linguistics Forum 22:229- 
252. 
Append ix .  E lementary formation of  plttrals in 
English. 
(0) x <= '+' => \[s,'#'l <:> 
x <= e => \[s,'#'\]+ 
(1) z <= '+' => \[s,'#'l <:> 
z <= e => \[s,'#'l. 
(2) y <= '+' => \[s,'#'l < :> 
i <= e => Is,'#'\]. 
(3) s <= '+' => \[s,'#'l <:> 
s <= e => \[s,'#'\], 
(4) o <= '+' => \[s,'#'l <:> 
o <= e => \[s,'#'\]. 
(5) \[c,h\]  <= '+' => \[s,'#'l <:> 
\[c,h\] <= e => Is,'#'l. 
(6) Is,hi <= '+' => 
Is,'#'\] <:> 
Is,h\] <= e => Is,'#'\]. 
(7) <= y => '+' <:> 
in(con) <--- i =>.  
(8) not(set(\[\[c,h\],s,\[s,hl,x,z,yl)) <~: '+' ~:> Is,'#'l 
<7> 
not(set(\[\[c,h,e\],Is,eJ,\[s,h,el,lx,e I \[z,el,\[i,e\] 1)) 
<= 0 => Is,'#'\]. 
%Note negative context here, 
(9) set(\[\[c,hl,s,\[s,h\],x,z,y\]) => e <= \[s,'#'l <:> 
set(\[\[c,h\],s,\[s,h\],x,z,il) =.- c <~ \[s,'#'l. 
%This is a default ale. 
(10) ._ <= iu(X,char_ e) => _ <:> 
_ <= in(X,char e) => . 
set(char e,\[a,b,c,d,f,g,h,i,j ,k,l ,m, 
u,o,p,q,r,s,t,u,v,w,x,y,z,'#' I). 
set(con,\[b,c,d,f,g,h,j,k,l,m,u,p,q,r,s,t,v,w,x,y,zl), 
In addition to specifying characters such as s, x, etc., we 
can also del iue ~qnences  of  characters noted aS lists 
Is,h\], not(characte0, uot(sequeuce ol characters), in(con) 
means any member of the ~t  con, whereas iu(X,char c) 
is a member of  the set char e ~ssigncd to the variable X 
for unification in another part of the talc. '+' is used as a 
mnrphenle lamm 'lary, 0 is used as the null symbol, '#' is 
used as an eadm~ker ,  and ' '  is used to specify a don't 
care context. By providing a complete specification of  
context we cnnld remove any consideration of  ordering of  
the rides, l Iowever, it is convenient o depart slightly 
l'i~m ~m order free formalism by al lowing default rules 
such as our last one with don't care contexts which 
SlW.cify what happens to syuubols not dealt with in any 
of the atore-menlioned rules, to appear at the end. 
(*) moqfl|ology(\[l,  \[1, A, B). 
(0) 
morphology(\[+, s, #\[A\], \[e, s, #1B\], \[xlC\], \[xlD\]) :- 
morphology(Is, #1AI, Is, #1B\], \[+, xlC\], \[e, xlD\]). 
(1) 
monf~hology(\[+, s, #1A\], \[e, s, #1B\], \[zlC\], \[zlD\]) :- 
morphology(Is, #1A\], Is, #1B\], \[+, zlCI, \[e, zlD\]). 
(2) 
ntorphology(\[+, s, #1A\], It, s, #1B\], \[ylC\], \[ilD\]) :- 
mnq>hology(\[s, #IA\], Is, #1B\], I+, ylC\], \[e, ilD\]). 
(3) 
morphology(l+, s #1AI, It, s, #\[B\], Isle\], \[slD1) :- 
men phology(Is, #1AI, Is, #1B\], \[~, slCI, \[e, slD\]). 
(4) 
moq>hology(l+, s, #1A\], \[e, s, #1B\], \[olC\], \[oiD\]) :-
moq~hology(I s, #1AI, Is, #1BI, \[+, olC.1, \[e, olD\]). 
(5) 
nlorphology(l+, s #1A\], \[e, s, #1B\], \[h, clC\], \[h, clD\]) :- 
movpholngy(\[s, #1AI, Is, #1BI, 
\[+, h, clC\], \[e, h, clD\]). 
(~,) 
moq)hology(l+, s #\[AI, le, s, #1B\], \[h, siC1, \[h, slD\]) :- 
utorphology(\[s, #1A.I, \[s, #Ill/, 
\[ ~-, h. sIC\], \[e, h, slD\]). 
(7) 
morphology(\[y, +IA\], lilB\], C, IDLE\]) :- 
con(D),morphulogy(\[+lA\], B, lylC\], \[i, DIE\]). 
(8) 
mcnphology(\[-t., s, #IA\], Is, #IB\], C, 1)) :- 
not subslxings(C, \[\[h, el, s, \[h, s\], x, z, y\]), 
not substrings(D, lie, h, e\], le, s\], \[e, h, s\], \[e, xl, 
\[e, zl, It, ill), 
morphoh~gy(\[s, IliA\], Is, #1BI, I+IC\], D). 
(9) 
moqfl~ology(\[e, A, BIC\], \[e, D, Ell;I, G, |1) :- 
not (subsUiugs(G, \[o, Ih, el, s, \[h, si, x, z, y\]), 
match(Is, #1, IA, BI)), 
uot (substrings(H, \[u, lh, el, s, \[h, sl, x, z, i\]), 
umteh(\[s, #\], ID, El)), 
moq)hology(\[A, BIC\], \[D, ELF\], \[elG1, \[elHl). 
(10) 
moqfltology(\[AIBI, \[AICI, f), E) :- 
char c(A), 
utorpholngy(B, C, IAIDJ, \[AIE\]). 
Clause (*) is generated to termiuate morphological  
l)ft~cssing whcu bofll tile \[exical and surface streams ~Ue 
empty. In this case, tile left contexts are ignored. 
Chmses 0-6 cotrcslx)ndiug to rules 0-6 follow the same 
pattern in which lcxicat and sud~lcc syml~Jls and contexts 
are specified within tile streams and m'e checked by 
unif icat ion, fol lowed by a recursive call to the 
moqfliology/4 predicate on file remainder of tile lexical 
illl(l surface stfcums and wiflt new left context streams. 
S/IC\[I clauses involving ani l icatiou ol  the head attd a 
AcrEs DE COl,ING-92, NANI~S, 23 28 Aoi)r 1992 8 S 3 l'l?oc:. O|; COl,IN(;-92. NANIES, A/JC+. 23-28, 1992 
body which is only a recursive call of the same predicate 
are efficiently handled by Prolog compilers. Clause 7 is 
similar except hat it also involves a check to see that 
the first character in the left surface context is a 
consonant. 
Set definitions uch as: 
set(con,\[b,c,d,f,g,h j k l,m ,n,p,q,r,s,t,v,w,x,y,zl). 
generat~ unit clauses: con(b)., con(c) ...... con(z). 
In clause 7, if D in con(D) is instantiated (as it is since 
the D represents a left context which has already been 
seen), code generated for this by Prolog compilers 
amounts to something like an indexed table lookup 
which takes place in constant ime. Similar remarks 
apply to clause 10 where it is checked that A is a 
member of the set char e. 
Clause 8 involves a combination of a unification check 
for the right context, and a check that the left context 
does not consist of any of the specified strings. Here, in 
order for the morphology clauses to work in both the 
analytical and generating directions, the negution must be 
logically safe notation, i.e., the arguments to the 
negation must be grounded. Logically safe negation 
involves the use of delaying evaluation of the negation 
until all arguments have been grounded. 
Clause 9 which involves a negative context, makes ure, 
using safe negation, that either the right context is not 
\[s,'#'\] or that the left context does not match any of the 
subslxings in the specified set. 
Sample execution: 
?- morphology(P,cries). 
Root = cry %nonstandard plural formation 
{cat=noun, %original lexicon entry 
root=cry ) 
Suffix = s 
(cat=norm, %modified feature 
root=cry, 
plural=yes} 
P = cry+s ; %another solution? 
fail. %no. 
?- morphology('fox+s',P). 
P = foxes 
?- morphology('piano+ s',P). 
P = pianoes; %one plural form for some nouns 
%which end in "o" 
P = pianos; %another plural form 
fail. %no others 
The same clauses for the predicates morphology/2 and 
morphology/4 are used in solving goals in both 
directions. 
Japanese Summary .  
~," h, 6 og fL-.)i 
KoskemtiemiO96J\[~ {,:-  5 ~ L~,~'~ ? ~  t/.,-tOP 
5o }J~4, l~t (Koskenniemi~9~o09~L~Jf :)  I~/t~-~ 
Harvey Abramson 
ACI~S DE COLING-92, NANTES, 23-28 AOfJ'r 1992 8 5 4 Pl~OC. oi: COLING-92, NANTES, AUG. 23-28, 1992 
