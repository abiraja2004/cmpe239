Proceedings of the Linguistic Annotation Workshop, pages 85?92,
Prague, June 2007. c?2007 Association for Computational Linguistics
A Search Tool for Parallel Treebanks
Martin Volk, Joakim Lundborg and Mae?l Mettler
Stockholm University
Department of Linguistics
106 91 Stockholm, Sweden
volk@ling.su.se
Abstract
This paper describes a tool for aligning and
searching parallel treebanks. Such treebanks
are a new type of parallel corpora that come
with syntactic annotation on both languages
plus sub-sentential alignment. Our tool al-
lows the visualization of tree pairs and the
comfortable annotation of word and phrase
alignments. It also allows monolingual and
bilingual searches including the specifica-
tion of alignment constraints. We show that
the TIGER-Search query language can eas-
ily be combined with such alignment con-
straints to obtain a powerful cross-lingual
query language.
1 Introduction
Recent years have seen a number of initiatives in
building parallel treebanks. Our group has partici-
pated in these efforts by building a tri-lingual paral-
lel treebank called SMULTRON (Stockholm MULti-
lingal TReebank).1 Our parallel treebank consists
of syntactically annotated sentences in three lan-
guages, taken from translated (i.e. parallel) docu-
ments. In addition, the syntax trees of corresponding
sentence pairs are aligned on a sub-sentential level.
This means they are aligned on word level or phrase
level (some phrases can be as large as clauses). Par-
allel treebanks can be used as training or evalua-
tion corpora for word and phrase alignment, as input
1We gratefully acknowledge financial support for the
SMULTRON project by Granholms stiftelse and Rausings stif-
telse.
for example-based machine translation (EBMT), as
training corpora for transfer rules, or for translation
studies.
Similar projects include Croco (Hansen-Schirra
et al, 2006) which is aimed at building a German-
English parallel treebank for translation stud-
ies, LinES an English-Swedish parallel treebank
(Ahrenberg, 2007), and the Czech-English parallel
dependency treebank built in Prague (Cmejrek et al,
2005).
SMULTRON is an English-German-Swedish par-
allel treebank (Samuelsson and Volk, 2006;
Samuelsson and Volk, 2007). It contains the first
two chapters of Jostein Gaarder?s novel ?Sofie?s
World? with about 500 sentences. In addition it
contains 500 sentences from economy texts (a quar-
terly report by a multinational company as well as
part of a bank?s annual report). We have (semi-
automatically) annotated the German sentences with
Part-of-Speech tags and phrase structure trees (incl.
edges labeled with functional information) follow-
ing the NEGRA/TIGER guidelines for German tree-
banking.
For English we have used the Penn Treebank
guidelines which are similar in that they also pre-
scribe phrase structure trees (with PoS tags, but only
partially annotated with functional labels). However
they differ from the German guidelines in many de-
tails. For example the German trees use crossing
edges for discontinuous units while the English trees
introduce symbols for empty tokens plus secondary
edges for the representation of such phenomena.
For Swedish there were no appropriate guidelines
available. Therefore we have adapted the German
85
guidelines to Swedish. The general annotation strat-
egy for Swedish was the same as for German: PoS
tags, phrase structure trees (incl. functional edge la-
bels) and crossing branches for discontinuous units.
But, of course, there are linguistic differences be-
tween German and Swedish that required special
attention (e.g. Swedish prepositions that introduce
sentences).
The treebanks for all three languages were anno-
tated separately with the help of the treebank editor
ANNOTATE. After finishing the monolingual tree-
banks, the trees were exported from the accompany-
ing SQL database and converted into an XML for-
mat as input to our alignment tool, the Stockholm
TreeAligner.
In this paper we will first describe this alignment
tool and then focus on its new search facility. To our
knowledge this is the first dedicated tool that com-
bines visualization, alignment and searching of par-
allel treebanks (although there are others who have
experimented with parallel corpus searches (Ny-
gaard and Johannesen, 2004; Petersen, 2006)).
2 The Stockholm TreeAligner
When our monolingual treebanks were finished, the
trees were exported from the editor system and con-
verted into TIGER-XML. TIGER-XML is a line-
based (i.e. not nested and thus database-friendly)
representation for graph structures which supports
crossing edges and secondary edges.2 TIGER-XML
has been defined as input format for TIGER-Search,
a query tool for monolingual treebanks (see section
3). We use this format also as input format for our
alignment tool, the Stockholm TreeAligner (Volk et
al., 2006).
The TreeAligner program is a graphical user in-
terface to specify (or correct) word and phrase
alignments between pairs of syntax trees.3 The
TreeAligner is roughly similar to alignment tools
such as I*Link (Ahrenberg et al, 2002) or Cairo
(Smith and Jahr, 2000) but it is especially tailored to
visualize and align full syntax trees (including trees
with crossing edges).
2For information about TIGER-XML see www.ims.uni-
stuttgart.de/projekte/TIGER
3The TreeAligner is freely available at www.ling.su.se/
DaLi/downloads/treealigner/index.htm
Figure 1: Tree pair German-English in the
TreeAligner.
The TreeAligner operates on an alignment file in
an XML format developed by us. This file describes
the alignments between two TIGER-XML treebanks
(specified in the alignment file) holding the trees
from language one and language two respectively.
For example the alignment between two nodes is
represented as:
<align type="exact">
<node id="s13_505" tb_id="DE"/>
<node id="s14_506" tb_id="EN"/>
</align>
This says that node 505 in sentence 13 of the Ger-
man treebank is aligned with node 506 in sentence
14 of the English treebank. The node identifiers re-
fer to the ids in the TIGER-XML treebanks. The
alignment is given the label ?exact? if the corre-
sponding token sequences are equivalent in mean-
ing.
The alignment file might initially be empty when
we want to start manual alignment from scratch, or
it might contain automatically computed alignments
for correction. The TreeAligner displays tree pairs
with the trees in mirror orientation (one top-up and
one top-down). See figure 1 for an example. The
trees are displayed with node labels and edge labels.
The PoS labels are omitted in the display since they
are not relevant for the alignment task.4
4During the development of our treebanks we discovered
86
Each alignment is displayed as a dotted line be-
tween two nodes (or words) across two trees. Click-
ing on a node (or a word) in one tree and drag-
ging the mouse pointer to a node (or a word) in the
other tree inserts an alignment line. Currently the
TreeAligner supports two types of alignment lines
(displayed in different colors) which are used to in-
dicate exact translation correspondence vs. approxi-
mate translation correspondence. However, our ex-
periments indicate that eventually more alignment
types will be needed to precisely represent differ-
ent translation differences. The alignment type at-
tribute can be used to describe many different lev-
els or types of alignment. These distinctions could
prove useful when exploiting the aligned treebanks
for Machine Translation and other applications.
Often one tree needs to be aligned to two (or
more) trees in the other language. The TreeAligner
therefore provides the option to browse the trees in-
dependently. For instance, if we have aligned only a
part of a tree Ti from language one to tree Tk of lan-
guage two, we may scroll to tree Tk+1 of language
two in order to align the remaining parts of Ti. Spe-
cial [Forward] and [Back] buttons are provided to
browse through the multiple-aligned trees systemat-
ically.
The TreeAligner is designed as a stand-alone tool
(i.e. it is not prepared for collaborative annotation).
It stores every alignment in an XML file (in the for-
mat described above) as soon as the user moves to a
new tree pair.
The TreeAligner was implemented in Python by
Joakim Lundborg. Python has become popular
in Language Technology in recent years. It is a
high level programming language that allows dif-
ferent programming styles including a good sup-
port for object-oriented programming. It is an in-
terpreted language that uses a dynamic type system.
It is therefore mostly compared to its siblings Perl,
Tcl and Ruby, even though the influence of other
languages like Smalltalk and Haskell are probably
stronger on a conceptual level.
One of Python?s strengths is the ease with which
that the TreeAligner is also useful for displaying different ver-
sions of the same treebank (e.g. before and after corrections, or
manually vs. automatically parsed). Therefore we plan to add a
tree-diff module which will highlight the differences between a
pair of trees over the same token sequence.
a programmer can manipulate primitive data types
like strings or numbers. Python?s string objects are
an excellent match to the needs of linguistic process-
ing. In addition to the primitive data types, Python
also features higher level data types: lists, tuples and
dictionaries. The combination of these built-in data
types, the vast standard library and the simple and
straightforward syntax make Python the perfect tool
for a wide range of scientific programming.
The TreeAligner served us well for creating the
alignments, but it soon became evident that we
needed suitable tools to explore and exploit the
aligned data. The most apparent need was a search
module for aligned trees. We decided to design our
search module after TIGER-Search.
3 TIGER-Search
TIGER-Search is a powerful treebank query tool de-
veloped at the University of Stuttgart by Wolfgang
Lezius (cf. (Ko?nig and Lezius, 2002; Lezius, 2002).
Its query language allows for feature-value descrip-
tions of syntax graphs. It is similar in expressiveness
to tgrep (Rohde, 2005) but it comes with graphical
output and highlighting of the syntax trees plus nice
frequency tables for objects identified in the query.
TIGER-Search has been implemented in Java and is
freely available for research purposes. Because of its
clearly defined input format (TIGER-XML) and its
powerful query language, it has become the corpus
query system of choice for many linguists.
The TIGER-Search query language is based on
feature-value descriptions of all linguistic objects
(tokens and constituents), dominance, precedence
and sibling relations in the tree, graph predicates
(e.g. with respect to token arity and continuity), vari-
ables for referencing objects, regular expressions
over values for varying the query precision, and
queries over secondary edges (which constitute a
secondary graph level).
A complex query might look like in the follow-
ing example (with > denoting direct dominance, >*
denoting general dominance, the dot denoting im-
mediate precedence, and the # symbol introducing
variables). This query is meant to find instances of
two ambiguously located PPs that are both attached
to the first noun (as illustrated by the example tree in
figure 2).
87
Figure 2: Noun phrase tree from the Penn Treebank
#np:[cat="NP"] >* #n1:[pos="NN"]&
#np > #pp1:[cat="PP"] &
#n1 . #pp1 &
#pp1 >* #n2:[pos="NN"] &
#np > #pp2:[cat="PP"] &
#n2 . #pp2
This query says: Search for an NP (call it #np)
that dominates a noun #n1 (line 1) and two PPs (lines
2 and 5). #pp1 must follow immediately after the
noun #n1 (line 3), and #pp2 must follow immedi-
ately after the noun within the #pp1 (lines 4 and 6).
TIGER-Search handles such queries efficiently
based on a intricate indexing scheme. It finds all
matching instances in a given treebank and allows
to browse (and to export) the resulting trees. The
matching objects in the resulting trees are high-
lighted.
TIGER-Search is limited in that it only allows
manually entered queries (rather than processing a
batch of queries from a file). Furthermore it is lim-
ited with regard to negation. The TIGER-Search
query language includes a negation operator but this
is of limited usefulness. The reason is that ?For
the sake of computational simplicity and tractabil-
ity, the universal quantifier is (currently) not part
of the TIGER language? (quoted from the TIGER-
Search online help manual). This means that typical
negated queries such as ?Find all VPs which do not
contain any NP? are not possible.
And clearly TIGER-Search is a tool for querying
monolingual treebanks and thus needed to be ex-
tended for our purposes, i.e. querying parallel tree-
banks.
4 The TreeAligner Search Module
(Merz and Volk, 2005) had listed the requirements
for a parallel treebank search tool. Based on
these we have now re-implemented TIGER-Search
for parallel treebanks and integrated it into the
TreeAligner.
The idea is to allow the power of TIGER-Search
queries on both treebanks plus additional alignment
constraints. For example, a typical query could ask
for a verb phrase VP dominating a prepositional
phrase PP in treebank one. This query can be com-
bined with the constraint that the VP in treebank one
is aligned to a sentence S in treebank two which also
dominates a PP. Such a query would be expressed in
3 lines as:
#t1:[cat="VP"] > [cat="PP"]
#t2:[cat="S"] > [cat="PP"]
#t1 * #t2
These three lines are entered into three separate
input fields in the user interface (cf. the three in-
put fields in the bottom left in figure 3). Lines 1
and 2 contain the queries over the monolingual tree-
banks 1 and 2. And line 3 contains the alignment
constraint. Note that the treebank queries 1 and 2
closely follow the TIGER-Search syntax. In par-
ticular they allow the binding of variables (marked
with #) to specific linguistic objects in the query.
And these variables are used in the alignment con-
straint in line 3. The reuse of the variables is the cru-
88
Figure 3: Screenshot of the TreeAligner with the Search Module.
cial idea which enabled a clear design of the Search
Module by keeping the alignment constraints sepa-
rate from the queries over the two treebanks.
So the above query will find the tree pair in figure
3 because it matches the alignment between the Eng-
lish VP closed the front door behind her and the el-
liptical Swedish sentence sta?ngde do?rren bakom sig
(which lacks the subject, but is still annotated as S).
The Search Module has recently been added to the
TreeAligner. It is intended to be used with any par-
allel treebank where the monolingual treebanks can
be converted into TIGER-XML and where the align-
ment information can be converted to the SMUL-
TRON alignment format. The separation of these
parts makes it possible to query each treebank sepa-
rately as well. The system is divided into a monolin-
gual query facility and an alignment query facility
that makes use of the former to perform its job. This
design choice made it necessary to (re)implement
the following in Python:
1. TIGER-Search
2. The alignment query facility
3. The integration into the TreeAligner
The choice of reimplementing TIGER-Search in
Python influenced the feature set. Even though
the implementation of TIGER-Search is well doc-
umented (in (Lezius, 2002) among others) and the
source codes are available under an Open Source li-
cense, this is still a non-trivial task. In order to nar-
row down the amount of work in a first phase, it was
decided to restrict the implementation to a subset of
the TIGER-Search query language. The implemen-
tation of negation within the queries was therefore
postponed (with the exception of negations used in
regular expressions within a feature definition). As
discussed in section 3, negations are limited even in
TIGER-Search, and we plan to implement a com-
prehensive support for negation at a later stage. The
code already has hooks for this extension.
The language for the alignment constraints is
kept simple as well. The user can specify that
two linguistic objects must be aligned (with exact
89
alignment or approximate alignment). And such
constraints can be combined with AND statements
into more complex constraints. Currently, we can-
not foresee exactly how a parallel treebank will be
queried. We have therefore focused on a clear de-
sign of the Search Module rather than overloading it
with features. This will facilitate the integration of
more features as they are requested by users.
4.1 Implementation Details
The implementation of the Search Module started
as a close re-implementation of the TIGER-Search
system described in (Lezius, 2002). During the de-
velopment it became apparent that some of Lezius?
design choices did not translate well into Python.
Moreover, the advancements concerning speed and
memory in computer hardware in recent years have
made it possible for us to deviate from the original
design towards a more Python-oriented and simpler
code with less considerations for resource limita-
tions (see (Mettler, 2007)).
This code base can be divided into four types
of functionality classes: helper, index, parser and
processor. The helper classes are the smallest pieces
of code and perform trivial tasks like sorting or set
operations and are called from the other classes.
The query system as such consists of the index, the
parsers and processors. The parsers are used to
transform a string such as the TIGER-XML files or
the queries into objects. These parse objects are then
used to create the index or are passed to a processor
object to get the results of a query.
The index consists of four classes. The Cor-
pus class governs the three others which are used
to store the data for the graphs and the attribute
value register that is defined in the TIGER-XML
head. Each graph is contained within its own ob-
ject. The attribute value register consists of one ob-
ject that governs a range of attribute value lookup
tables. There are three parser classes and one parser
method. Each of these parser classes handles a dif-
ferent input. The first parses TIGER-XML, the sec-
ond parses the node definitions within a TIGER-
Search query (contained within the square brackets),
and the third parser class uses them to parse com-
plete TIGER-Search queries. As the syntax for the
alignment constraints is simple, this was done within
a method of the parallel query processor class. This
is likely to change with the increasing feature set for
parallel queries.
The last part of the system consists of two proces-
sor classes. The first is the class used for monolin-
gual queries. On instantiation the class takes an in-
dex object and a query parser object as arguments.
When the object?s query method is called with a
query string, the object lets the query parser produce
a parse object from the string. The parse object is
then processed to produce an object that contains the
matching graph parts using the index. The processor
for parallel queries works similarly. On instantiation
a monolingual processor for each language is passed
as arguments to the object. When the query method
is called, the parallel processor objects gets the re-
sults from the monolingual processors first and then
parses and processes the parallel query using the re-
sults from the monolingual processing step. The re-
sult of a query is a list with the two aligned sentence
IDs.
4.2 Evaluation of the Search Module
The TreeAligner Search module was first tested by
running a set of representative queries over a part
of our English-German parallel treebank (500 tree
pairs). This test set included:
? dominance relations (direct dominance, gen-
eral dominance, labeled dominance, right and
left corner dominance)
? precedence relations (immediate precedence,
general precedence, sibling precedence, prece-
dence distance)
? queries over secondary edges
? graph predicates (root, arity, tokenarity)
For the monolingual queries we checked whether
the number of hits in our TreeAligner Search cor-
responded to the number of hits in TIGER-Search.
This worked nicely. For bilingual queries we manu-
ally checked the correctness of the results.
We also tested the system for robustness and scal-
ability. Since we currently do not have a large paral-
lel treebank, we took the German NEGRA treebank
with 10,000 trees and used it for both language one
and language two in our TreeAligner. This means
we used each tree aligned to a copy of itself as the
90
basic data. This treebank contains around 81,000
nodes. We automatically generated an alignment file
that contains each node aligned to its copy in the
corresponding tree. This means we were using an
alignment file with 81,000 alignments.
Unfortunately the time for loading this data set
into the TreeAligner was prohibitively long (while
loading a monolingual treebank with 10,000 trees
into TIGER-Search takes less than a minute for in-
dexing it once, plus few seconds for loading the in-
dex before starting the searches). Obviously, we
need to improve the scalability of the TreeAligner.
When we redid the experiment with 1000 trees
from the NEGRA treebank (with 35,756 align-
ments), it worked fine. Loading takes about one
minute, and queries like the one given in the exam-
ple above are processed in less than one minute. The
system is currently not optimized for speed. It is
a proof-of-concept system to demonstrate that the
(monolingual) TIGER-Search query language can
be elegantly extended with alignment constraints for
parallel treebank searches.
Lately we have tested the use of serialized in-
dexes. We have observed that they are much faster,
but that the speed-up factor decreases with increas-
ing file size. It seems that eventually we will have
to switch to a custom binary format as was done
in TIGER-Search, if we want to provide a smooth
work experience with parallel treebanks of 10,000
and more trees.
5 Conclusions
We have built a TreeAligner for displaying and
searching parallel aligned trees. The tool is writ-
ten in Python and freely available. In particular it
allows to align nodes and words across languages
by drawing lines. We distinguish between exact
and approximate alignment types. The search mod-
ule which was recently added supports queries over
both treebanks in combination with alignment con-
straints. The query language follows TIGER-Search
(though negation is not included yet). The alignment
constraints use the variables bound to linguistic ob-
jects in the monolingual queries.
In the future we will improve the TreeAligner in
three directions: features, usability and evaluation.
The feature part consists of providing full support
for TIGER-Search queries (in particular the imple-
mentation of negation) and improving the parallel
query facilities (with a variety of alignment con-
straints).
Moreover we are in the process of extending the
TreeAligner to handling dependency trees. The
TreeAligner currently imports only treebanks in
TIGER-XML. This format is well suited for rep-
resenting phrase structure trees but less for depen-
dency trees. We will therefore extend the support to
appropriate XML import formats.
Usability is the broadest group and aims at im-
provements like creating an installation routine for
all operating systems, improving speed and making
sure that UTF8 support works properly.
Finally, more systematic evaluations are needed.
We plan to enlarge our standard set of queries to
cover all possible combinations. This query set
could then be used to test the speed and performance
of our system (and for the comparison with other
systems). We hope that the TreeAligner will gain a
broad user community which will help to drive im-
provements in alignment and querying.
References
Lars Ahrenberg, Magnus Merkel, and Mikael Andersson.
2002. A system for incremental and interactive word
linking. In Proc. of LREC-2002, pages 485?490, Las
Palmas.
Lars Ahrenberg. 2007. LinES: An English-Swedish par-
allel treebank. In Proc. of Nodalida, Tartu.
Martin Cmejrek, Jan Cur??n, and Jir?? Havelka. 2005.
Prague Czech-English dependency treebank. Resource
for structure-based MT. In Proceedings of EAMT 10th
Annual Conference, Budapest.
Silvia Hansen-Schirra, Stella Neumann, and Mihaela
Vela. 2006. Multi-dimensional annotation and align-
ment in an English-German translation corpus. In Pro-
ceedings of the EACL Workshop on Multidimensional
Markup in Natural Language Processing (NLPXML-
2006), pages 35? 42, Trento.
Esther Ko?nig and Wolfgang Lezius. 2002. The TIGER
language - a description language for syntax graphs.
Part 1: User?s guidelines. Technical report.
Wolfgang Lezius. 2002. Ein Suchwerkzeug fu?r syn-
taktisch annotierte Textkorpora. Ph.D. thesis, IMS,
University of Stuttgart, December. Arbeitspapiere des
91
Instituts fu?r Maschinelle Sprachverarbeitung (AIMS),
volume 8, number 4.
Charlotte Merz and Martin Volk. 2005. Requirements
for a parallel treebank search tool. In Proceedings of
GLDV-Conference, Sprache, Sprechen und Computer
/ Computer Studies in Language and Speech, Bonn,
March. Peter Lang Verlag.
Mae?l Mettler. 2007. Parallel treebank search - the imple-
mentation of the Stockholm TreeAligner search. C-
uppsats, Stockholm University, March.
Lars Nygaard and Janne Bondi Johannesen. 2004.
SearchTree - a user-friendly treebank search interface.
In Proc. of 3rd Workshop on Treebanks and Linguistic
Theories, pages 183?189, Tu?bingen, December.
Ulrik Petersen. 2006. Querying both parallel and tree-
bank corpora: Evaluation of a corpus query system. In
Proc. of LREC, Genua.
Douglas L. T. Rohde, 2005. TGrep2 User Manual. MIT.
Available from http://tedlab.mit.edu/ ?dr/Tgrep2/.
Yvonne Samuelsson and Martin Volk. 2006. Phrase
alignment in parallel treebanks. In Jan Hajic and
Joakim Nivre, editors, Proc. of the Fifth Workshop
on Treebanks and Linguistic Theories, pages 91?102,
Prague, December.
Yvonne Samuelsson and Martin Volk. 2007. Alignment
tools for parallel treebanks. In Proceedings of GLDV
Fru?hjahrstagung 2007.
Noah A. Smith and Michael E. Jahr. 2000. Cairo: An
alignment visualization tool. In Proc. of LREC-2000,
Athens.
Martin Volk, Sofia Gustafson-Capkova?, Joakim Lund-
borg, Torsten Marek, Yvonne Samuelsson, and Frida
Tidstro?m. 2006. XML-based phrase alignment in par-
allel treebanks. In Proc. of EACL Workshop on Multi-
dimensional Markup in Natural Language Processing,
Trento, April.
92
