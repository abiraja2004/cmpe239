Floating Constraints in Lexical Choice 
Michael Elhadad* 
Ben Gurion University in the Negev 
Jacques Robin~ 
Universidade Federal de Pernambuco 
Kathleen McKeown t
Columbia University 
Lexical choice is a computationally complex task, requiring a generation system to consider 
a potentially large number of mappings between concepts and words. Constraints that aid in 
determining which word is best come from a wide variety of sources, including syntax, semantics, 
pragmatics, the lexicon, and the underlying domain. Furthermore, in some situations, different 
constraints come into play early on, while in others, they apply much later. This makes it difficult 
to determine a systematic ordering in which to apply constraints. In this paper, we present a
general approach to lexical choice that can handle multiple, interacting constraints. We focus on 
the problem of floating constraints, emantic or pragmatic onstraints that float, appearing at a 
variety of different syntactic ranks, often merged with other semantic constraints. This means that 
multiple content units can be realized by a single surface element, and conversely, that a single 
content unit can be realized by a variety of surface elements. Our approach uses the Functional 
Unification Formalism (Fu~) to represent a generation lexicon, allowing for declarative and 
compositional representation findividual constraints. 
1. Introduction 
Given a request o communicate, a language generator typically must select infor- 
mation from an underlying domain representation a d determine how to order this 
information, ultimately realizing the representation as sentences by selecting words 
and linearly ordering them under the syntactic onstraints of the language. The prob- 
lem of determining what words to use for the concepts in the domain representation 
is termed lexical choice. In an effort to make domain representations i dependent of
language, there may be a variety of different words that can be used to express any 
concept in the domain, and a language generator must choose which one is most ap- 
propriate in the current context. A one-to-one mapping between each domain concept 
and a word of the language would imply that concepts are represented by words, 
clearly an undesirable situation. Just as there is no reason to assume that a concept 
uniquely determines a word, there is no reason to assume that a single concept must 
map to a single word; a domain concept may be expressed by multiple words, or 
conversely, a single word may express a combination of concepts (Talmy 1985; Zock 
1988). 
Avoiding encoding any assumptions about the mapping between domain and 
language has the benefit of portability; the architecture and some knowledge sources 
of the generator can be reused for a variety of different applications in quite different 
* Mathematics and Computer Science Department, Beer Sheva, 84105 Israel. E-mail: elhadad@cs.bgu.ac.il 
t Computer Science Department, New York, NY 10027 USA. E-mail: kathy@cs.columbia.edu 
:~ Departamento de Informatica, Recife, PE 50740-540 Brazil. E-mail: jr@di.ufpe.br 
(~) 1997 Association for Computational Linguistics 
Computational Linguistics Volume 23, Number 2 
domains. However, it means the task of lexical choice is computationally complex, 
requiring consideration of a potentially large number of mappings between concepts 
and words. This is complicated by the fact that constraints on lexical choice come from 
a wide variety of sources: 
? Syntax (the choice of a particular verb influences the syntactic forms that 
can be used to realize its arguments, which in turn constrains the words 
used to lexical)ze these arguments). For example, if the main verb to 
allow is selected, then the object must be either a clause (allow one to select) 
or a noun-group (allow the selection). 1 
? Semantics (the concept itself and how it is taxonomized in the domain 
influence which word should be used). For example, when discussing 
basketball, the words rebound and point realize distinct concepts under 
the generic concept of a player "performance." 
? The lexicon (the choice of one word can constrain the choice of other 
words in a sentence). For example, the selection of rebound as object 
noun would entail preferring to grab over to score as main verb, while the 
selection of point would entail the opposite verb choice, since to grab 
rebounds and to score points are lexical collocations, whereas ?to score 
rebounds and ?to grab points are not. 
? The domain (the same words are used to refer to different concepts in 
different domain sublanguages). For example, rebound means different 
things in the basketball domain and in the stock-market domain (IBM 
rebounded from a 3 day loss vs. Magic grabbed 20 rebounds). 
? Pragmatics (information about speaker intent, hearer background, or 
previous discourse plays a role). This may lead to the decision to refer to 
the same situation as a glass half ull or half empty. 
Furthermore, interaction between constraints i multidirectional, making it difficult 
to determine a systematic ordering in which constraints should be taken into account. 
In fact, earlier work on lexical choice (Danlos 1986) implied that a new ordering of 
constraints, and thus a new architecture for lexical choice, must be developed for each 
new domain. 
In this paper, we present a general approach to lexical choice that can handle 
multiple, interacting constraints. Our architecture positions the lexical choice module 
between a language generator's content planner and surface sentence generator, in 
order to take into account conceptual, pragmatic, and linguistic constraints on word 
choice. We show how the Functional Unification Formalism (FUF) (Elhadad 1993a), 
originally developed for representing syntactic grammars (Kay 1979), can be used to 
represent a generation lexicon, allowing for declarative and compositional represen- 
tation of independent constraints. The order of constraint application is determined 
dynamically through unification, allowing for different orderings as required. Since 
any approach must deal with a combinatorial explosion of possible mappings and 
ordering of constraints, computational efficiency is in general an issue. We show con- 
trol techniques we have developed within FUF to reduce overall search. In this paper, 
1 The options are different in French for example, where the corresponding verb governs a VP permet de 
sdectioner. 
196 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
we illustrate our model for lexical choice as it has been implemented in ADVISOR- 
II (Elhadad 1993c), a system that can advise students about course selection, but 
we also draw on examples from two other systems based on the same model but 
within different generation architectures: STREAK, a system for generating basketball 
game summaries (Robin 1994a; Robin and McKeown 1996) and COOK (Smadja and 
McKeown 1991), a system that generates tock market reports. 2We have used this 
same model for lexical choice in other systems we have developed, such as COMET 
(McKeown et al 1990), a multimedia explanation system for equipment maintenance 
and repair, and PLANDOC (Kukich et al 1994), an automated ocumentation system 
under collaborative development with Bellcore. 
We focus on the problem of floating constraints, constraints that cannot be mapped 
in a systematic way from an input conceptual representation to the linguistic structure. 
Instead, such constraints float, appearing at a variety of different levels in the resulting 
linguistic structure, depending on other constraints in the input. Such constraints pose 
problems (see discussion in Elhadad and Robin \[1992\]) for the top-down recursive 
building of the linguistic structure used by most generation algorithms (Meteer et al 
1987; Shieber et al 1990); these algorithms typically only handle structural constraints, 
constraints that are consistently expressed at a given linguistic rank (e.g., the sentence, 
clause, group, or word rank) (Halliday 1985) in the application domain sublanguage. 
We consider two different ypes of floating constraints: 
? Interlexical constraints, which arise from restrictions on lexical 
co-occurrences such as collocations (Smadja 1991) (they are orthogonal to 
the mapping from input content units onto output linguistic form since 
they both originate from the lexicon and act upon the lexicon). 
? Cross-ranking constraints, which arise from the fact that an input 
network of content units is not isomorphic with the resulting linguistic 
structure, allowing a single content unit to be realized by surface 
elements of various linguistic ranks (cross-ranking proper), or multiple 
content units to be realized by the same surface element (merging). 
Sentences (1) and (2) below, generated by COOK, illustrate cross-ranking con- 
straints. They show how time and manner can be mapped to two different surface 
elements of different syntactic rank in the sentence, among many other possibilities. 
Sentences (3) and (4), generated by STREAK, show how game result and manner can 
be realized as two separate surface elements or can be merged into a single element, 
the verb. 
(1) Wall Street Indexes opened strongly. (time in verb, manner as adverb) 
(2) Stock indexes surged at the start of the trading day. (time as PP, manner in 
verb) 
(3) The Denver Nuggets beat the Boston Celtics with a narrow margin, 
102-101. (game result in verb, manner as PP). 
(4) The Denver Nuggets edged out the Boston Celtics 102-101. (game result 
and manner in verb) 
2 The differences between the system architectures of these three systems are discussed inSection 6.1.2. 
197 
Computational Linguistics Volume 23, Number 2 
In these examples, the input conceptual constraints (time and manner) float, ap- 
pearing at a variety of different syntactic ranks (here, verb and circumstantial), and 
are sometimes merged with other semantic onstraints. 
Which content units are floating and which are structural depends on the domain 
and the particular target sublanguage. Our corpus analysis of the basketball domain, 
for example, indicates that historical knowledge is floating, whereas game result in- 
formation is structural. Similarly, in the student advising domain, we found course 
evaluation (e.g., how difficult or interesting a course is) to be floating, whereas the 
description of the assignments required (e.g., how many there are or whether they 
involve writing essays, software, or proofs) in a course is structural. 
Floating constraints have not been addressed in a general way in previous work; 
most systems implicitly hardwire the choices or permit only one or two of many pos- 
sibilities. In contrast, our model for lexical choice accommodates floating constraints, 
resulting in a system with a high degree of paraphrasing power. 
In the following sections, we first present our general model for lexical choice, 
illustrating it with a relatively simple example. We then discuss different ypes of con- 
straints and the problems they pose, presenting the techniques we have developed 
within FUF to address these issues, turning from structural constraints, to pragmatic 
cross-ranking constraints, and to interlexical constraints. Finally, we compare our ap- 
proach with other work on lexical choice, closing with a summary of our contributions. 
2. An Architecture for Lexical Choice 
The place of lexical choice in the overall architecture of generation systems has varied 
from project o project. Due to the varied nature of the constraints on lexical choice, 
exactly how lexical choice is done often depends on the type of constraints a system 
design accounts for. For example, if syntactic and lexical constraints are the research 
focus, it may make sense to delay lexical choice until late in the generation process, 
during syntactic realization. If only conceptual constraints are accounted for, lexical 
choice may be done early on, for example, during content planning by associating 
concepts with the words or phrases that can realize them. 
In this section, we describe a general model for lexical choice as part of an overall 
generation system architecture. Due to the wide variety of constraints on word selec- 
tion that we consider, lexicalization is positioned after the content of the generated text 
has been determined and before syntactic realization takes place. We detail the nature 
of input and output to the lexical choice module, thus specifying the tasks the lexical 
choice module performs and the tasks that are expected to be done elsewhere in the 
system. We illustrate, through a relatively simple example that depends on a single 
type of constraint, how FUF and unification are used for lexicalization. Our criteria 
for a model for lexical choice are fourfold: 
. 
. 
3. 
. 
It must be able to use the full variety of constraints whether pragmatic, 
semantic, lexical, or syntactic. 
It must be able to apply constraints in a flexible order. 
It must avoid encoding assumptions about the mapping between 
domain concepts and lexical structure. 
It must be able to handle floating constraints. 
198 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
Communication Request 
Content Specification 
Lexical 
~' L 1 Chooser 
I Surface R alization 
~l . (  Lexical ~ .l C Lexica-----~ 
T I r :m: ionl I i? 1 I 1 
Figure 1 
Possible placements of lexical choice within a generator's architecture. 
Text ~t 
2.1 Lexical Choice within a Generation System Architecture 
Generation systems perform two types of tasks: one conceptual, determining the con- 
tent of the text to be generated, and one linguistic, determining the form of that 
text (McDonald 1983; McKeown 1985). Typically, a generator has two modules, each 
corresponding to one of these two tasks, a content planner and a linguistic realizer. 
While many systems allow for interaction across these components, there is general 
consensus that these two components can be separated (Reiter 1994). Furthermore, 
within the linguistic component, here appears to be further consensus that the task 
of syntactic realization can be isolated. As evidence, note that a number of dedicated 
syntactic realization components have been developed such as SURGE (Elhadad and 
Robin 1996), NICEL (Matthiessen 1991), MUMBLE (Meteer et al 1987), and TAGs (Yang, 
McCoy, and Vijay-Shanker 1991; Harbusch 1994). Such components expect as input a 
specification of the thematic structure of the sentence to generate, with the syntactic 
category and open-class words of each thematic role. 3 Thematic structure involves roles 
such as agent, pat ient,  instrument, etc. It is opposed to surface syntactic structure 
which involves roles such as subject,  object,  adjunct, etc. Due to general syntac- 
tic alternations (Levin 1993) such as passive, dative, it-extraposition, or clefting, the 
mapping from thematic roles onto surface syntactic roles is one-to-many. The role of 
the syntactic grammar is to (1) map the thematic structure onto a surface syntactic 
one, (2) enforce syntactic rules such as agreement, (3) choose the closed-class words, 
(4) inflect the open-class ones, and (5) linearize the surface syntactic tree into a natural 
language string. These tasks indicate the kind of information the syntactic grammar 
needs as input. For example, unless the system is to choose randomly, it needs enough 
information to choose between different syntactic options available in the grammar. 
Furthermore, input must either specify all words, or provide enough features o that 
the syntactic grammar can lexicalize any words that are syntactically determined. 
Lexical choice could be carried out at any number of places within this standard 
architecture. Figure I shows the typical anguage generation architecture used in many 
systems, indicating the different places for lexical choice to occur. One option would 
be to position lexical choice as part of syntactic realization, as just a very specific type 
of syntactic decision (i.e., option 3 in Figure 1). Researchers who work on reversible 
3 Words are traditionally divided into (a) open-class words such as nouns, verbs, adjectives and adverbs 
and (b) closed-class words (also called fimction words) such as articles, pronouns, and conjunctions. 
Open classes are large and constantly expanding while closed classes are small and stable. 
Distinguishing elements in an open class requires emantics while in a closed class, it can be done on 
syntactic grounds only. 
199 
Computational Linguistics Volume 23, Number 2 
grammar formalisms, using the same grammar to both parse and generate language, 
take this approach (Van Noord 1990; Shieber and Shabes 1991; Strzalkowski 1994). 
The systemic grammar paradigm also takes this approach, where lexical choice is the 
most "delicate" of decisions, occurring as a by-product of many high-level syntactic 
choices. However, in computational implementations of the systemic paradigm, such 
as NIGEL (Mann and Matthiessen 1983), only the syntactic onstraints on lexical choice 
are handled during syntactic realization. The semantic onstraints on lexical choice 
are in effect taken into account in the input knowledge representation (i.e., option 1 
in Figure 1). 
There are two problems with option 3 (during syntactic realization). First, the range 
of constraints on lexical choice covered in this line of work is quite restricted and we 
have some question about whether it could be extended to include the pragmatic 
constraints considered here. Furthermore, since words are selected only once the full 
syntactic tree is constructed, it would be quite difficult, if not impossible, to account for 
floating constraints. Such constraints cannot be considered solely from local positions 
within a constructed tree, but require some global knowledge of interaction between 
semantic units. 
If lexical choice is not part of the syntactic realization component, hen all decisions 
regarding open-class word selection must be made before the grammar is invoked# 
They then must occur either as part of content planning or after all content has been 
determined and expressed in a language-independent manner. While some researchers 
have directly associated words with each concept in the domain-knowledge base (e.g., 
Reiter 1991; Swartout 1983), this approach does not allow for consideration of syntac- 
tic and lexical constraints unless a phrasal exicon is used (e.g., Kukich 1983b; Danlos 
1986; Jacobs 1985; Hovy 1988). Using a phrasal lexicon, however, means hand-encoding 
the many mappings of multiple constraints onto multiword phrasings. It thus does 
not allow for compositional lexical representation (Pustejovsky and Boguraev 1993), 
and entails a combinatorial explosion in the number of entries to cover the variations 
of phrases that are possible in different contexts. This approach thus does not allow 
for scaling up paraphrasing power (see Robin and McKeown \[1996\] for a quantita- 
tive evaluation of the scalability gains resulting from the compositional word-based 
approach). 
By waiting until content planning is complete, lexical and syntactic onstraints can 
be represented explicitly and independently ofone another, instead of being embedded 
into full phrases, allowing for a more economical and flexible word-based lexicon that 
incorporates phrasal constraints. 
The only remaining option is to position the lexical choice module between the 
content planner and the syntactic realization module. Note that some high-level de- 
cisions about sentence structure must be made early on with this architecture (i.e., 
before syntactic realization), since, for example, selecting the verb imposes syntactic 
constraints on how its arguments can be realized. This is desirable since it allows a 
system to take into account only those syntactic onstraints on lexical choice that are 
relevant. In fact, in the eight domains for which we have implemented generators, 
we have never found a case where other syntactic decisions made during realization 
force the lexical chooser to undo an earlier decision. This experience strongly supports 
modularization between lexical choice and syntactic realization. 5 
4 In fact, most portable syntactic components mentioned arlier, such as SURGE, MUMBLE, and TAGs, 
expect as input a fully lexicalized specification, thus supporting this approach. 
5 The only argument for option 3 is that it allows for an integrated account of the influence of surface 
structure on lexical choice within a single component. However, our experience (corroborated by 
200 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
As we will show, this architecture allows us to convey several aspects of the 
semantic ontent using the same word and at the same time, allows us to realize the 
same semantic oncept at a variety of syntactic ranks depending on the situation. In 
particular, by selecting words before a syntactic tree has been constructed, the lexical 
syntactic features associated with alternate l xical choices can constrain the high-level 
structure of the final tree, which is a key feature to handling floating constraints. 
2.2 Input and Output 
Given this organization, input to the lexical choice module will be structures from the 
application domain representation selected uring content planning, possibly aug- 
mented with discourse relations. Following our criteria for generation, the structure 
of the conceptual input will not be committed to any linguistic structure, in order 
to avoid encoding assumptions about realization into the domain application, and 
in order to free the content planner from reasoning about linguistic features when 
determining what information should be included. Thus, it should be possible for a 
conceptual structure to be realized by a clause, a nominalization, a noun-noun mod- 
ifier, a predicative adjective, or a prepositional phrase. Similarly, the mapping need 
not be one-to-one. Several conceptual e ements may be realized by the same linguistic 
constituent, and conversely, several linguistic onstituents may be needed to realize a 
single conceptual element. 
For example, consider the conceptual input to ADVISOR-II's Lexical Chooser whose 
graph is outlined at the top tier of Figure 2. The domain from which concepts are 
selected is an expert system rule base, which uses gradual rules of inference (e.g., the 
more assignments in a class, the harder the class). The input is a set of three relations, 
each of which is represented similarly by a set of attribute-value pairs in the feature 
structure form shown in the central tier of Figure 2, except for cardinality, which 
reduces to an integer. This content representation does not indicate which relations 
should appear as the head element in the linguistic structure and which should appear 
as dependents. Nor does it indicate which syntactic relations hould be used. 
As a result, many different paraphrases of this content can be generate d, as il- 
lustrated by the five given at the bottom tier of Figure 2. Note that while in (1) the 
relation assignt-type surfaces as the main element in the syntactic structure, in (2)-(5) 
it appears as a dependent element. Note also the syntactic variety of these dependent 
elements. This example illustrates that, in contrast o much previous work in gen- 
eration (but see Meteer \[1990\]), we do not assume that relations will be realized as 
verbs and objects as their arguments. Instead, the Lexical Chooser must reason about 
how different domain entities can be realized. The ability to realize relations by com- 
pact constituents such as predicative adjectives or noun-noun modifiers allows for the 
fluency of the sentences of Figure 2. Realizing all relations in the Figure 2 input as 
clauses would result in rather cumbersome s ntences such as: Programming is the kind 
of assignments ofthe class whose topic is AI and the number of these assignments is six. 
Note that in order to choose between these sentences, the Lexical Chooser needs 
information other than just content encoded in the domain representation. I  general, 
the Lexical Chooser needs information about discourse and about speaker intent. For 
this particular example, it needs information about the speaker's focus and her per- 
spective, at this point in the discourse. Such information must be part of the input to 
the Lexical Chooser and can typically be provided by a content planner (McKeown 
Reiter's \[Reiter 1994\]) shows that he influences ofsyntax on lexical choice can be accounted for before 
syntactic realization. 
201 
Computational Linguistics Volume 23, Number 2 
AI AI-assignt "~, programming 
/~ber  
6 
i semr 
cat set \] 
assignments \[1\] cardinality 6 
generic_elt \[cat assignment \] 
class \[2\] name ai 
\[ cat assignment_activity \] activity \[3\] name programming 
7 \]\] class \[2\] relation1 args assignt \[1\] 
assignt \[11 relation2 args activity \[3\] 
. 
. 
. 
4. 
. 
The six AI assignments require programming. (relation assignt_type as main 
clause) 
AI has six assignments which involve programming. (relation assignt_type as 
relative clause) 
AI has six assignments of programming nature. (relation assignt_type as PP) 
AI has six programming assignments. (relation assignt_type as predicative 
adjective) 
AI has six implementation assignments. (relation assignt_type as 
noun-noun modifier) 
Figure 2 
An example of an input conceptual network with paraphrases that can be generated from it. 
1985; Polgu~re 1990; McCoy and Cheng 1991; Carcagno and Iordanskaja 1993), which 
must keep track of how focus shifts as it plans the discourse, or text. Similarly, any 
goals of the speaker must be provided as input to the Lexical Chooser. In the student 
advising domain, argumentative intent, or the desire of the speaker to cause the hearer 
to evaluate the information provided in a particular light, plays an important role. For 
example, whether the six programming assignments should be viewed as a plus of AI 
or a minus will depend both on hearer 6goals and on what action the speaker 7 thinks 
the hearer should pursue (i.e., take AI or not). Such goals, or argumentative intent, are 
used by the content planner in reasoning about what information to include. Again, 
6 In our  case, the sys tem user. 
7 In our  case, the system.  
202 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
since such goals are available to the content planner, they can easily be provided as 
input to the Lexical Chooser. 
2.3 Two Tasks for Lexical Choice 
Given the input and output specified above, this leaves two tasks for the Lexical 
Chooser: 
? Syntagmatic decisions: choosing among the many possible mappings 
from the fiat conceptual network it receives as input onto the thematic 
tree structure it must produce as output, (e.g., the choice of expressing 
the assignt_type relation in the network of Figure 2 as the main verb 
and the cardinal relation as a noun modifier in paraphrase \[1\]). 
? Paradigmatic decisions: choosing among alternative lexicalizations 
inside a particular thematic structure, (e.g., the choice of the verb to 
require to express the assignt_type relation in paraphrase \[1\] instead of 
to involve in \[2\]). 
While syntagmafic decisions may seem to be more syntactic in nature, they are 
directly intertwined with various lexical choices. Selecting the verb, or a higher-level 
relation such as a connective between two clauses, automatically determines overall 
thematic structure, while selecting which concept in the input will serve as head of 
the sentence directly influences choice of words. Minimally, syntagmatic decisions in- 
dude determining the main process, which constrains the set of possible verbs, s For 
example, in paraphrase (4) of Figure 2, this means choosing: 
? To map the relation class_assignt as the main process of the sentence. 
? A possessive thematic structure for that main process. 
? To map the arguments class and assignt of class_assignt onto 
respectively the possessor and possessed roles of the possessive 
process. 
Further syntagmatic choices determine which concepts will function as modifiers 
of any of these roles, ultimately surfacing as relative clauses, prepositional phrases, 
or adjectival describers. This mapping of conceptual structure to linguistic structure is 
carried out first in the Lexical Chooser. We call this initial stage involving syntagmatic 
decisions phrase planning. Then, the Lexical Chooser selects the actual words that 
are used to realize each role. We call this subsequent stage involving paradigmatic 
decisions lexicalization proper. 
Floating constraints are handled in both of these stages: for example merging two 
content units in a single linguistic unit is a phrase planning decision, whereas picking 
the appropriate collocate of an already chosen word is a paradigmatic decision. 
2.4 An Implementation Based on the FUF/SURGE Package 
The implementation of ADVlSOR-II builds on a software nvironment dedicated to the 
development of language generation systems: the FUF/SURGE package (Elhadad 1993a, 
8 Here we use the word "process" inthe systemic sense, see Section 2.4.2. 
203 
Computational Linguistics Volume 23, Number 2 
1993c). FUF (Functional Unification Formalism) is a programming language based on 
functional unification (Kay 1979). 9 Both the input and the output of a FUF program 
are feature structures called Functional Descriptions (FDs). The program itself, called 
a Functional Unification Grammar (FUG), is also a feature structure, but one which 
contains disjunctions and control annotations. The output FD results from the unifi- 
cation of this FUG with the input FD. The disjunctions in the FUG make unification 
nondeterministic. 
Functional unification has traditionally been used to represent syntactic grammars 
for sentence generation (e.g., Appelt 1983; McKeown 1985; Paris 1987) and FUF comes 
as a package with SURGE, a grammar of English implemented in FUF. SURGE is usable 
as a portable front-end for syntactic processing. FUF is the formalism part of the package, 
a language in which to encode the various knowledge sources needed by a generator. 
SURGE is the data part of the package, an encoded knowledge source usable by any 
generator. Using the FUF/SURGE package, implementing a generation system thus con- 
sists of decomposing nonsyntactic processing into subprocesses and encoding in FUF 
the knowledge sources for each of these subprocesses. Each such knowledge source is 
represented as a FUG. 1? In the case of ADVISOR-II, the focus of nonsyntactic processing 
is lexical choice. ADVISOR-II thUS essentially consists of a pipeline of two FUGs: a lex- 
ical FUG encoding the domain-specific lexical chooser and the domain-independent 
syntactic FUG SURGE. Lexical choice is performed by unifying the conceptual input 
with the lexical FUG or lexicon. The resulting lexicalized thematic tree is then unified 
with SURGE, which produces the final sentence. 
We now briefly overview the FUF language and then the SURGE syntactic grammar 
before explaining in detail how unification is used to perform lexical choice. 
2.4.1 FUF: A Functional Unification Formalism. Functional unification is based on two 
principles: information is encoded in simple and regular structures called functional 
descriptions (FDs) and FDs can be manipulated through the operation of unification. 11 
A Functional Unifier takes as input two FDs and produces a new FD if unification 
succeeds and failure otherwise. Note that contrary to structural unification (SU, as used 
in Prolog for example), functional unification (FU) is not based on order and length 
(see Shieber \[1992\] and Carpenter \[1992\] for recent and comprehensive d scriptions of 
feature structures). 
An important property of FDs is their ability to describe structure sharing (or reen- 
trancy): an FD can describe an identity equation between two attributes. For example, 
subject-verb agreement in a sentence is described by the FD: 
subject \[ number \[1\]\] 
verb \[ number \[1\] \] 
In this FD, the notation \[1\] indicates that the value of the attribute number under subject 
must be identical to that of the attribute number under verb, whatever it may be. In 
FUF, tags like \[1\] are encoded with the path notation such as {verb number}. A path 
is best understood as a pointer within the FD. Because paths can be used with no 
constraints, the graph encoding an FD can include loops and does not need to be a 
tree. 
9 FUF is currently implemented in Common Lisp. 
10 To avoid overloading the word "grammar," we will use "FUG" to refer to the common representation 
formalism and "syntactic grammar" to refer to syntactic data encoded in SURCE using this formalism. 
11 FDs are often called feature structures or attribute value matrices in the literature. 
204 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
The a l t  keyword expresses disjunction in FUF. The value of the a l t  keyword 
is a list of FDs, each one called a branch. When unifying an input FD with such a 
disjunction, the unifier nondeterministically selects one branch that is compatible with 
the input. Disjunctions encode the available choice points of a system and introduce 
backtracking in the unification process. In this paper, alts are represented using the 
following standard notation for disjunctions in feature structures: 
ALT name-of-alt } 
branch1 
branch2 
A disjunction can be embedded in another one if necessary. In addition, disjunctions 
can be named using the de f -a l t  notation, and referred to in other places using 
the notation (:! name). This notation allows for a modular notation of large gram- 
mars written in FUF. Other FUF constructs are introduced as needed in the rest of the 
paper. 
2.4.2 SURGE: A Wide-coverage Syntactic Front-End For Generation. SURGE is a 
wide-coverage syntactic grammar of English implemented in FUF and usable as a 
syntactic front-end portable across domains. It has been progressively developed over 
the last seven years and extensively tested for the generation of texts as varied as 
multimedia explanations (McKeown et al 1990), stock market reports (Smadja and 
McKeown 1991), student advisory sessions (Elhadad 1993c), telephone planning engi- 
neer activity reports (Kukich et al 1994; McKeown, Kukich, and Shaw 1994), taxation 
correspondence, visual scene descriptions (Abella 1994), didactic biology term deft- 
nitions (Lester 1994), basketball game summaries (Robin 1994a), workflow diagram 
descriptions (Passoneau et al 1996), news article summaries (McKeown and Radev 
1995), intensive care patient summaries (Dalai et al 1996), and web-page access de- 
mographics. 
SURGE represents our own synthesis, within a single working system and compu- 
tational framework, of the descriptive work of several (noncomputational) linguists. 
Our main source of inspiration were: Halliday (1985) and Winograd (1983) for the 
overall organization of the grammar and the core of the clause and nominal subgram- 
mars, Fawcett (1987) and Lyons (1977) for the semantic aspects of the clause, Pollard 
and Sag (1994) for the treatment of long-distance dependencies and Quirk et al (1985) 
for the many linguistic phenomena not mentioned in other works, yet encountered 
in many generation application domains. Since many of these sources belong to the 
systemic linguistic school, SURGE is mostly a functional unification implementation 
of systemic grammar ules. In particular, the type of FD it accepts as input specifies 
a "process" in the systemic sense, i.e., any type of situation involving a given set of 
participants (or thematic roles). This situation can be an event, a relation, or state in 
addition to a process in its most common, aspectually restricted sense. In this broader 
systemic sense, a process is thus a very general concept, simply denoting a semantic 
class of verbs sharing the same thematic roles. However, SURGE also includes aspects 
of lexical grammars, such as subcategorization. 
Furthermore, while SURGE is essentially systemic in terms of the type of thematic 
structure it expects as input, it differs from a purely systemic grammar implementation 
such as NIGEL (Mann and Matthiessen 1983) in terms of control. Because it is based on 
functional unification, SURGE is driven by both the structure of the grammar and that 
205 
Computational Linguistics Volume 23, Number 2 
of the input, working in tandem. In contrast, NIGEL is driven solely by the structure of 
the grammar, as encoded in its system networks. 
2.4.3 Lexical Choice by Functional Unification. We apply FUF to lexical choice by 
representing the lexicon as a FUG whose branches pecify both constraints on lexical 
choice (as tests) and the lexical features selected as a result of the different tests. Lexical 
choice is performed automatically by unifying the lexicon, or lexical FUG, with the 
conceptual input. During unification, the tests probe both the input conceptual network 
and the linguistic tree under construction. 
FUF is particularly suited for the representation f lexical constraints for a va- 
riety of reasons, some of which have been discussed elsewhere (e.g., McKeown and 
Elhadad 1990; McKeown et al 1990). First, FUF allows the representation f constraints 
on lexical choice in a declarative and compositional manner. This means that each con- 
straint can be represented separately and the ordering on how the constraints apply is 
determined dynamically through unification. Because the constraints are represented 
separately, lexical features are added as each constraint apphes, thus compositionally 
constructing the set of features that define the final choice. Finally, because unification 
is the governing process, constraints are bidirectional. 
Given the wide variety of constraints on lexical choice (Robin 1990) and the unpre- 
dictable manner in which they interact, hese features of FUF are particularly desirable. 
Since in different contexts, different constraints play more or less of a role, unification 
can determine dynamically which constraints are triggered and in what order. This is 
a benefit in several different scenarios. For example, sometimes a constraint is stated 
in the input while at other times it may be derived from the choice of another word 
in the sentence. If the constraint is available, it can influence the choice of that word; 
if not, then if the word is selected based on other constraints, it will trigger the con- 
straint, which may in turn trigger selection of other words. With lexical constraints 
that hold between two or more words, it is not critical which word is chosen first. 
Examples of such patterns of interaction are given in the following sections. 
2.5 A Simple Example 
To see how lexicalization works for our simple example sentence AI has six assign- 
ments, we will only consider semantic onstraints. The input specification received by 
the Lexical Chooser is shown in Figure 3. The conceptual representation in the in- 
put is encoded as an FD under the semr (SEMantic Representation) attribute. In this 
example, it is a simple encoding in FUF notation of a binary relation CLASS_ASSIGNT 
holding between two entities: the individual AI and the set ASSIGNT_SET1. The link 
between the arguments of the relation and its fillers is indicated by path values (of 
\[1\] and \[2\] respectively). In the matrix notation used here, we use a number in brack- 
ets (In\]) to both label a value and subsequently represent the path to that value. As 
the Lexical Chooser proceeds, it adds features to this feature structure, representing 
the syntactic elements of the clause that is to be produced. The output is shown in 
Figure 4. It consists of the input semr attribute nriched by a syntactic structure of 
category clause (cf. note 1) with lexical items specified for each linguistic onstituent 
(cf. note 3 and the features next to notes 4 and 5 of the figure). This output FD is then 
fed to the SURGE syntactic realization component, to eventually produce the expected 
sentence. 
In the architecture we are describing, the Lexical Chooser must meet the require- 
ments of the underlying application, which feeds it its input, on the one hand, and 
on the other hand it must produce an output acceptable by the syntactic realization 
component. The particular semantic features (name of the relations and of the argu- 
206 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
nt 
AI AI-assignt 
semr 
assignments 
class 
relation1 
cat set \] 
name assignt_setl 
\[1\] cardinality 6 
gen.ic l, \[co, as.gnm.., \] 
\[2\] name ai 
Figure 3 
Conceptual input to the Lexical Chooser in FD format. 
ments) are specific to the ADVISOR-II domain. The particular thematic roles found in 
the output are characteristic of SURCE. The mapping process is generic. 
The Lexical Chooser first traverses the input conceptual structure (which appears 
under semr) to decide what syntactic ategory will be chosen to realize it. In this case, 
the Lexical Chooser decides to map a semantic relation to a simple clause. This decision 
is done during phrase planning, a process we detail in Section 3. As the clause is being 
constructed, the feature (cat clause) is added (cf. Note 1 in Figure 4) and the syntactic 
structure of a clause is constructed. A clause skeleton is added to the top level of the 
FD (cf. notes 2, 4, and 5). 
Since the main verb has not yet been selected, the Lexical Chooser cannot proceed 
further and determine which participants (or verb arguments) will be inserted in the 
clause, and how they will map to the arguments of the input semantic relation. But the 
phrase planning component has already determined to use the main verb to realize the 
input relation. To represent this decision, the Lexical Chooser copies information from 
the top-level semantic representation in the semr feature under process (cf. note 2), thus 
indicating that the main verb maps to the semantic relation CLASS_ASSIGNT. This is a 
general feature of the technique: the Lexical Chooser incrementally builds a syntactic 
structure, and each time a new linguistic constituent is introduced, a subconstituent 
from the semr is copied under the semr of the syntactic subconstituent, representing the 
mapping between semantic and syntactic onstituents. This process is the generation 
counterpart of a compositional semantic interpretation. 
The next task of the Lexical Chooser is to select a word or phrase to realize the 
relation CLASS_ASSIGNT. The verb is selected by recursively unifying the process de- 
scription (including its newly assigned semr feature, cf. note 2) with a disjunction 
of the verbs stored in the lexicon. The relevant fragment of the lexicon is shown in 
Figure 5. 
The selected entry contains two types of features: syntagmatic (constraints on 
daughter nodes in the syntactic tree) and paradigmatic (choice of alternative lexical 
entries for the same node in the tree). 12 First the verb to have is selected (cf. note 3 
12 A generation lexicon is indexed by concepts instead of words. Each of its entries groups the alternative 
words to express a given concept. 
207 
Computational Linguistics Volume 23, Number 2 
semr 
cat 
process 
lex_cset 
% Tests 
assignments 
class 
\[1\]... %cf.Fig.3 
\[2\]... %cf.Fig.3 
% Relation1 is of type class-assignt. 
% It is mapped to the process of the main clause. 
\[ name \[3\] class-assignt \]
relationl argl \[1\] 
arg2 \[2\] 
% Enrichment: semr is mapped to a clause 
% of process type possessive 
clause 
cat semr name 
cat verb-group 
type possessive 
lex ,have It
class-relation 
\[3\] 
% Indicates the syntactic onstituents to be recursively lexicalized 
{.1 I l} 
participants 
% Clause complements 
'% Pointer to the semr subconstituent 
semr \[1\] 
possessor \[4\] 
% Linguistic features from the lexicon 
| cat proper 
L lex "AI" 
\[2\] 
np 
\[ cat noun \] 
lex "assignment" 
possessed no 
plural 
plural 
yes 
yes 
\[value 6\ ]  
semr 
cat 
head 
\[5\] definite 
number 
ref _number 
quantitative 
exact 
cardinal 
Figure 4 
Output from the Lexical Chooser. 
in Figure 4) as the default option for possessive verbs---English uses a possessive 
metaphor to refer to the link existing between a class and its assignments (a class 
"owns" the assignments). 13 As discussed below, this is a domain-specific decision that 
only applies to the particular elation CLASS_ASSIGNT. 
Once the verb class is known, the transitivity of the clause is determined, and 
the clause skeleton can be extended by specifying the verb's complements. In SURGE, 
possessive clauses expect two participants, named POSSESSOR and POSSESSED. The 
second part of the lexical entry therefore determines how the semr  features of the two 
syntactic participants are to be linked to the semantic arguments of the input semantic 
relation (in our case, this is done by the FUF pointers next to notes 4 and 5 in Figure 4). 
This mapping is domain-specific, and is completely contained in the lexicon en- 
13 Under different conditions, the Lexical Chooser could select one of the other verbs represented in the 
entry, such as to require or a construction such as in c lass ,  there is assignment. 
208 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
% First-level index: relation type is indexed by type of first argument. 
DEF-ALT RELATIONS 
: index (process emr cat) \[ \[s r \[cot c,os.e,otion \]\] \] 
| % This extends into the named alt 
| % class-relations below 
L :! CLASS-RELATIONS 
\[ process \[ semr \[ cat student_relation \] \] \] 
\[ :! STUDENT-RELATIONS 
? . .  Other types of relations . . .  
% Second-level index: relations by name. 
DEF-ALT CLASS_RELATIONS 
: index (process emr name) 
% For each type of class_relation, determine possible 
% lexicalizafion and its cat and identify sub-constituents 
\[class \ [1 \ ] \ ]  semr assignments \[2\] 
 oc ss \[s r \[nome css ssignt \]\] 
ALT ASSIGNMENrI~ 
: bk-class ao  
% Lexicalizations: C requires A, C has A 
% there is A in C, in C they do A 
% Branch 1: C requires A 
% Branch 2: C has A 
\[ type possessive \] process lex "have" 
% lex_cset declaration to handle recursion 
lcx_cset ( \ [3 \ ]  \[4\] ) 
possessee \[4\]\[sem~ \[2\]\] 
% Branch 3: In C there is A 
process \[ type existential \]
lex_cset ( \[5\] \[61 ) 
participants \[located \[5\] \[ semr \ [2 \ ] \ ] \ ]  
circumstances \[location \[6\] \[ semr \[1\] \] \] 
. . .  Other types of classmelafions . . .  
Figure 5 
Fragment of the lexicon for Verb selection. 
try for the domain relation CLASS_ASSIGNT. In contrast to previous lexical choice ap- 
proaches, such as Bateman et al (1990), we make no claims that the linguistic relation of 
possession used in this case is more general than the domain relation CLASS_ASSIGNT. 
That is, we do not attempt to fit each domain relation under a general ontology based 
on linguistic generalizations. Such fixed categorization of domain relations in effect 
prevents a generator from realizing the same domain relation at various linguistic 
209 
Computational Linguistics Volume 23, Number 2 
ranks and thus drastically reduces its paraphrasing power. 14 The only information this 
mapping encodes is that one option to lexicalize the domain relation CLASS_ASSlGNT 
in English is a possessive clause. 
At this point, the top-level unification of the input with the Lexical Chooser is 
completed. The intermediate FD corresponds to the features next to notes 1, 2, 4, and 
5 in Figure 4. The verb has been selected and the clause structure has been built. 
In order to continue the lexicalization of the arguments, the Lexical Chooser must 
specify which constituents in this FD require further processing. This is accomplished 
by adding a lex_cset (LEXical Constituent SET) declaration to the (lexical) FUG. The 
value of lex_cset is a list of pointers to the constituents of the FD as shown in Figure 5. 
Constituents bring structure to functional descriptions. 15 To handle constituents, the 
complete unification procedure implemented in FUF is: 
. 
. 
3. 
Unify top-level input with the lexicon (i.e., the single unification step 
described just above). 
Identify constituents in result (i.e., read the lex_cset attribute). 
Recursively unify each constituent with the lexicon. 
The lexical entry for an argument-bearing word (usually a verb) includes a lex_cset 
declaration. In the example, it specifies the two complements, POSSESSOR and POS- 
SESSED, each of which will eventually be realized as an NP. When this is the case, 
the head noun of the NP realizes the argument of the conceptual relation. When this 
argument is shared by other relations in the input conceptual network, those other 
relations are realized as nominal modifiers. Lexicalizing such complex NPs requires 
determining: 
? Which relations in the complex NP will appear as premodifiers and 
which as postmodifiers. 
? Which postmodifiers will be realized as prepositional phrases and which 
as relative clauses. 
? Selecting the features the grammar needs in order to select a determiner, 
if any. 
Details on how the linguistic features appearing under the NP constituents are 
selected are given in Elhadad (1993b, 1996). 
In summary, the Lexical Chooser proceeds as follows: 
. 
. 
A stage of phrase planning first processes the semantic input and 
determines to which syntactic ategory it is to be mapped. 
A skeletal FD for the selected category enriches the semantic input. 
14 Note that it is not the very idea of using an ontological upper-model that we criticize here (with all its 
advantages in terms of knowledge inheritance and reuse) but the use of the most common linguistic 
realization of each concept as the main criteria for classification. 
15 SURaE also uses the special feature cset to encode the surface syntactic onstituents of the sentence, 
following Kay (1979). Thus, two cross-cutting constituent s ructures, thematic and syntactic, can be 
represented in the same FD. SURCE ignores the lex_cset features and recurses according to the cset 
declarations. 
210 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
Figure 6 
IO(~ winner ~//team ~k 
Bulls Jazz Jazz-stmak~ 
(~ number 
3 
~ t  pr?gram~ ming 
y 
6 
Networks of semantic relations with shared arguments. 
. 
. 
. 
(a) 
(b) 
The head word for the linguistic onstituent is selected by looking up the 
semantic feature in (i.e., unifying the semr feature with) the lexicon. 
The lexical entry for the head word is responsible for: 
Providing a lexical item with its lexical features. 
Mapping semantic subconstituents to the complements of the 
head word. 
The lex_cset attribute triggers recursion on the immediate descendants of 
the linguistic head. The linguistic structure is therefore incrementally 
expanded as each head is lexicalized in turn. The FUF default control 
regime develops this structure in breadth-first order. 
3. Phrase Planning in Lexical Choice 
When the input semantic network contains more than one relation, the Lexical Chooser 
must decide how to articulate the different predicates into a coherent linguistic struc- 
ture. We refer to this stage of processing as "phrase planning" because of its close 
relationship to paragraph planning. In a simplistic generation system, all semantic 
relations would be mapped to clauses, while entity and set descriptions would be 
mapped to noun phrases. This strategy is not felicitous when dealing with multiple 
relations, as illustrated by the two examples whose inputs and corresponding alterna- 
tive outputs are shown in Figure 6 and Figure 7, respectively. 
If every relation is to be realized as a clause, then the only option for lexicalizing 
the relations 1 and 2 in Example 1 of Figure 7 is to generate two separate sentences 
as in (1), or to embed one of the relations as a relative clause modifier of the shared 
argument as in (2) or (3). Our corpus analysis (Robin and McKeown 1993), however, 
has shown that sentences in the basketball report domain tend to be more syntactically 
complex than sentences (1) to (3). Sentences (4) and (5) illustrate the type of complexity 
we found: the two semantic relations are merged into a single sentence, but the second 
relation is realized as a prepositional djunct of different ypes. Example 2, in the 
ADVI$OR-II domain, shows other options for realizing attached relations: as noun- 
noun modifiers (AI assignments) or premodifier (programming assignments). To account 
for this observed syntactic omplexity, the Lexical Chooser must be able to accept as 
input networks of several semantic relations, sharing certain arguments. The semantic 
networks corresponding to Examples 1, 2, and 3 are shown graphically in Figure 6. 
211 
Computational Linguistics Volume 23, Number 2 
Example 1 (left network of Figure 6): 
(1) Two sentences: 
The Jazz defeated the Bulls. 
They extended their winning streak to three games. 
(2) One sentence - beat as head - No lexical optimization: 
The Jazz who extended thei r winning streak to three games, defeated the Bulls. 
(3) One sentence - s t reak  as head - No lexical optimization: 
The Jazz who defeated the Bulls, extended their winning streak to three games. 
(4) One sentence - beat as head - With lexical optimization: 
The Jazz defeated the Bulls for their third straight win. 
(5) One sentence - s t reak  as head - With lexical optimization: 
The Jazz extended their winning streak to three games with a victory over the Bulls. 
Example 2 (right network of Figure 6, perspective alternation with fixed focus): 
(6) AI has six programming assignments. (perspective c lass_ass ignt ,  focus aI) 
(7) The six AI assignments require programming. (perspective ass ignt_type,  focus AI) 
Example 3 (right network of Figure 6, focus alternation with fixed perspective): 
(8) AI requires ix programming assignments. (perspective c lass_ass ignt ,  focus AI) 
(9) Six programming assignments are required in AI. (perspective c lass_ass ignt ,  focus 
assignt_set 1) 
Figure 7 
Alternative outputs for the input of Figure 6. 
3.1 Selecting the Head Relation and Building its Argument Structure 
The Lexical Chooser must first decide which relation to map to the main clause, and 
which one to embed as a modifier. 16 We refer to this decision as perspective selec- 
tion. The notion of perspective is related to the notion of focus as used, for example, 
in McKeown (1985). However, the perspective is a relation in the conceptual network 
whereas the focus is an entity. Once the perspective is chosen, focus can shift between 
the participants of a relation, by switching the order of the complements, as in sen- 
tences (8) and (9) of Figure 7. This is in contrast o sentences (6) and (7) in the same 
figure, where perspective switches from c lass_ass ignt  to ass ignt_type (with the fo- 
cus being the same). We have not investigated further which pragmatic factors affect 
the selection of perspective. Our research as focused on building into the Lexical 
Chooser the ability to realize any choice of perspective on the structures produced 
by the content planner. We thus assume that perspective is given in the input to the 
Lexical Chooser. Figure 2 shows in FD form the input the Lexical Chooser receives 
for the example that produces entences (6) to (9) (the network form for this input 
is shown on the right in Figure 6), depending on the values of the additional input 
features perspective and focus omitted in Figure 6. 
The ADVISOR-II system expects in its input up to four semantic relations, the 
highest number of relations that we observed expressed by a single sentence in our 
16 Note that while an object cannot in general serve as a verb, a relation can serve as clause, noun, and a 
variety of different modifiers. Thus, while we are restricted to selecting a relation as a main clause, we 
are not restricted inhow we do the mapping of other input relations to syntactic constituents. 
212 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
model corpus of advising dialogues. The clause planning process has two compo- 
nents: one, domain specific, maps from the domain relations to a clause structure, and 
one, generic, maps the clause structure to the appropriate types of syntactic modifiers 
(relative clause, prepositional djunct, adjectival premodifier, or noun-noun modifier). 
To explain this process, we will go through the clause planning of the example 
input shown in Figure 2 step-by-step. Assume that the content planner has decided 
the focus is on aI, and the perspective is on the c lass -ass ignt  relation. First, the head 
constituent of the linguistic structure is built from the description of the c lass -ass ignt  
relation. 
This mapping is shown in the top half of Figure 8. The left-hand side shows the 
conceptual structure that is the input to the Lexical Chooser. The right-hand side shows 
the linguistic structure that is constructed. At this stage, the conceptual relation that 
will be realized as the head has been selected (shown by the dotted line pointing to 
the node c lass-ass ignt)  and the Lexical Chooser has decided to use a process (i.e., 
ultimately a verb) to realize it. In addition, the ro les feature is added as a generic 
argument structure for the clause. The roles point to the appropriate arguments of the 
class-assignt (again, note the dotted lines to the nodes AI and AI-assignt). Note, 
however, that during this stage of phrase planning, neither the syntactic category 
nor the lexical head of the constituent are yet chosen. The input conceptual graph 
is merely transformed into a semantic tree. It is only during the subsequent stage of 
lexicalization (proper), when the specific verb (to have in this example), is selected. 17
In the implementation, generic roles (role1, role2) are used to point to the arguments 
of a process as long as the specific verb is not selected. They are mapped to clausal 
participants (e.g., CARRIER, ATTRIBUTE) only once the verb is chosen. 
3.2 Attaching the Remaining Relations as Modifiers 
The second step of the mapping is to map the second relation, assignt_type, onto 
modifiers of the arguments of the head clause. The assignt_type is mapped onto 
the modifier slot of the a t t r ibute  role of the head clause, when it is found that the 
assignt_type and class_assignt share an argument. 
This mapping is illustrated in the bottom half of Figure 8 for the example sentence: 
(5) AI has programming assignments. 
The modifier description has the same format as a clause in the linguistic structure. 
The process of the clause is mapped to the relation ass ignt - type and the process 
roles to the arguments of assignt-type.  This does not mean that the modifier will 
necessarily be realized by a clause as in the following sentence: 
(6) AI has assignments which involve programming. 
It can also be realized by an adjective or a noun. But these modifiers are analyzed as 
being derived from the relative clause construction using only linguistic derivations, 
following Levi (1978). Thus, sentence (5) above is analyzed as being derived from 
(6) by deletion of the predicate involve and migration of its object, programming, to a 
premodifier of the head assignments. 
Another option to attach a second relation is to add it as a separate clause to avoid 
deeply embedded structures. For example, the clause combination, sentence (7) below, 
17 The same process generalizes to the treatment of nominal heads. 
213 
Computational Linguistics Volume 23, Number 2 
AI ~class 
Al'assignt ~ -a-'ssig~n: , 
programming ( ~  activity 1 
I 
I 
\[ lex = "hale'__\]..~rrier 2~te  
\[lex="Al"\] ( == head X~lfler 
\[ lex = "assignment" \] / ~  2 identifier 
P7 roles -~  
deleted 1 ~) t  ified 
conceptual 
Figure 8 
Construction of a clause structure. 
\[ lex = "programming" \] 
linguistic 
is preferred over the embedded combination, sentence (8) below, because in the latter 
the relative clause is twice embedded: 
(7) Intro to AI has many assignments which consist of writing essays. 
You do not have experience in writing essays. 
(8) Intro to AI has many assignments which consist of writing essays in which you do 
not have experience. 
In summary, the first step of the mapping from conceptual network to clause is 
(1) to select a perspective among the conceptual relations of the network, which deter- 
mines a head clause, and (2) to attach the remaining relations as either embedded or 
subordinate modifiers of the head clause. The perspective is selected using focus con- 
straints; the choice between embedding or subordination is based on simple stylistic 
criteria. The output of this stage is a hierarchical structure where heads correspond to 
linguistic constituents of a given category (clause or NP), but where the lexical heads 
are not yet selected. 
These two operations constitute clause planning, similar to text planning at the 
paragraph level. A similar process for NP planning is described in Elhadad (1996). 
Once the head clause structure has been built, it is passed to the rest of the Lexical 
Chooser, which determines which syntactic forms can be selected for each modifier, 
when appropriate l xical resources are found. 
These operations of phrase planning are possible in this approach because the 
conceptual input is not already linguistically structured. Such planning is a major 
source of paraphrasing power, and since it is controlled by pragmatic factors (as ex- 
plained in Section 4) it also increases the sensitivity of the generator to the situation 
of enunciation. 
214 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
TAKE(S,C) 
S enjoy C 
INTEREST(C,S) / 
ASSIGNMENT(C,A) 
~____________~C ire A requ 
DIFFICULT(A,S) 
TAKE(S,C) ~ WIN(X,Y) 
DIFFICULT(C,S) / . . - -W"  S struggle with C LARGE(WIN) / " " "W~ 
Figure 9 
Merging two semantic units onto a single lexical item. 
X crush Y 
4. Cross-ranking and Merged Realizations 
The two structures that the Lexical Chooser has to match--a network of semantic 
units and a syntactic structure--are in general not isomorphic. This can be explained 
by two factors: a combination of semantic elements can be expressed by a single 
surface element, or a single semantic element by a combination of surface elements 
(Talmy 1985, 57). This non-isomorphism between syntactic and semantic structures i
a pervasive phenomenon, asillustrated by Talmy's extensive cross-linguistic analysis 
of constructions expressing motion and causation (Talmy 1976, 1983). 
This discrepancy between the structures of the input and output of the Lexical 
Chooser imposes two constraints: ince several semantic units can be realized by the 
same lexical item, the Lexical Chooser must be able to merge semantic units, and since 
the same semantic unit can be realized at different syntactic levels, the Lexical Chooser 
must be able to handle cross-ranking realization--that is, to dispatch a semantic unit 
from a given level in the semantic network onto several different ranks of the syntactic 
structure. 
An example of merging is provided by verbs that convey an evaluative connota- 
tion, as illustrated in Figure 9. TM Here, the verb enjoy, used in the student enjoyed the AI 
class, conveys two semantic units: 
The student took the AI class (a binary relation between the AI class and 
the student)2 9 
The student found the AI class interesting (an argumentative evaluation). 
By choosing a verb with connotations such as enjoy, the Lexical Chooser satisfies two 
input constraints at once. 
An example of cross-ranking realization is shown in Figure 10. All four sentences 
in this example convey similar information and satisfy the same argumentative intent: 
they evaluate the AI class as high on the scale of difficulty. The difference is that this 
evaluation is realized at four distinct syntactic ranks. 
In (1), the evaluation is realized by selecting the judgment determiner many and 
relying on the commonsense inference rule "the more assignments in a class, the more 
difficult it is." Here the Lexical Chooser decided to use the marked evaluative xpres- 
sion many instead of six to refer to the number of assignments. Judgment determiners 
include many, few, a great number of, etc. In (2), the use of a scalar adjective directly 
18 In which student, class, and assignments are abbreviated S, C, and A, respectively. 
19 We do not address the issue of deciding whether presupposed content units will be conveyed in the 
output. 
215 
Computational Linguistics Volume 23, Number 2 
. 
2. 
. 
4. 
Judgment determiner: "\[AI has many assignments.\]" 
Predicative scalar adjective: "\[AI, which is difficult, has seven 
assignments.\]" 
Connotative verb: "\[AI requires even assignments.\]" 
Argumentative connective: "AI is interesting but \[it has six assignments\]." 
Figure 10 
Cross-ranking ofargumentative evaluation. 
realizes the evaluative intention of the speaker. Scalar adjectives include difficult, inter- 
esting, important, etc. In (3), the choice of the connotative main verb require can also be 
related to the speaker's intention to evaluate AI as a difficult class. The verb to require 
merges the expression of the relation between the class and the assignments with the 
connotation that AI is difficult. In contrast, the verb to have only expresses the first 
semantic unit and does not have any connotation with respect o difficulty. 
Finally, in (4), the argumentative connective but projects an evaluation on the 
clauses it connects in an indirect way. The clause AI has seven assignments i not eval- 
uative taken alone; but when it is contrasted with the first evaluation AI is interesting 
by way of a but, it becomes an argument that must be opposed to interesting, and 
the whole sentence supports this second argument. In this case, the speaker elies 
on two commonsense rules that predict hat (a) the more a course is interesting, the 
more a student wants to take it and (b) the more a course is difficult, the less a 
student wants to take it. Such common sense relations are called topoi by Ducrot 
(Anscombre and Ducrot 1983). The modeling of argumentative evaluation using topoi 
for text generation is described in detail in Elhadad (1995). 
In summary, the same content unit--the valuation of the class of AI on the scale of 
difficulty--can be realized by very different linguistic devices: connective, main verb, 
noun modifier, and determiner sequence. We use the term floating constraints to de- 
scribe input constraints such as evaluations, which can be realized at different syntactic 
levels. Figures 11 and 12 show how these floating constraints are distinguished from 
structural constraints such as semantic predications. Structural constraints require the 
presence of syntactic onstituents at a given linguistic rank in the output and thus 
guide the structural mapping process from the conceptual network to the thematic 
tree. For example, when the input relation STUDENT-CLASS is mapped to a clause, the 
predicate to take determines how the arguments of the relation are mapped onto the 
thematic roles of the clause: STUDENT to AGENT and CLASS to RANGE. In contrast, float- 
ing constraints are conveyed by either semantically richer wordings for the obligatory 
constituents introduced by the structural constraints (e.g., in Figure 12 changing the 
verb to have into to require or the determiner six into many to add the evaluation of AI 
as a difficult class) or by optional constituents (e.g., in Figure 12 the connective but or 
the qualifier difficult). 
Both merging of semantic units in a single site and cross-ranking ofa single seman- 
tic unit to different syntactic sites, are found in other domains as well. For example, in 
the basketball domain, the semantic unit describing a game result (victory or defeat) 
can be merged with an evaluation of the ease or the predictability of the result in 
verbs like to outlast, to crush, to surprise, etc. as shown in Figure 9. Similarly, the phe- 
nomenon of cross-ranking is not restricted to evaluative connotations. For example, in 
216 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
\[Relation = student-dass\] \[cat = clause\] 
C- -~ ~N~-- - - - -  : - - -~  . . . . . . . . . . . . . . . . . .  ~ ' (~ participants 
class/ ~studen, "take" /~  
/ ~ agent/ 
Figure 11 
Structural constraint. 
\[cat complex-clause\] 
connec~ve~~rective 
I . . . . " " proc 7 ~cipants 
. - " / ' "  . . . . . . . . . . . . . . . . . . . . . . . .  > 0 ( 3  
-<~2 llex="require"\] / ~  
:: . . . .  7 T 
-.. \[lex = "difficult"\] \[/ex = "many"\] [lex ="~lgm~ent~"l 
". . . . . . . . . . . . . . . . .  .)~ 
Figure 12 
Floating constraint. 
the following sentences taken from stock market reports (Kukich 1983b; Smadja 1991), 
the semantic unit expressing the time appears as a floating unit at different syntactic 
levels: 
? Stock prices got off to a strong start. \[time in both (prepositional) verb 
and object\] 
? Wall Street Indexes opened strongly. \[time in verb only\] 
? Stock indexes surged at the start of the trading day. \[time in adjunct\] 
Thus, this phenomenon is a pervasive aspect of lexicalization. The need to perform 
cross-ranking realization and to deal with floating constraints requires that the input 
to the generator be neutral to linguistic form. This is in sharp contrast with previous 
generators (Meteer et al 1987; Bateman et al 1990), whose input already determines 
linguistic structure (e.g., semantic relations are always realized as clauses, and individ- 
uals always as noun phrases). The distinction between the structure of the conceptual 
input and the linguistic structure used to realize it implies that the Lexical Chooser 
must not only perform paradigmatic hoices (select among substitutable items, e.g., 
between require and necessitate), but also syntagmatic choices (determine the linguistic 
217 
Computational Linguistics Volume 23, Number 2 
structure corresponding to a given input specification, e.g., select between a clause 
and a nominalization, determine which construction will realize an evaluation). In 
previous work, these structural decisions were made imphcitly at the content deter- 
mination stage, when building the input to a text generator, and usually were done 
through hand-coding. In this section, we show how these decisions can be made by 
the Lexical Chooser in an efficient way. 
4.1 Merging of a Conceptual Unit with an Argumentative Evaluation 
We first illustrate the implementation f floating constraints in a Lexical Chooser taking 
as example the merging of a conceptual unit with an argumentative evaluation. 
Consider the task of mapping an argumentative evaluation onto a simple clause. 
In this simple example, the input is made up of two semantic units: a conceptual 
relation, e.g., c lass_ass ignt  (ass ignt_set l ,  a i )  and an argumentative evaluation, 
e.g., eva l (a i ,  d i f f i cu l ty ) .  For this example, we will restrict the available sites in 
the syntactic lause capable of realizing the evaluation to be: the main verb, modifiers 
of the NP realizing the class (i.e., premodifying adjective or relative clause), and the 
determiner sequence. 2? 
The input description for this configuration of semantic units is shown in Fig- 
ure 13 both graphically and as an FD matrix. In the graphical representation, argu- 
mentative valuations are represented as wavy lines, and semantic predications as 
straight lines. The dotted line indicates that the two evaluations (many assignments 
and difficulty) are part of an argumentative rule--a topos--which reads: the more a 
class has assignments he more difficult it is. In the FD matrix, the evaluations and the 
conceptual relations are represented under two separate top-level features of the input 
semr ( f loat ing  and s t ructura l  respectively). This representation does not commit he 
Lexical Chooser to map the evaluations to any particular site a priori--highlighting 
the floating nature of evaluations. 
Therefore, one of the tasks of the Lexical Chooser, is to decide to which node in 
the linguistic tree the argumentative evaluations will be attached. In the overall flow 
of control followed by FUF (discussed in Section 2.5), semantic relations are mapped 
onto a linguistic tree, which is expanded top-down, breadth-first. So the decision to 
attach an evaluation at a given node in the linguistic structure must also be made 
top-down. This order of decision making is shown in Figure 14 and is followed as the 
clause structure is constructed. 
At each stage of this traversal, the Lexical Chooser checks whether there is lexical 
material available in the lexicon to realize the evaluation at the specified syntactic 
level. For example, at the verb level, the Lexical Chooser checks whether there exists a 
verb that expresses the c lass_ass ignt  relation and has for connotation that the c lass  
argument is difficult. In this case, the verb require can be selected. If, however, the 
evaluation was on the scale of interest, no appropriate verb could be found (there 
is no verb expressing both that a course is interesting and that it involves certain 
assignments). At the NP level, the Lexical Chooser would then check whether there 
exists a scalar adjective that can realize the evaluation. 
20 In the implementation f ADVISOR-II, the Lexical Chooser also considers as potential sites connectives 
and indirect argumentative evaluations--i.e., relying on a topos relation of the form "the more a class has 
assignments, he more difficult it is," one can realize the evaluation of a class as difficult by evaluating 
as large the set of assignments i  requires. In that case, a modifier of the NP assignments realizes the 
evaluation on the entity class. 
218 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
N Class-assig nt 
+ . . . . . . . . .  + 
cardinality difficulty 
semr 
floating 
structural 
% Evaluative Relation 
cat topos 
scale 
left orientation value 
evaluated 
scale 
right orientation value 
evaluated 
6cardinality-I- \] 
\[11 
difficulty++ \] 
\[2\] 
% Objective relation: AI has 6 assignments 
cat set \] 
assignments \[1\] cardinality 6 
generic_elt \[cat assignment \] 
class \[2\] name ai 
I assignt \[11 relationl args class \[2\] 
Figure 13 
Lexical Chooser input for one semantic unit and one floating constraint. Example of 
corresponding output sentence: AI has many assignments, soit is difficult. 
can the evaluation be ~/ /~? Is there an appropriate connotative verb? 
expressed at the clause level? 
Is there an appropriate adverbial? 
Is there an appropriate pre-modifying 
can the evaluation be ~ adjective? 
expressed at the NP level? 
I Can an evaluative relative clause be added? 
I can the evaluation be Is a judgment determiner appropriate? 
expressed at the determiner level? 
Figure 14 
Order of decisions during top-down traversal for mapping argumentative evaluations. 
The way  these decisions are imp lemented  in FUF is shown in Figures 15 and 16. 
The overal l  process is shown in Figure 15: the Lexical Chooser  first tries to attach the 
219 
Computational Linguistics Volume 23, Number 2 
Input semantic net: 
\[ \[structural I0 = semr floating 
has been packaged as follows by the phrase planning branch: 
... %cf.Fig.13 .%cf.Fig.13 \] \] 
11 = 
process \[ semr ... \] 
roles \[ 1 \[ semr \[1\] %Understructural \] \] 
2 \[ semr \[2\] % Under structural \]  
ao \[ sem r \[3\] % Under floating \] 
CONJ LEX-CLAUSE 
cat 
process 
ALT MAP-AO-CLAUSE 
:bk-class ao 
% At the top-level of the clause, AO can be mapped to: 
% (1) Verb with connotation 
% (2) An adverbial 
% If no lexical resource is found at this level: 
% Try to attach AO at another level 
% Branch 1: No AO specified in input - nothing to do 
\[ao NONE \] 
% Branch 2: Attach AO down to verb 
\[ ao \[4\]GIVEN \] 
process \[ao . \[conveyed proc s \]\] 
% Branch 3: Attach AO to adverb 
ao \[5\] GIVEN \] 
adverb \[ ao \[5\]\[ conveyed adverb \] \] 
% Branch 4: Delegate AO to other constituents 
\[ ao GIVEN \] 
ao \[conveyed ANY \] 
clause 
\[cat verb_group \] 
:! roles 
Figure 15 
Lexicon fragments mapping a floating constraint at the clause level. 
element expressing argumentative evaluation 21(A0 attribute in the figure) to an appro- 
priate constituent (in the map-ao-clause alt). Then the regular structural constraints 
are dealt with (in the ro les  alt). The map-ao-clause alt implements the following 
algorithm: if no AO is specified in the input, nothing needs to be done (first branch). 
Since unification is bidirectional, a feature \[a v\] in a grammar branch can be either 
a test for the presence of the feature or the instruction to enrich the input FD with 
that feature if it is not present. The FUF keyword given is used to specify that the 
feature is intended only as a test. If an AO is specified, then it can be attached either 
21 More often known as speaker intention or goal. 
220 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
In the context of I1 in Fig. 15 for the reference to \[1\] and \[2\]: 
DEF-ALT ASSIGNMENTS 
: bk_class ao 
% Branch 1: C requires A - Argumentative evaluation 
attributive 
"require" 
GIVEN % Only if ao is specified in input 
process 
type 
lex 
ao 
evaluated 
scale 
ao conveyed 
orientation 
( .I > 
carrier \[41\[ semr 
\[5\] \[ semr attribute 
lex_cset 
participants 
\[i\]name "difficulty"\]\] 
verb_level 
+ 
.1\]\] 
\[21 \] 
% Branch 2: C has A - no AO connotation 
\[ type possessive \]process lex "have II 
% lex_cset declaration to handle recursion 
lex_cset ( \ [6 \ ]  \[7\] > 
\[ possessor \[6\]\[ semr \[1\] \] \] 
participants 
possessed \[7\]\[ semr \ [2\] \ ]  
% Branch 3: In C there is A - no AO connotation 
process \[ type ex/stential \] 
tex~set ( \[SJ \[91 ) 
participants \[ located \[8\]\[ scmr \[2\] \] \] 
circumstances \[location \[9\]\[ semr \[1\] \] \] 
Figure 16 
Three alternative lexical entries satisfying an AO constraint. 
on the process (branch 2) of the clause, or as an adverbial (branch 3). In last recourse, 
it can be "delegated" to another lower-level constituent (brafich 4). Note that at this 
level of processing, the Lexical Chooser does not yet know whether appropriate lexical 
material will be found to satisfy the constraint of expressing the AO connotation. For 
example, when deciding to try branch 2, we still do not know whether an appropriate 
verb will be found. So we just try to attach the AO at a certain level, and wait until 
the Lexical Chooser arrives at the level of the verb in its traversal of the constituent 
tree to verify whether our decision was justified. This is the equivalent of a prediction 
step in a top-down parsing algorithm. 
In the end, we must find an appropriate lexical element that will satisfy the re- 
quirement to express AO. Such an element is shown in Figure 16. It is the lexical 
entry for the semantic relation assignments, which holds between a class and its as- 
signments. Three options are listed to realize this relation: c lass  require assignment, 
c lass  have assignment and in c lass  there is assignment. Only the verb to require con- 
veys an argumentative valuation (that the class is difficult). When it is selected, the 
feature \[\[ao \[\[conveyed verb - level\]\]\]\] is added--which signals that the AO is effectively 
expressed at the verb level. 
In summary, the process develops as follows: at the clause level, choose a site for 
the AO. Here we committed AO to the verb by copying the feature AO from the clause 
221 
Computational Linguistics Volume 23, Number 2 
level under the process constituent, with the feature conflation: 
ao \[4\]GIVEN \]
process \[ ao \[4\]\] 
Then proceed with regular structural traversal of the constituent tree: process, argu- 
ments, then under process, verb. At the verb level, we look up the lexicon for an appro- 
priate entry to realize the process. In this case, the process is already enriched with a 
copy of the AO annotation. So we select he verb to require, which satisfies this request. 
The AO constraint is thus satisfied, and the \[ao conveyed\] feature is instantiated--which 
means that the AO constraint is satisfied. 
Now, imagine that no lexical entries were found to express the AO constraint, 
neither at the verb level, nor at the adverbial level. In this case, the AO constraint must 
be mapped own to an NP participant of the clause. The mapping inside the NPs is 
not described in the map-ao-clause alt, because, at this level, the Lexical Chooser has 
no knowledge of which NPs will be added to the syntactic structure. Instead, the AO 
constraint is simply delegated to another constituent. When a new NP constituent is 
constructed by the Lexical Chooser, the alt map-ao-np will perform a function similar 
to map-ao-clause but within the NP. 
At the clause level, the delegation is encoded using the feature: 
\[ ao \[ conveyed ANY\] \] 
The aNY feature is a powerful construct of FUF that imposes that a feature be instan- 
tiated at the end of the unification process. Because unification is order-independent, aNY
constraints can only be checked after the entire grammar has been traversed at all the 
levels. In our example, 
\[ ao \[ conveyed ANY\] \] 
declares that AO must eventually be instantiated toa ground value---that is, that some 
lexical element has finally taken the responsibility of expressing the AO. 
If we look back at the flowchart in Figure 14, we see that the algorithm just 
described eterministically maps the AO to the first slot found in the constituent tree 
that can account for it. We discuss in the next section how to add variety to this 
decision and allow a nondeterministic selection of the AO realization site. 
4.2 BK-CLASS: Smart Backtracking for Efficient Cross-ranking Realization 
The process just described is a search process where the Lexical Chooser tries to find 
an appropriate site for the realization of a floating constraint. This search is not tightly 
constrained, since, for example, at the clause level, the Lexical Chooser maps the AO 
feature to different sites without knowing in advance whether the sites are capable 
of handling it. For example, the AO element is first tentatively mapped to the verb, 
without knowing whether an appropriate connotative verb will eventually be found. 
On the other hand, the construction of the linguistic structure depends on this 
mapping; for example, if the argumentative evaluation is mapped to a qualifier, an- 
other type of semantic element will not be mapped to the same site. 22 Thus, it is not 
possible to first build the whole linguistic structure ignoring the AO constraint and 
then subsequently examine which sites are available for the AO. 
22 Here, we assume a simplistic stylistic onstraint of limitating the number of postmodifiers to one. 
222 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
In summary, the problem of finding an appropriate site to attach a floating con- 
straint is inherently a hard search problem, which cannot be handled efficiently by 
straightforward search techniques. Additional knowledge must be added to control 
the search and make it efficient. In this section we introduce bk-class, a control tool 
implemented in FUF, which reduces the search space in a significant way and makes 
the implementation f such lexicalization tasks practical. 
A version of dependency-directed backtracking (de Kleer et al 1979), bk-class is 
specialized to the case of FUF. The bk-class construct relies on the fact that in FUF, 
a failure always occurs because there is a conflict between two values for a certain 
attribute at a leaf location in the input FD, as already enriched by some features 
from the FUG at the point of failure within the recursive unification process. In our 
example, backtracking is triggered by the requirement that the value of the subattribute 
conveyed of the attribute ao be instantiated, when the actual subattribute is not. The 
path {A0 conveyed} defines the address of the failure, i.e., the only decision points 
in the backtracking stack that could have caused the failure. Identifying the address 
of a failure requires additional control knowledge that must be declared in the FUG. 
More precisely, we allow the FUG writer to declare certain paths in the FUG to be of 
a certain bk-class. We then require the explicit declaration i  the FUG of the choice 
points that correspond to this bk-class. In such cases, the writer must realize that 
the decisions within the class are interdependent, but she need not have knowledge 
of which one is most likely to succeed. 
For example, the statement: (def ine-bk-class A0 conveyed) specifies that all 
paths ending with the attribute conveyed are of class AO. In addition, we tag in the 
FUF program all alts that have an influence on the handling of the AO constraint with 
a declaration ( :bk-class A0) as shown in Figures 15 and 16. 
To illustrate how bk-class helps in dealing with floating constraints, consider 
again the require example discussed in the previous ubsection. In the lexicon frag- 
ment of Figure 15, costly backtracking is avoided by forcing a fixed order for the 
consideration of the possible sites to express the AO: first verb, then adverb, and fi- 
nally argument NP. Also the alternative option of a separate clause is not considered. 
To overcome the limitation of this deterministic site selection for the AO attach- 
ment and allow a variety of possible outputs, we can force a random selection in the 
a l t  map-A0-clause of Figure 15. This is achieved by adding an (:order :random) 
annotation to the a l t  map-A0-clause, which becomes: 
(def -a l t  map-ao-clause (:bk-class A0) (:order :random) . . . )  
With this annotation, FUF nondeterministically chooses one of the four branches of 
the disjunction. In this manner, the algorithm shown in Figure 14 is not performed in 
a fixed order. As a consequence, the Lexical Chooser can map the AO evaluation to a 
noun modifier, even though it was possible to merge it into the verb--producing either 
AI requires six assignments or AI, which is difficult, has seven assignments. In the Lexical 
Chooser of ADVISOR-II, the AO mapping mechanism also interacts with the phrase 
planning component and maps the AO to a dedicated evaluative clause--producing 
in our example the complex clause AI has seven assignments; therefore it is difficult. A 
random selection among these options adds significantly to the variety of possible 
outputs. 
This randomization can also lead to computationally expensive dead-ends. The 
AO mapping grammar describes three possible attachment sites for AO, leading to 
the sentences: 
? AI requires ix assignments. 
223 
Computational Linguistics Volume 23, Number 2 
? AI, which  is difficult, has six assignments. 
? AI has six assignments; therefore it is difficult. 
If one of these sites is not available, another one must be chosen. Unfortunately, it 
can take time to realize that a given site is not available. The possibilities are outlined 
below. 
? Case 1: all sites available: all three sentences can be generated. 
? Case 2: the NP site is not avai lable because another modifier must be 
attached to the same NP. This would occur, for example, in sentences 
like AL which is taught by Smith, has six assignments. 
? Case 3: the verb site is not avai lable because there is no connotative 
verb that simultaneously conveys the structural relation and the AO 
evaluation. This would occur, for example, in sentences like AL which is 
difficult, deals with some mathematical topics, since there is no English verb 
that expresses the relation "deal with" together with a connotation of
difficulty in the domain sublanguage of ADVISOR-II. 
? Case 4: both the verb site and the NP site are not  avai lable (the 
combination of case 2 and 3 above): only a complex clause can be 
generated. 
The problem is that at the time the map-ao-clause disjunction is traversed, we do 
not yet know whether the corresponding sites are available. The following scenarios 
illustrate how the late detection of availability can lead to a prohibitive search time: 
? Case 1: All sites available. The order in which map-ao-clause is 
traversed etermines which sentence is generated. No price is paid 
computationally, since all choices lead directly to an acceptable 
configuration. 
? Case 2: NP site not available---Verb site tried first in map-ao-clause.  In 
this case again, there is no time wasted, the Lexical Chooser "guesses" 
right the first time. 
? Case 3: NP site not avai lable - NP site tried first. In this case, the 
Lexical Chooser goes the wrong way and must backtrack. Backtracking 
is triggered only when the 
\[ ao \[ conveyed ANY\ ]  \] 
constraint is checked, which is at the end of the unification process. This 
means that full lexicalization of the input is performed--ignoring the AO 
constraint--and at the end, a failure is discovered. Using a simple 
chronological backtracking control, such a late failure is the worst 
possible scenario. All possible options starting at the wrong guess in 
map-ao-clause are systematically explored, until finally, the 
raap-ao-clause choice point is tried again, leading to an acceptable 
sentence. 
224 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
D 
e 
c 
i 
S 
i 
O 
n 
M 
a 
k 
i 
n 
g 
I Lexicalize ASSIGNMENT relation I
Figure 17 
Backtracking and BK-CLASS. 
Map AO constraint 
I Choose verb site - Delay \[ANY\] 1 
I Map args to complements 1 
Processall ( 
subconstituents 
> < 
Check ANY: 
AO IS NOT CONVEYED 
B 
a 
c 
k 
t 
r 
a 
c 
k 
i 
n 
g 
Case 4: Two sites (verb and NP) not ava i lab lemboth  tried before the 
complex clause option. The scenario is the same, except hat when 
backtracking reaches the map-ao-clause, it starts once more with a 
wrong guess, and the same wasteful search is triggered. 
The bk-c lass construct solves this problem efficiently by jumping back directly to 
the map-ao-clause when the ANY failure is detected at address {ao conveyed}. This is 
possible only if the grammar writer has declared the map-ao-clause as a choice point 
of class a0. Figure 17 illustrates the search process, and how bk-c lass affects it. When 
the unifier fails at a location of class A0, it directly backtracks to the last choice point 
of class a0, ignoring all intermediate decisions. 
In our example, when the ANY constraint fails, we directly backtrack to the last 
AO choice point encountered, which was in the map-ao-np disjunction. If no other 
option is left in the NP, we backtrack up to the alt map-ao-clause of Figure 16. We 
therefore use the knowledge that only the verb, the NP, or an additional clause can 
satisfy the AO constraint in a clause to drastically reduce the search space. Thanks 
to the bk-c lass construct, this knowledge is locally expressed at each relevant choice 
point, retaining the possibility of independently expressing each constraint in the FUF 
program. 
To evaluate the practical effect of bk-class, we have measured the number of 
backtracking points required to lexicalize different clauses illustrating the scenario 
discussed above. Table 1 summarizes these measurements, performed on the lexical 
chooser for ADVISOR-II. 
225 
Computational Linguistics Volume 23, Number 2 
Table 1 
Measuring the effect of bk-class. 
Backtrack points 
Input Output w/o bk w/  bk 
All sites available AI requires ix assignt. 46 46 
AL which is hard, has six assignt. 59 59 
AI has six assignt., therefore it is hard. 189 189 
Verb unavailable 
NP site tried first 
two clauses tried first 
Verb site tried first 
NP unavailable 
NP site tried first 
NP and verb unavailable 
two clauses tried last 
AL which is hard, deals with math. 
AI deals with math, therefore it is hard. 
AI, which is hard, deals with math. 
58 58 
59 59 
8,379 86 
AL . . . .  requires ix assignt. 10,546 124 
AI, . . . .  deals with math, therefore it is hard. 15,580 128 
AL . . . .  has six assignt., therefore it is hard. 22,719 189 
The number of backtracking points required to lexicalize ach example clause is 
listed with and without bk-class. The first group, with all sites available, indicates 
the size of the lexicon. The numbers can be interpreted as the number of decisions the 
Lexical Chooser makes to lexicalize abasic clause for which practically no backtracking 
is required. It roughly corresponds to the number of unretracted decisions made by 
the Lexical Chooser and is the optimal number of backtracking points that a search 
control regime can obtain for the given input. Without bk-class, the wide variation in 
number of backtracking points among the examples indicates the exponential nature 
of the blind search that floating constraints impose on the standard control regime. 
In contrast, with bk-class, the variation in number of backtracking points remains 
within a factor of three among all the examples. 
The dependency-directed mechanism implemented in FUF with bk-class therefore 
complements a general top-down control regime to make the processing of floating 
constraints efficient. The performance penalty imposed by a floating constraint de- 
pends on the number of sites in the syntactic structure where it can be realized. For 
example, the AO constraint can be realized at three levels and it may require the uni- 
fier to retraverse the same FUG branches three times until it finds a site to convey the 
AO constraint. Each floating constraint can be characterized by its range of possible 
attachment odes. 
The bk-class mechanism improves the efficiency of functional unification while 
preserving its desirable properties--declarativeness and bidirectional constraint satis- 
faction. It is a declarative statement ofdependency between a decision in the FUG and 
a class of constraints in the input. Using bk-class, however, is not always easy for 
the FUG writer since it requires thinking about he control strategy of the unifier--the 
same drawback as for PROLOG'S cut  mechanism. We are currently investigating the 
use of abstract interpretation techniques (Cousot and Cousot 1977) to automatically 
determine where bk-class annotations are necessary and thus ease the task of the 
programmer. 
5. Interlexical Constraints 
Interlexical constraints occur when a pair of content units is realizable by alternative 
sets of collocations (Smadja nd McKeown 1991). This is the case, for example, in the 
226 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
following situation: 
? A domain relation R is realizable by two verbs V1 and V2 
? A domain entity E is realizable by two nouns N1 and N2. 
? <V1,NI> and (V2,N2) are verb-object collocations. 
? (V1,N2) and <V2,N1) are not verb-object ollocations. 
We observed the influence of interlexical constraints in our corpus of newswire 
basketball reports used in developing STREAK. The act of performing strictly better 
than ever before can alternatively be lexicalized by the collocations to break a record 
or to post a high. However, even though the elements of the collocation are dependent 
on different portions of the input network, they are not interchangeable. One can 
say neither ?to break a high nor ?to post a record. For other relations, the words are 
interchangeable; forexample, one can say either to equal a high or to equal a record. 
The input for these collocations i shown in Figure 18. It includes two relations: 
performance(player, statistic) and improve(performance, maximum), which in- 
dicate that a player's performance improves some previously set maximum. The verb 
of the collocation realizes these two semantic relations, such as to break or to post simul- 
taneously indicating (I) a relation between a player and one of its game statistics and 
(2) that this statistic is strictly higher than some previous maximum. If, in contrast, the 
statistic was even with the previous maximum, then the verb equal or match would be 
selected instead. Whether the object is high or record depends on the type of maximum. 
In this domain, a maximum can occur for a variety of different reference sets. It can 
be a maximum for a player, for a team, or for a league. The noun high is used when 
the performance is a maximum of past performances by the same player while record 
is used when it is maximum over past performances of other players as well. 
These semantic onstraints on individual word choice are orthogonal to the inter- 
lexical constraints between verb and object. It is possible, therefore, to encode interlex- 
ical constraints in various locations in the Lexical Chooser. One possibility is to encode 
the verb-object ollocation with the lexicalization options for the predicate. This means 
that both the lexicalization of the predicate and that of its collocationally constrained 
argument are chosen all at once. Such simultaneous choices hinder the modularity of 
the Lexical Chooser and declarative r presentation f individual constraints. With this 
organization, the choice of verb must be indexed by the semantic onstraints from the 
arguments even though these constraints do not directly influence predicate choice. 
Furthermore, if this constraint is encoded in the lexical entry for the predicate, it will 
have to be repeated for the other domain relations that can take the same concept 
as an argument, such as equal. This is undesirable since the verbs for lexicalizing 
this relation are not collocationally restricted, as indicated by the validity of all the 
following forms: to equal a high, to match a high, to equal a record, to match a record. 
A second possibility is to represent the semantic onstraints on verb and noun 
choice separately; where there are several possible verbs for a given semantic on- 
straint, the verb is chosen randomly. The collocational constraints between verb and 
noun are represented with the noun in this scheme. In this case, modularity in the 
representation f individual constraints i preserved. Semantic onstraints on the re- 
spective lexicalizations of the predicate and its argument are independently encoded. 
However, the orthogonal interlexical constraint can trigger backtracking: for example, 
if the verb to break is first randomly chosen for the relation improve and then the noun 
high gets selected because the input indicates the player as the reference set for the 
maximum concept, the Lexical Chooser must backtrack to select he verb post instead. 
227 
Computational Linguistics Volume 23, Number 2 
semr 
structural 
floating 
% Relation 1 marked as structural by the content planner 
% Stockton scored 45 points 
name performance 
\[cat p layer \ ]  
actor \[1\] name Stockton 
relation1 surname John 
perf \[2\] value 45 
unit points 
% Relation 2 marked as floating by the content planner 
% This performance improves Stockton's maximum 
relation2 args past_perf \[3\] 
\[\] 
% Past performance that the new performance \[2\] improves: 
% Maximum of the set of all scoring+ performances scored by Stockton 
cat maximum 
cat set 
ref _set generic_elf actor \[1\] cat statistic 
perf unit points 
Figure 18 
Test input for the sentence John Stockton posted ahigh with 45 points. 
In order to both preserve modularity and avoid backtracking, the solution is to de- 
lay the choice of one collocate until the other one is chosen. We have implemented this 
in FUF through a control mechanism termed :wait, which allows explicit representa- 
tion of the interlexical constraints along with modular epresentation f the individual 
semantic onstraints on word choice. The :wait mechanism is used to indicate that 
a particular choice should be delayed until some other specific choice point in the 
grammar. Again, the grammar writer must know that the two decisions are interde- 
pendent, but does not need to know which one will take priority. Here, the choice 
of verb is delayed until the head of the object is selected. Figure 19 shows how the 
:wait annotation of FUF implements such a delay. In this case, the choice of verb is 
suspended until its object noun collocates have been chosen. Therefore, no backtrack- 
ing occurs even though the respective semantic onstraints on the lexicalization of 
the predicate and its argument are kept separate. The :wait annotation is a general 
control facility that allows optimizing a FUG whenever it is known that two decision 
classes are dependent on one another. The case illustrated in this paper, where these 
two decisions classes are verb choice and object head noun choice, is only one of the 
many types of optimizations made possible by the use of :wait (see Elhadad \[1993c\] 
for other types). 
6. Other Approaches to Lexical Choice 
6.1 FUF-based Systems 
In this section, we present four applications, developed at Columbia, which use FUF 
for lexical choice. The first two use a very similar approach to ADVISOR-II, while the 
last two incorporate the same model within distinct system architectures. 
228 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
DEF-ALT LEX_SCORE 
% Branch 1: . . .  
% Branch 2: Verbs merging a PERFORMANCE structural relation 
% and an IMPROVE floating relation 
% Unifies with result of clause planning on input of Fig.18 
process \[semr\[nameperformance\]\] 
roles perf \[1\] GIVEN 
floating GIVEN 
\[ Process i semr \[ name improve \] \] i \] 
floating new_perf \[1\] 
roles oldqoer f \[cat maximum \] 
:! IMPROVE-MAX_VERBS 
DEF-ALT IMPROVE_MAX_VERBS 
% Choice of verb delayed until object is lexicalized : order random 
wait ( participants affected head lex \ / 
% Purely lexical test since done when object noun already chosen 
% Branch 1: break a record 
process \[ lex "break" \] 
affected head \[ lex "record"\]\] 
% Recurse on both arguments 
lex_cset < \[\]  \[ \]  > 
% Branch 2: post 
process 
participants 
lex-cset 
a high 
\[ lex "post" \] 
agent \[3\] 
affected \[4\]\[ head \[ lex 
% Recurse on both arguments (L31 t4\]> 
"high"\]\] \] 
"DEF-CONJ LEX-MAX 
semr \[cat maximum\] 
cat np 
ALT SEMANTIC-CONSTRAINT-ON-NOUN 
% Choose noun for max. with no reference to embedding verb 
% Branch 1: record 
\[ semr \[ ref.set \[ generic_elt \[ actor \[cat{teamleague} \] \] \] \] 
head \[ lex "record" \] 
% Branch 2: high 
\[ semr \[ ref~set \[ generic_elt \[ actor \[catplayer\] \ \] \] \] 
head \[ lex "high"\] 
Figure 19 
Use of :wait to preserve modularity and avoid backtracking. 
229 
Computational Linguistics Volume 23, Number 2 
6.1.1 Systems with Similar Architectures. Two applications developed at Columbia 
use FUF for lexical choice in much the same way as ADVI$OR-II: COMET (COordinated 
Multimedia Explanation Testbed) (Feiner and McKeown 1990; Elhadad et al 1989) 
and PLANDOC (McKeown, Robin, and Kukich 1995). These systems are more limited, 
however, in that they do not handle floating constraints, and thus lexical choice consists 
of a one-to-one mapping between conceptual nd linguistic structures. This mapping 
focuses on the paradigmatic decisions and can be efficiently performed using the 
simple default op-down regime of recursive unification. But in effect, this shifts the 
burden of performing most syntagmatic decisions to the Content Planner, which must 
then hand to the Lexical Chooser a tree-structured input that already prefigures the 
(lexicalized) thematic tree that the Lexical Chooser in turn passes on to SURGE. 
In COMET, a system which generates multimedia explanations for equipment main- 
tenance and repair, the major research focus is the co-ordination of multiple media 
and some word choices are influenced by decisions made by the graphics component. 
For example, to determine how to refer to an object in an accompanying illustration, 
the Lexical Chooser takes into account how the object is depicted (McKeown et al 
1992). COMET also considers constraints from the user and from previous discourse 
in selecting words. This case has some similarities with floating constraints; if a word 
is unknown to the user, an alternative word that can simply be substituted in the 
sentence may not exist. Instead, COMET must replan the entire sentence when an al- 
ternative word is not available, reinvoking its content planner (McKeown, Robin, and 
Tanenblatt 1993). 
PLANDOC is an automated ocumentation system under joint development by 
Columbia and Bellcore. It produces one to two page reports documenting the activi- 
ties of telephone planners. While PLANDOC does include a wide variety of paraphrases, 
some of which involve different word choices, and handles interactions between dif- 
ferent choices, lexical choice was not the primary issue in this system. Instead, the 
focus was on the systematic use of conjunction with ellipsis and its interaction with 
syntagmatic paraphrases, in order to produce concise, yet fluent, summaries. FUF was 
used as a tool for developing the Lexical Chooser, but with less-novel results on the 
topic of lexical choice. 
6.1.2 Systems with Different Architectures. Two other applications developed at 
Columbia also use FUF for lexical choice, but within a different system architecture: 
COOK (Smadja nd McKeown 1991) and STREAK (Robin 1994b). Some of the examples 
discussed in this paper within the framework defined by the architecture of ADVISOR- 
II originated from the respective domains for which these two other systems were 
implemented. 
The focus in COOK, a system for generating stock market reports, was on interlexi- 
cal constraints such as those presented in Section 5. By representing in FUF collocations 
that were automatically derived from a corpus of stock market reports, COOK could 
merge phrasal and single word constraints in the same lexicon as well as handle inter- 
actions between collocations. The way lexical choice is performed in COOK differs from 
the way it is performed in all the other FUF-based systems in that it is not driven by a 
top-down traversal of the input conceptual structure. Instead, lexical entries (individ- 
ual words or collocations) are chosen in afixed order in terms of the syntactic function 
they will ultimately occupy in the output sentence: first the verb arguments, then the 
main verb, finally the adjuncts. This bottom-up regime is less efficient han the top- 
down regime for handling the structural constraints described in Section 4. However, 
it allows indexing the lexicon by <lexical item, syntactic function> pairs rather than 
by concepts, a property that is handy for using syntactically marked collocations auto- 
230 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
matically produced by a domain-independent toolwith no semantic knowledge such 
as  XTRACT (Smadja 1991). 
The focus in STREAK was the definition of a draft-and-revision architecture for 
generating the type of very complex sentences used in newswire reports to summarize 
quantitative data about a basketball game and its historical background. STREAK relies 
on revision rules drawn from a corpus analysis of such reports (Robin and McKeown 
1993) to incrementally generate such complex sentences. While the draft-and-revision 
approach of STREAK sets it apart from all the other FUF-based generators, the Lexical 
Chooser of STREAK is akin to the Lexical Chooser of ADVISOR-II in that: 
? It handles floating constraints. 
? Its input is a linguistically unbiased fiat semantic network. 
? It is based on top-down recursive functional unification. 
There is, however, an important difference in the architectures of the two systems. 
STREAK handles the structural constraints and the floating constraints in two sepa- 
rate passes. Structural constraints are handled during an initial draft-building pass 
and floating constraints during a subsequent revision pass. This is in contrast with 
ADVISOR-II, which handles both types of constraints simultaneously. In STREAK, the 
Lexical Chooser is thus called first to build the draft and then again at each revision 
increment. The need for revision in STREAK primarily stems from the necessity in writ- 
ten summaries to concisely pack many facts into very complex sentences, as observed 
in newswire stories. For example, in the corpus of basketball reports that served as 
model output for STREAK, some sentences conveyed up to 12 conceptual relations and 
contained up to 46 words. In contrast, in the corpus of student advising sessions that 
served as model output for ADVISOR-II, no sentences conveyed more than four con- 
ceptual relations or contained more than 25 words. For the sentences ofmore ordinary 
complexity found in dialogues, revision is not needed and simultaneously combining 
semantic units into a single word can be achieved far more efficiently in a single pass. 
6.2 Other Systems 
In this section we overview approaches tolexical choice that do not rely on a FuF-based 
lexicon. We have classified them according to where they position the task of lexical 
choice in the overall generation architecture. For each class of systems, we describe 
the constraints on lexical choice that were considered. 
6.2.1 After Content Planning and Before Syntactic Realization. This approach is the 
most common among text generation systems. The surface realization component is
separated into two successive modules: lexical choice followed by syntactic realization. 
The lexical choice module builds the linguistic structure and chooses all open-class 
words. The syntactic realization component deals with agreements, ordering of con- 
stituents, choice of closed-class words, and in most systems can also perform syntactic 
transformations on the structure provided by the Lexical Chooser (such as passiviza- 
tion, dative movement, here-insertion, or it-extraposition). This is the approach used 
in the systems TEXT (McKeown 1985), GENARO-MUMBLE (Conklin 1983; Meteer et al 
1987), PENMAN (The Penman NLG 1989), SPOKESMAN (Meteer 1990), EPICURE (Dale 
1992), KALIPSOS (Nogier 1990) and in the generators based on the Meaning-Text The- 
ory (MTT) (Mel'Suk and Pertsov 1987) such as: FOC (Bourbeau et al 1990), GossIP 
(Carcagno and Iordanskaja 1993) and LFS (Iordanskaja et al 1994). 
231 
Computational Linguistics Volume 23, Number 2 
1. Main Verb with Adjunct: Prices increased by 20%. 
2. Object Noun with Postmodifier: Prices showed an increase of 20%. 
3. Subject Noun with Premodifier: A 20% increase has been reported. 
Figure 20 
Cross-ranking paraphrasing in the Meaning-Text Theory. 
These systems primarily use semantic and syntactic onstraints in selecting the 
words to use. Typically, each semantic oncept has an entry in the lexicon. The lexical 
entry for the semantic head (usually the verb, but indicated by either the semantic 
representation r the underlying application) is accessed first. The word chosen can 
depend on the semantic features of the arguments o the head (thus, this scheme basi- 
cally follows Goldman's \[1975\] use of discrimination networks). It is at this point that 
the overall syntactic structure is determined. This lexical entry then usually invokes 
the lexical entries for the arguments to the head and this control is followed until 
all input arguments have been lexicalized. In these systems, pragmatic onstraints 
are not consistently accounted for and when interlexical constraints are accounted for 
they are encoded as phrasal entries. Perspective on the input conceptual structure is 
fixed; thus, different entry points into this input structure cannot determine what the 
syntactic head of the sentence will be (except in SPOKESMAN \[Meteer 1990\]). In other 
words, the conceptual structure determines linguistic structure. Lexical choice was not 
a major research issue in any of these systems (unlike the work presented here), with 
two exceptions: KALIPSOS and MTT-based generators. 
Research for KALIPSOS focused on mapping multiple conceptual elements to the 
same word using matching of conceptual graphs. It also allowed for some decision 
making in determining the perspective of the clause, selecting the verb that covers the 
largest portion of the input network. Unlike our work, it handled primarily semantic 
and syntactic constraints on choice and thus, for example, does not dispatch conceptual 
nodes to different syntactic ranks. 
Paraphrasing power using a word-based lexicon is also a central issue in MTT, a 
generation-oriented an  highly stratificational linguistic theory in which sentences are 
represented atmultiple layers, five of which are relevant to the task of lexical choice 
(Polgu6re 1990). 
ADVISOR-II and MTT-based systems are similar in that lexical choice in both starts 
from a flat conceptual network (the Conceptual Communicative R presentation (CCR) 
layer in the case of MTT-based systems), they perform choice of perspective as well 
as syntagmatic choices, and they take into account interlexical constraints. 
There are also three main differences: 
The MTT approach is more stratified. In GOSSIP and LFS, lexical choice is 
decomposed into a pipeline of four mappings between the five layers of 
MTT representations. In ADVISOR-II, the input flat conceptual network 
(corresponding to the CCR in MTT) is directly mapped onto the output 
lexicalized syntactic tree. 23 
23 It is interesting to note that he most applied among MTr systems, FOG, directly maps the CCR onto a 
DSyntR. It may be an indication that all the intermediary representations defined in the MTr are not 
necessary in all domains. 
232 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
MTT makes the different ypes of lexical choices in a fixed order: first, 
paradigmatic choices that depend only on semantic onstraints, then 
perspective choice, followed by syntagmatic choices, and finally 
paradigmatic choices that depend on interlexical constraints. ADVISOR-II 
starts with perspective choice and then interleaves syntagmatic and 
paradigmatic choices. 
MTT does not handle pragmatic onstraints that float across the whole spectrum of 
linguistic ranks (i.e., all the way from connectives linking several clauses 
or sentences down to determiners) uch as the argumentative evaluations 
generated by ADVISOR-II. MTT also does not explicitly distinguish 
between structural and floating constraints, which makes considering the 
connective or determiner as alternative sites to clausal or nominal sites 
problematic. This is significant, since using a connective or a determiner 
instead of a semantically rich verb or a noun modifier allows for a more 
implicit expression of floating constraints (at least in the case of 
argumentative evaluations). MTT does, however, allow cross-ranking 
paraphrasing limited to the clause and NP ranks, as illustrated by the 
examples in Figure 20 (taken from Boyer and Lapalme \[1985\]). 
6.2.2 During Surface Realization, Interleaved with Syntactic Realization. In this ap- 
proach, lexical choice is considered as one linguistic decision like any other one, and, 
therefore, it is not isolated in a dedicated component. Instead, the syntactic grammar 
contains very specific rules for lexical insertion. 
This approach is generally associated with the use of either: 
? A phrasal exicon such as in the generation systems ANA (Kukich 1983a), 
PI-IRF.D (Jacobs 1985) and PAULINE (Hovy 1988). 
? A lexicalist reversible grammar (Strzalkowski 1994), such as a synchronous 
TAG (Shieber and Shabes 1991), especially in conjunction with the 
semantic-head-driven algorithm to generation (Shieber et al 1990). 
In a phrasal lexicon entry, all the syntactic onstraints between the elements of the 
template are already preselected, so there is no need for much syntactic realization: 
constituents are already ordered, their syntactic ategory is fixed in the phrasal tem- 
plate, closed-class words are already selected. Alternations like passivization or dative 
movement are encoded by defining, for each domain concept, several different em- 
plates, one for each combination of these orthogonal options (and thus failing to cap- 
ture the generality of these syntactic transformations independently of specific words 
and concepts). Interlexical constraints pose no problem since mutually constrained 
words are not chosen individually but all at once by accessing a phrasal template (it 
is just a matter of encoding only the entries corresponding tovalid collocations). Sim- 
ilarly, floating constraints are less of a problem for the phrasal approach, since most 
alternative locations for their expression remain for the most part within the scope of 
a phrasal template. However, the price to pay for this simplicity is high: generators 
relying on a phrasal exicon simply do not scale up. Extending their paraphrasing 
power and semantic overage requires hand-coding a combinatorially explosive num- 
ber of phrasal templates. With a more compositional pproach, such scaling up can 
be achieved by adding only few words along with the constraints that bind some of 
them (see Robin and McKeown \[1996\] for a corpus-based quantitative evaluation of 
the scalability gains achievable through compositionality). 
233 
Computational Linguistics Volume 23, Number 2 
In most approaches based on a lexicalist grammar, the semantic structure is tra- 
versed and a semantic head is selected; after the head is selected, all the syntactic 
decisions that depend on this head are performed; then the dependent constituents 
are identified and lexicalized in turn. Lexicalization and syntactic realization are, there- 
fore, interleaved as the linguistic structure is being built. With this approach, only a 
restricted range of constraints on lexical choice can easily be handled: in most cases 
only the semantic and syntactic onstraints coming from the local constituent influence 
what word is selected. Interlexical and pragmatic onstraints are not discussed and we 
have some doubts about how easy it would be to incorporate them in this approach. 
Since words are selected only as the full syntactic tree is constructed, it would be 
difficult to take floating constraints into account, which collapse different portions of 
the semantic input into different portions of the syntactic tree. 
6.2.3 During Content Planning and Before Syntactic Realization. Another class of 
generation systems positions the task of lexical choice somewhere during the process of 
deciding what to say, before the surface generator is invoked. This positioning allows 
lexical choice to influence content and to drive syntactic hoice. Danlos (1986) chooses 
this ordering of decisions for her domain. In her system, a lexicon grammar first selects 
lexical items for the predicative lements of the conceptual input. A discourse grammar 
is then used to combine clauses into valid discourse organization patterns, which also 
determine syntactic realization (choice passive/active for example). Danlos's system 
thus performs content determination and lexical choice before discourse organization 
and syntactic realization (a very original position). Since all the possible combinations 
of alternative discourse organizations and alternative syntactic forms need to be hand- 
coded in the discourse grammar, this approach suffers from the same drawback as the 
phrasal exicon approach: it is not compositional nd thus does not scale up. 
Rubinoff's (1992) IGEN also addresses the problem of the interaction between con- 
tent decisions and linguistic decisions and implements an architecture that relies on 
explicit negotiation between the two components: the content planner equests a set of 
options from the Lexical Chooser to realize a certain conceptual element, and the Lex- 
ical Chooser eplies with annotated options. The content planner selects among these 
annotations as it proceeds and combines the preferred options into an English mes- 
sage. Rubinoff designed a language of annotations that maintains a good separation 
of knowledge between the conceptual and linguistic components. 
Other researchers advocate folding the lexicon into the knowledge representation. 
In this approach, as soon as a concept is selected for the text, the words associated with 
it in the knowledge base would automatically be selected as well. This is the approach 
in KING (Jacobs 1987) and FN (Reiter 1991). In this approach, interlexical and syntactic 
constraints on lexical choice are not addressed, thus restricting the coverage of the 
domain sublanguage of the generator to sentences where these constraints do not 
come into play. McDonald's (1983) use of realization classes allows for the advantages 
of this approach while nonetheless allowing for syntactic onstraints to play a role. 
He makes use of inheritance within a knowledge base (McDonald 1981) to associate 
generic concepts uch as 0BJECT directly with a phrase category such as NP, but 
allows for individuations of the concept o have exceptions. Options are expressed 
in realization classes. While this does allow for a given input semantic element o 
be mapped to different syntactic onstructions, this approach does not address the 
problem of merging semantic oncepts in a single word, nor does it address interlexical 
constraints. 
234 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
7. Conclusion 
In this paper, we have presented a general model for lexical choice, which allows a 
generation system to take into account awide range of constraints on word selection in 
a compositional, flexible, and yet efficient fashion. By positioning the Lexical Chooser 
after content selection and before syntactic realization, both conceptual and linguistic 
constraints can influence word choice. Critically, our work has focused on the problem 
of floating constraints, providing a mechanism that allows the choice of a single word 
to realize several semantic oncepts and conversely allows a single semantic oncept 
to be realized by multiple words at distinct linguistic ranks. Our technique for lexical 
choice is characterized by the following features: 
? It is capable of handling a wide variety of constraints on lexical selection 
(co-occurrence r strictions, connotation of lexical items, syntactic and 
conceptual properties, and pragmatic effects). 
? Interaction among these constraints i easily handled through the use of 
a unification formalism to describe lexical entries. 
? Floating constraints can be attached at different levels of the generated 
syntactic structure, and several conceptual elements can be merged onto 
a single linguistic item, providing for more compact and lexically richer 
output. 
? Syntagmatic decisions are also made by the Lexical Chooser, so that an 
input conceptual structure can be mapped to a variety of linguistic 
structures. For example, the selection of "perspective" in a clause is 
guided by the available lexical resources (which verbs exist to express a
given conceptual relation) and by pragmatic onsiderations (which 
relation is highlighted as the topic of the discourse). 
Our implementation of the Lexical Chooser as a functional unification grammar 
allows the separate, declarative representation f different constraints, with unification 
allowing for interaction between constraints. Furthermore, within this framework we 
have developed an algorithm for lexical selection, and the consequent building of 
syntactic structure, such that at each choice point in the structure, the Lexical Chooser 
considers all semantic oncepts that can be realized, choosing a word that conveys as 
many as possible or discharging a concept o dependent linguistic sites, at the end 
checking that all concepts have been covered. In this framework, floating constraints 
can be merged with other semantic onstraints at any linguistic rank. 
Finally, handling floating constraints requires that the same semantic structure is 
mapped to different syntactic structures in different contexts. Thus, a Lexical Chooser 
must also consider syntagmatic choice. We have presented an approach that allows 
perspective to be chosen depending on the discourse focus. Different relations may be 
chosen as the head of a syntactic structure, depending on the focus. This means that 
the generation system encodes no a priori assumptions about which domain concepts 
will be realized as which syntactic onstituents. 
Any lexical selection algorithm that handles uch a wide range of constraints must 
deal with the issue of computational complexity. To ensure an efficient Lexical Chooser, 
we have developed a collection of techniques in the FUF programming environment 
to limit the cost of operations required during lexical choice. We have described in 
this paper lazy evaluation (with the : wait annotation) and dependency-directed back- 
tracking (with the :bk-c3.ass annotation) and shown how it reduces the cost of lexical 
235 
Computational Linguistics Volume 23, Number 2 
choice. With the help of these tools, we have implemented sophisticated lexical opti- 
mizations in ~uF. 
Our work results in an interpreter for an efficient Lexical Chooser, which allows 
handling of a wide variety of interacting constraints. In future work, we plan to in- 
vestigate the construction of domain- independent lexicon modules and methods for 
organizing large scale lexica, topics that we did not address in this work. This will 
require extending our work to provide tools for representing content of the lexicon in 
addition to the tools for manipulating and representing content hat we have detailed 
here. 
Acknowledgments 
This research was partially supported by a 
joint grant from the Office of Naval 
Research and the Advanced Research 
Projects Agency under contract 
N00014-89-J-1782, by National Science 
Foundation Grants IRT-84-51438 and 
GER-90-2406, and by the New York State 
Science and Technology Foundation under 
the auspices of the Columbia University 
CAT in High Performance Computing and 
Communications in Health Care, a New 
York State Center for Advanced Technology. 
We would like to thank the anonymous 
reviewers for their helpful comments. 
References 
Abella, A. 1994. From pictures to words: 
Generating locative descriptions of objects 
in an image. In Proceedings ofthe Image 
Understanding Workshop, Monterey, CA, 
November. 
Anscombre, J. C. and O. Ducrot. 1983. 
L'argumentation dans la langue. Philosophie 
et langage. Pierre Mardaga, Bruxelles. 
Appelt, D. 1983. Telegram: A grammar 
formalism for language planning. In 
Proceedings ofthe 8th International Joint 
Conference on Artificial Intelligence. IJCAI. 
Bateman, J. A., R. T. Kasper, J. D. Moore, 
and R. A. Whitney. 1990. A general 
organization of knowledge for natural 
language processing: The Penman 
upper-model. Technical Report, ISI, 
Marina del Rey, CA. 
Bourbeau, L., D. Carcagno, E. Goldberg, 
R. Kittredge, and A. Polgu~re. 1990. 
Bilingual generation of weather forecasts 
in an operations environment. In
Proceedings ofthe 13th International 
Conference on Computational Linguistics, 
Helsinki University, Finland. COLING. 
Boyer, M. and G. Lapalme. 1985. Generating 
paraphrases from meaning-text semantic 
networks. Computational Intelligence, pages 
103-117, August-November. 
Carcagno, D. and L. Iordanskaja. 1993. 
Content determination a d text 
structuring: Two interrelated processes. In 
H. Horacek and M. Zock, editors, New 
Concepts in Natural Language Generation: 
Planning, Realization and Systems. Frances 
Pinter, London and New York. 
Carpenter, B. 1992. The Logic of Typed Feature 
Structures with Applications to Unification 
Grammars, Logic Programs and Constraint 
Resolution, Cambridge Tracts in 
Theoretical Computer Science, volume 32. 
Cambridge University Press, Cambridge. 
Conklin, E. 1983. Data-driven I delible 
Planning of Discourse Generation Using 
Salience. Ph.D. thesis, University of 
Massachusetts, Amherst, MA. 
Cousot, P. and R. Cousot. 1977. Abstract 
interpretation: A unified lattice model for 
static analysis of programs by 
construction or approximation of
fixpoints. In Proceedings ofthe Fourth ACM 
Symposium on the Principles of Programming 
Languages, pages 238--252, Los Angeles, 
CA. 
Dalai, M., S. K. Feiner, K. R. McKeown, 
D. Jordan, B. Allen, and Y. alSafadi. 1996. 
Magic: An experimental system for 
generating multimedia briefings about 
post-bypass patient status. In Proceedings 
of the American Medical Informatics 
Association, Washington, D.C., October. 
Dale, R. 1992. Generating Referring 
Expressions. ACL-M1T Press Series in 
Natural Language Processing, Cambridge, 
MA. 
Danlos, L. 1986. The Linguistic Basis of Text 
Generation. Studies in Natural Language 
Processing. Cambridge University Press, 
Cambridge. 
de Kleer, J., J. Doyle, G. L. Steele, and 
G. J. Sussman. 1979. Explicit control of 
reasoning. In Winston P.J. and R.H. 
Brown, editors, Artificial Intelligence: An 
MIT Perspective. MIT Press, Cambridge, 
MA, pages 93-116. 
Elhadad, M. 1993a. Fuf: The universal 
unifier--user manual, version 5.2. 
Technical Report CUCS-038-91, Columbia 
University, New York. 
236 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
Elhadad, M. 1993b. Generating 
argumentative judgment determiners. In
Proceedings ofthe 11th National Conference on 
Artificial Intelligence, pages 344-349. AAAI. 
Elhadad, M. 1993c. Using Argumentation to
Control Lexical Choice: A Unification-based 
Implementation. Ph.D. thesis, Computer 
Science Department, Columbia University, 
New York. 
Elhadad, M. 1995. Using Argumentation i  
text generation. Journal of Pragmatics, 
24:189-220. 
Elhadad, M. 1996. Lexical choice for 
complex noun phrases. Machine 
Translation. 
Elhadad, M. and J. Robin. 1992. Controlling 
content realization with functional 
unification grammars. In R. Dale, 
H. Hovy, D. Roesner, and O. Stock, 
editors, Aspects of Automated Natural 
Language Generation. Springer Verlag, 
pages 89-104. 
Elhadad, M. and J. Robin. 1996. An 
overview of surge: A reusable 
comprehensive syntactic realization 
component. Technical Report 96-03, Ben 
Gurion University, Dept of Computer 
Science, Beer Sheva, Israel, April. 
Elhadad, M., D. Seligmann, S. Feiner, and 
K. McKeown. 1989. A common intention 
description language for interactive 
multi-media systems. In A New Generation 
of Intelligent Interfaces: Proceedings of
I\]CAI89 Workshop on Intelligent Interfaces, 
pages 46-52, Detroit, MI, August 22. 
Fawcett, R. P. 1987. The semantics of clause 
and verb for relational processes in 
English. In M. A. K. Halliday and 
R. P. Fawcett, editors, New Developments in 
Systemic Linguistics. Frances Pinter, 
London and New York. 
Feiner, S. and K. McKeown. 1990. 
Generating coordinated multimedia 
explanations. In Proceedings ofthe IEEE 
Conference on AI Applications, Santa 
Barbara, CA, March. 
Goldman, N. 1975. Conceptual generation. 
In Roger Schank, editor, Conceptual 
Information Processing. North-Holland, 
Amsterdam, pages 289-374. 
Halliday, M. A. K. 1985. An Introduction to 
Functional Grammar. Edward Arnold, 
London. 
Harbusch, K. 1994. Towards an integrated 
generation approach with tree-adjoining 
grammars. Computational Intelligence, 
10(4):579-590. 
Hovy, E. 1988. Generating Natural Language 
under Pragmatic Constraints. L. Erlbaum 
Associates, Hillsdale, N.J. 
Iordanskaja, L., M. Kim, R. Kittredge, 
B. Lavoie, and A. PolguSre. 1994. 
Generation of extended bilingual 
statistical reports. In Proceedings ofthe 15th 
International Conference on Computational 
Linguistics. COLING. 
Jacobs, P. 1985. Phred: a generator for 
natural language interfaces. Computational 
Linguistics, 11(4):219-242. 
Jacobs, P. S. 1987. Knowledge-intensive 
natural language generation. Artificial 
Intelligence, 33:325-378. 
Kay, M. 1979. Functional grammar. In 
Proceedings ofthe 5th Annual Meeting of the 
Berkeley Linguistic Society. 
Kukich, K. 1983a. The design of a 
knowledge-based report generator. In
Proceedings ofthe 21st Annual Meeting. 
Association for Computational 
Linguistics. 
Kukich, K. 1983b. Knowledge-based Report 
Generation: A Knowledge Engineering 
Approach to Natural Language Report 
Generation. Ph.D. thesis, University of 
Pittsburgh. 
Kukich, K., K. McKeown, J. Shaw, J. Robin, 
N. Morgan, and J. Phillips. 1994. 
User-needs analysis and design 
methodology for an automated document 
generator. In A. Zampolli, N. Calzolari, 
and M. Palmer, editors, Current Issues in 
Computational Linguistics: In Honour of Don 
Walker. Kluwer Academic Publishers, 
Boston. 
Lester, J. C. 1994. Generating Natural 
Language Explanations from Large-Scale 
Knowledge Bases. Ph.D. thesis, Computer 
Science Department, Universtity of Texas 
at Austin, New York, NY. 
Levi, J. 1978. The Syntax and Semantics of 
Complex Nominals. Academic Press. 
Levin, B. 1993. English Verb Classes and 
Alternations: A Preliminary Investigation. 
University of Chicago Press, Chicago. 
Lyons, J. 1977. Semantics. Cambridge 
University Press, Cambridge. 
Mann, W. C. and C. M. Matthiessen. 1983. 
Nigel: a systemic grammar for text 
generation. Technical Report 
ISI/RR-83-105, ISI, Marina del Rey, CA. 
Matthiessen, C. M. 1991. Lexicogrammatical 
choice in text generation. In C. Paris, 
W. Swartout, and W. C. Mann, editors, 
Natural Language Generation i Artificial 
Intelligence and Computational Linguistics. 
Kluwer Academic Publishers, Boston. 
McCoy, K. F. and J. Cheng. 1991. Focus of 
attention: Constraining what can be said 
next. In C. Paris, W. Swartout, and 
W. C. Mann, editors, Natural Language 
Generation i Artificial Intelligence and 
237 
Computational Linguistics Volume 23, Number 2 
Computational Linguistics. Kluwer 
Academic Publishers, pages 103-124. 
McDonald, D. 1981. Language production: 
The source of the dictionary. In 
Proceedings ofthe 19th Annual Meeting. 
Association for Computational 
Linguistics. 
McDonald, D. 1983. Description directed 
control: Its implications for natural 
language generation. In Karen 
Sparck-Jones, Barbara Grosz, and 
Bonnie-Lynn Webber, editors, Readings in 
Natural Language Processing. Morgan 
Kaufmann Publishers. 
McKeown, K. 1985. Using Discourse Strategies 
and Focus Constraints to Generate Natural 
Language Text. Studies in Natural 
Language Processing. Cambridge 
University Press, Cambridge. 
McKeown, K. and M. Elhadad. 1990. A 
contrastive evaluation of functional 
unification grammar for surface language 
generators: A case study in choice of 
connectives. In Natural Language 
Generation i  Artificial Intelligence and 
Computational Linguistics. Kluwer 
Academic Publishers, Boston. (Also, 
Columbia Technical Report CUCS-407-88). 
McKeown, K. R., M. Elhadad, Y. Fukumoto, 
J. G. Lim, C. Lombardi, J. Robin, and 
E A. Smadja. 1990. Text generation i
comet. In R. Dale, C. S. Mellish, and 
M. Zock, editors, Current Research in 
Natural Language Generation. Academic 
Press, pages 103-140. 
McKeown, K. R., S. Feiner, J. Robin, 
Seligmann D. D., and M. Tanenblatt. 1992. 
Generating cross-references for
multimedia explanation. In Proceedings of
the lOth Annual Conference on Artificial 
Intelligence, pages 9-16. AAAI. 
McKeown, K., K. Kukich, and J. Shaw. 1994. 
Practical issues in automatic 
documentation generation. In Proceedings 
of the ACL Applied Natural Language 
Conference, Stuttgart, Germany, October. 
McKeown, K. and D. Radev. 1995. 
Generating summaries of multiple news 
articles. In Proceedings ofSIGIR, Seattle, 
WA, July. 
McKeown, K., J. Robin, and K. Kukich. 
1995. Generating concise natural language 
summaries. Information Processing and 
Management. 31(5):703-733, September. 
Special Issue on Summarization. 
McKeown, K., J. Robin, and M. Tanenblatt. 
1993. Tailoring lexical choice to the user's 
vocabulary in multimedia explanation 
generation. In Proceedings ofthe 31st 
Annual Meeting. Association for 
Computational Linguistics. 
Mel'~uk, I. A. and N. V. Pertsov. 1987. 
Surface-syntax of English, A Formal Model in 
the Meaning-Text Theory. Benjamins, 
Amsterdam and Philadelphia. 
Meteer, M. W. 1990. The Generation Gap: The 
Problem of Expressibility in Text Planning. 
Ph.D. thesis, University of Massachusetts 
at Amherst. Also available as BBN 
Technical Report No. 7347. 
Meteer, M. W., D. D. McDonald, 
S. D. Anderson, D. Forster, L. S. Gay, 
A. K. Huettner, and P. Sibun. 1987. 
Mumble-86: Design and implementation. 
Technical Report COINS 87-87, University 
of Massachusetts at Amherst, Amherst, 
MA. 
Nogier, J. F. 1990. Un systeme de production de 
language fonde sur le modele des graphes 
conceptuels. Ph.D. thesis, Universit~ de 
Paris VII. 
Paris, C. L. 1987. The use of explicit user models 
in text generation: Tailoring to a user's level of 
expertise. Ph.D. thesis, Columbia 
University. Also available as Technical 
Report CUCS-309-87. 
Passoneau, R., K. Kukich, J. Robin, 
V. Hatzivassiloglou, L. Lefkowitz, and 
H. Jing. 1996. Generating summaries of 
workflow diagrams. In Proceedings ofthe 
International Conference on Natural Language 
Processing and Industrial Applications 
(NLP-IA'96), Moncton, New Brunswick, 
Canada. 
The Penman NLG. 1989. The Penman user 
guide. Technical report, Information 
Science Institute, Marina Del Rey, CA. 
Polgu~re, A. 1990. Structuration et mise en jeu 
proc~durale d'un modele linguistique ddclaratif 
dans un cadre de gdndration de texte. Ph.D. 
thesis, Universit~ de Montreal, Quebec, 
Canada. 
Pollard, C. and I. A. Sag. 1994. Head Driven 
Phrase Structure Grammar. University of 
Chicago Press, Chicago. 
Pustejovsky, J. and B. Boguraev. 1993. 
Lexical knowledge representation a d 
natural language processing. Artificial 
Intelligence, 63(1-2):193-223. 
Quirk, R., S. Greenbaum, G. Leech, and 
J. Svartvik. 1985. A Comprehensive 
Grammar of the English Language. Longman. 
Reiter, E. B. 1991. A new model for lexical 
choice for open-class words. 
Computational Intelligence, December. 
Reiter, E. B. 1994. Has a consensus natural 
language generation architecture 
appeared and is it psycholinguistically 
plausible? In Proceedings ofthe 7th 
International Workshop on Natural Language 
Generation, pages 163-170, June. 
238 
Elhadad, McKeown, and Robin Floating Constraints in Lexical Choice 
Robin, J. 1990. Lexical choice in natural 
language generation. Technical Report 
CUCS-040-90, Columbia University. 
Robin, J. 1994a. Automatic generation and 
revision of natural language summaries 
providing historical background. In 
Proceedings ofthe 11th Brazilian Symposium 
on Artificial Intelligence, Fortaleza, CE, 
October. 
Robin, J. 1994b. Revision-based generation 
of natural anguage summaries providing 
historical background: Corpus-based 
analysis, design, implementation a d 
evaluation. Technical Report 
CU-CS-034-94, Computer Science 
Department, Columbia University, New 
York. Ph.D. Thesis. 
Robin, J. and K. McKeown. 1993. Corpus 
analysis for revision-based generation of
complex sentences. In Proceedings ofthe 
11th National Conference on Artificial 
Intelligence, pages 365-372. AAAI. 
Robin, J. and K. McKeown. 1996. 
Empirically designing and evaluating a 
new revision-based model for summary 
generation. Artificial Intelligence, 85, 
August. Special Issue on Empirical 
Methods. 
Rubinoff, R. 1992. Negotiation, Feedback and 
Perspective within Natural Language 
Generation. Ph.D. thesis, Computer Science 
Department, University of Pennsylvania. 
Shieber, S. 1992. Constraint-based Grammar 
Formalism: Parsing and Type Inference for 
Natural and Computer Languages. MIT 
Press, Cambridge, MA. 
Shieber, S. M. and Y. Shabes. 1991. 
Generation and synchronous 
tree-adjoining grammars. Computational 
Intelligence, 7(4):220-228, December. 
Shieber, S. M., G. Van Noord, R. M. Moore, 
and Pereira E C. P. 1990. Semantic 
head-driven generation. Computational 
Linguistics, 16(1):30--42. 
Smadja, E 1991. Retrieving Collocational 
Knowledge from Textual Corpora. An 
Application: Language Generation. Ph.D. 
thesis, Computer Science Department, 
Columbia University, New York. 
Smadja, E A. and K. McKeown. 1991. Using 
collocations for language generation. 
Computational Intelligence, 7(4):229-239, 
December. 
Strzalkowski, T., editor. 1994. Reversible 
Grammars in Natural Language Processing. 
Kluwer Academic Publishers, Boston. 
Swartout, W. 1983. The gist behavior 
explainer. In Proceedings ofthe National 
Conference on Artificial Intelligence, pages 
402-407, Washington D.C. AAAI. 
Talmy, L. 1976. Semantic ausative types. In 
M. Shibatani, editor, The grammar of 
causative constructions. Syntax and 
semantics, volume 6. Academic Press, 
London. 
Talmy, L. 1983. How language structures 
space. In H. L. Pick and L. P. Acredolo, 
editors, Spatial Orientation: Theory, Research 
and Application. Plenum Press, New York 
and London. 
Talmy, L. 1985. Lexicalization patterns: 
Semantic structure in lexical form. In 
T. Shopen, editor, Grammatical Categories 
and the Lexicon, Language typology and 
syntactic description, volume 3. 
Cambridge University Press, Cambridge. 
Van Noord, G. 1990. An overview of 
head-driven bottom-up generation. In
R. Dale, C. Mellish, and M. Zock, editors, 
Current Research in Natural Language 
Generation. Academic Press, pages 
141-166. 
Winograd, T. 1983. Language as a Cognitive 
Process. Addison-Wesley. 
Yang, G., K. McCoy, and K. Vijay-Shanker. 
1991. From functional specification to 
syntactic structure: Systemic grammar 
and tree adjoining rammars. 
Computational Intelligence, 7(4), December. 
Zock, M. 1988. Natural anguages are 
flexible tools, that's what makes them 
hard to explain, to learn and to use. In 
M. Zock and G. Sabah, editors, Advances 
in Natural Language Generation: An 
Interdisciplinary Perspective. Pinter and 
Ablex. 
239 

