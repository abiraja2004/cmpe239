Proceedings of the 11th International Conference on Parsing Technologies (IWPT), pages 65?68,
Paris, October 2009. c?2009 Association for Computational Linguistics
Deductive Parsing with Interaction Grammars
Joseph Le Roux
NCLT, School of Computing,
Dublin City University
jleroux@computing.dcu.ie
Abstract
We present a parsing algorithm for In-
teraction Grammars using the deductive
parsing framework. This approach brings
new perspectives to this problem, depart-
ing from previous methods which rely on
constraint-solving techniques.
1 Introduction
An Interaction Grammar (IG) (Guillaume and Per-
rier, 2008) is a lexicalized grammatical formal-
ism that primarily focuses on valency, explicitly
expressed using polarities decorating syntagms.
These polarities and the use of underspecified
structures naturally lead parsing to be viewed as
a constraint-solving problem ? for example (Bon-
fante et al) reduce the parsing problem to a graph-
rewriting problem in (2003) .
However, in this article we depart from this ap-
proach and present an algorithm close to (Earley,
1970) for context-free grammars. We introduce
this algorithm using the standard framework of de-
ductive parsing (Shieber et al, 1995).
This article is organised as follows: we first
present IGs (section 2), then we describe the algo-
rithm (section 3). Finally we discuss some techni-
cal points and conclude (sections 4 and 5).
2 Interaction Grammars
We briefly introduce IGs as in (Guillaume and Per-
rier, 2008)1. However, we omit polarized feature
structures, for the sake of exposition.
2.1 Polarized Tree Descriptions
The structures associated with words by the lexi-
con are Polarized Tree Descriptions (PTDs). They
represent fragments of parse trees. The nodes of
these structures are labelled with a category and a
1This paper also discusses the linguistic motivations be-
hind IGs.
polarity. IGs use 4 polarities, P = {?,?,=,?},
namely positive, negative, neutral and virtual.
A multiset of polarities is superposable2 if it
contains at most one? and at most one?.
A multiset of polarities is saturated if it contains
either (1) one?, one? and any number of? and
=, or (2) zero?, zero?, any number of? and at
least one =.
The two previous definitions can be extended to
nodes: a multiset of nodes is saturated (resp. su-
perposable) if all the elements have the same cat-
egory and if the induced multiset of polarities is
saturated (resp. superposable).
A PTD is a DAG with four binary relations: the
immediate dominance >, the general dominance
>?, the immediate precedence ? and the general
precedence ?+. A valid PTD is a PTD where (1)
> and >? define a tree structure3 , (2) ? and ?+
are restricted to couples of nodes having the same
ancestor by >, and (3) one leaf is the anchor. In
the rest of this paper, all PTDs will be valid.
We now introduce some notations : if n >?
m, we say that m is constrained by n and for a
set of nodes N , we define Nz = {N |?M ?
N ,MzN} wherez is a binary relation.
2.2 Grammars
An IG is a tuple G = {?,C, S,P, phon}, where ?
is the terminal alphabet, C the non-terminal alpha-
bet, S ? C the initial symbol, P is a set of PTDs
with node labels in C? P, and phon is a function
from anchors in P to ?.
The structure obtained from parsing is a syntac-
tic tree, a totally ordered tree in which all nodes
are labelled with a non-terminal. We call lab(A)
the label of node A. If a leaf L is labelled with a
terminal, this terminal is denoted word(L).
2This name comes from the superposition introduced in
previous presentations of IGs.
3For readers familiar with D-Tree Grammars (Rambow et
al., 1995), > adds an i-edge while >? adds a d-edge.
65
We will write M  N if the node M is
the mother of N and N  [N1, . . . , Nk] if the
N is the mother of the ordered list of nodes
[N1, . . . , Nk]. The order between siblings can also
be expressed using the relation ??: M ?? N
means that N is the immediate successor of M .
??+ is the transitive closure of ?? and ? the
reflexive transitive closure of.
We define the phonological projection PP
of a node as : PP (M) = [t] if M 
[] and word(M) = t, or PP (M) =
[PP (N1) . . . PP (Nk)] if M  [N1, . . . , Nk]
A syntactic tree T is a model for a multisetD of
PTDs if there exists a total function I from nodes
in D (ND) to nodes in T (NT ). I must respect
the following conditions, where variables M,N
range over ND and A,B over NT :
1. I?1(A) is saturated and non-empty.
2. if M > N then I(M) I(N)
3. if M >? N then I(M)? I(N)
4. if M ? N then I(M) ?? I(N)
5. if M ?+ N then I(M) ??+ I(N)
6. if A B then there exists M ? I?1(A) and
N ? I?1(B) such that M > N
7. lab(A) = lab(M) for all M ? I?1(A)
8. if phon(M) = w then PP (I(M)) = [w]
Given an IG G = {?,C, S,P, phon} and a sen-
tence s = w1, . . . , wn in ??, a syntactic tree T is
a parse tree for s if there exists a multiset of PTDs
D from P such that the root node R of T is la-
belled with S and PP (R) = [w1, . . . , wn]. The
language generated by G is the set of strings in ??
for which there is a parse tree.
3 Parsing Algorithm
We use the deductive parsing framework (Shieber
et al, 1995). A state of the parser is encoded as an
item, created by applying deductive rules. Our al-
gorithm resembles the Earley algorithm for CFGs
and uses the same rules : prediction, scanning and
completion.
3.1 Items
Items [A(H,N,F ) ? ? ? ?, i, j, (O,U,D)] con-
sist of a dotted rule, 2 position indexes and a 3-
tuple of sets of constrained nodes.
The dotted rule A(H,N,F ) ? ? ? ? means
that there exists a node A in the parse tree with
antecedentsH ?N ?F . Elements of the sequence
? are also nodes of the parse tree. For the sequence
?, the elements have the form Bk(Hk) where Bk
is a node of the parse tree and Hk is a subset of its
antecedents, the predicted antecedents.
This item asserts that a syntactic tree can be par-
tially built from the input grammar and sentence,
that contains A  [A1 . . . AkB1 . . . Bl] and that
PP (A1) ? ? ? ? ? PP (Ak) = [mi+1 . . .mj ].
The proper use of constrained nodes is managed
by O, U and D:
? Nodes in D are available in prediction to find
antecedents for new parse tree nodes.
? Nodes in O must be used in a sub-parse. To
use an item as a completer, O must be empty.
? U contains constrained nodes that have been
used in a prediction, and for which the con-
straining nodes have not been completed yet.
Moreover, we will use 3 additional symbols: >
as the left-hand side of the axiom item which can
be seen as a dummy root, and  or  that mark
items for which prediction is not terminated.
We will need sequences of antecedents that re-
spect the order relations of an IG. Given a set of
nodes N , we define the set of all these orderings:
ord(N ) = {[N1 . . .Nk]|
(Ni)1?i?k is a partition of N?
1 ? i ? k,Ni is superposable ?
if n1, n2 ? N and n1 ? n2 then
?1 ? j < k s.t. n1 ? Nj and n2 ? Nj+1?
if n1, n2 ? N and n1 ?+ n2 then
?1 ? i < j ? k s.t. n1 ? Ni and n2 ? Nj}
3.2 Deductive Rules
In this section, we assume an input sentence s =
w1, . . . , wn and a IG G = {?,C, S,P, phon}.
Axiom This rule creates the first item. It pre-
pares the prediction of a node of category S start-
ing at position 0 without constrained nodes.
[> ? ?S(?), 0, 0, (?, ?, ?)]ax
66
Prediction This rule initializes a sub-parse. We
divide it in three in order to introduce the different
constraints one at a time.
[A(H,N,F )? ? ? C(HC)?, i, j, (O,U,D)]
[C(HC , ?, ?)? , j, j, (?, U,D ?O)] p1
In this first step, we initialize a new sub-parse
at the current position j where C will be the pre-
dicted node that we want to find antecedents for. If
some antecedentsHC have already been predicted
we use them. The nodes in O, that must be used
in one of the sub-parse of A, become available as
possible antecedents for C.
[C(HC , ?, ?)? , j, j, (?, U1, D1)]
[C(HC , NC , ?)? , j, j, (?, U2, D2)]p2
?
?????
?????
HC ?NC 6= ?
HC ?NC is superposable
NC ? D1 ? roots(P)
D2 = D1 ?NC
U2 = U1 ? (D1 ?NC)
In this second step, new antecedents for C are
added from the set NC , chosen among available
nodes in D1 and root nodes from the PTDs of
the grammar. The 3 node sets are then updated.
Constrained nodes that have been chosen as an-
tecedents for C are not available anymore and are
added to the set of used constrained nodes.
[C(HC , NC , ?)? , j, j, (?, U,D)]
[C(HC , NC , FC)? ??, j, j, (O,U,D)]p3
?
?????
?????
HC ?NC ? FC is saturated
? ? ord((HC ?NC ? FC)>)
FC = ?iQi, Q0 ? (HC ?NC)>? , Qi+1 ? Q>?i
O = (HC ?NC ? FC)>? ? FC
no anchor node in HC ?NC ? FC
In this last step of prediction, we can choose
new antecedents for C among nodes constrained
by antecedents already chosen in the previous
steps in order to saturate them. This choice is re-
cursive : each added antecedent triggers the pos-
sibility of choosing the nodes it constrains. The
second part of this step consists of predicting the
shape of the tree. We need to order and superpose
the daughter nodes of the antecedents in such a
way that ordering relations in PTDs are respected:
an element of ord((HC ?NC ? FC)>) is chosen.
Finally, the nodes that must be used in a sub-
parse are the ones that are constrained by an-
tecedents of C and not antecedents themselves.
Scan This is the rule that checks predictions
against the input string. It is similar to the previ-
ous rule, but one (and only one) of the antecedents
must be an anchor.
[C(HC , NC , ?)? , j, j, (?, U,D)]
[C(HC , NC , FC)? ?, j, j + 1, (?, U,D)]s
?
???????
???????
HC ?NC ? FC is saturated
(HC ?NC ? FC)> = ?
FC = ?iQi, Q0 ? (HC ?NC)>? , Qi+1 ? Q>?i(HC ?NC ? FC)>? ? FC = ?
one anchor a in HC ?NC ? FC
phon(a) = wj+1
If the expected terminal is read on the input
string, parsing can proceed. Note that antecedents
for C should not constrain nodes that are not an-
tecedents of C themselves.
Completion This rule extends a parse by com-
bining it with a complete sub-parse.
[A(H,N,F )? ? ? C(Hc)?, i, j, (O1, U1, D1)]
[C(HC , NC , FC)? ??, j, k, (?, U2, D2)]
[A(H,N,F )? ?C ? ?, i, k, (O3, U3, D3)]
c
?
???????
???????
NC ? D1 ?O1 ? P
D2 ? (D1 ?O1)?NC
U1 ? U2
O3 = O1 ? U2
D3 = D1 ? U2
U3 = U2 ?O1
We have to make sure that the second hypothe-
sis is a sub-parse for the first : (1) the set of avail-
able nodes in the sub-parse must be a subset of
the available nodes for current parse, (2) the set of
used nodes in the main parse must be a subset of
the used nodes in the sub-parse and (3) used nodes
constrained by the first hypothesis disappear.
Goal Parsing is successful if the following item
is created : [> ? S?, 0, n, (?, ?, ?)].
4 Discussion
4.1 Consistency and completeness
An item [A(H,N,F )? ???, i, j, (O,U,D)] as-
serts the following invariants :
67
? A and the elements ?l of ? are models for
saturated sets of nodes. Conditions 1, 7 and 3
(reflexive case) of a model are respected.
? Elements ?k of ? are superposable. Then we
have ?k ? (A?1)> (conditions 2 and 6).
? the sequence ?? is compatible with the order
relations from the PTDs (conditions 4 and 5).
? PP (?1) ? . . . ? PP (?l) = [wi+1 ? ? ?wj ]
? a node N in U is a constrained node in re-
lation >? with a node such that condition 3
holds.
These invariants can be checked by induction
on rules. Hence, such an item asserts there exists a
function J from the nodes of a subset of the PTDs
of an IG to a syntactic tree with its root labelled
by S and phonological projection w1 . . . wj . This
function has the same properties as the function I
for models but conditions 2 to 5 only apply if both
nodes are in the domain of J . The parsing process
extends the domain until (1) all the nodes of each
PTD selected are used and (2) the input string has
been read completely. Then J defines a syntactic
tree which is a parse tree.
4.2 Sources of non-determinism
The parsing problem in IGs is a NP-hard prob-
lem (Bonfante et al, 2003). Our presentation lets
us see several sources of non-determinism.
In p2, new antecedents are chosen among avail-
able nodes and root nodes of PTDs from the in-
put grammar. There is an exponential number of
such choices. However, IGs are lexicalized : only
PTDs associated with a word in the sentence will
be used and efficient lexical filters have been de-
veloped for IGs (Bonfante et al, 2006) that drasti-
cally decrease the number of PTDs to consider.
In p3 and s, constrained nodes can be chosen as
antecedents (nodes in FC). There is again an ex-
ponential number of such choices. But in existing
IGs, nodes have at most one successor by >? and
there is no chain of nodes in relation by >?. Con-
sequently, |FC | can be bounded by |HC ?NC |.
In p3, daughters must be partitioned. Instead of
building all these partitions in p3 and generating
many useless items, one can think of a lazy ap-
proach like the one proposed by (Nederhof et al,
2003) for pomset-CFGS.
It can be noticed that the completion rule, while
having the most positional indexes, is not a partic-
ular source of non-determinism.
5 Conclusion
We presented a parsing algorithm for IGs. Al-
though we used a simplified version without polar-
ized feature structures, adding a unification mech-
anism shouldn?t be an issue. The novelty of
this presentation is the use of deductive parsing
for a formalism developed in the model-theoretic
framework (Pullum and Scholz, 2001).
This change of perspective provides new in-
sights on the causes of non-determinism. It is
a first step to a precise complexity study of the
problem. In the future, it will be interesting to
search for algorithmical approximations to im-
prove efficiency. Another way to overcome NP-
hardness is to restrict superpositions, as in (k-)TT-
MCTAGs (Kallmeyer and Parmentier, 2008).
References
G. Bonfante, B. Guillaume, and G. Perrier. 2003.
Analyse syntaxique e?lectrostatique. Traitement Au-
tomatique des Langues, 44(3).
G. Bonfante, J. Le Roux, and G. Perrier. 2006. Lexi-
cal disambiguation with polarities and automata. In
Proceedings of CIAA.
J. Earley. 1970. An efficient context-free parsing algo-
rithm. Communications of the ACM, 13(2):94?102.
B. Guillaume and G. Perrier. 2008. Interaction Gram-
mars. Research Report RR-6621, INRIA.
L. Kallmeyer and Y. Parmentier. 2008. On the relation
between TT-MCTAG and RCG. In Proceedings of
LATA.
M.J. Nederhof, G. Satta, and S. Shieber. 2003. Par-
tially ordered multiset context-free grammars and
ID/LP parsing. In Proceedings of IWPT.
G. Pullum and B. Scholz. 2001. On the distinction be-
tween model-theoretic and generative-enumerative
syntactic frameworks. In Proccedings of LACL.
O. Rambow, K. Vijay-Shanker, and D. Weir. 1995. D-
tree grammars. In Proceedings of ACL.
S. Shieber, Y. Schabes, and F. Pereira. 1995. Principles
and implementation of deductive parsing. Journal of
Logic Programming, 24(1?2):3?36.
68
