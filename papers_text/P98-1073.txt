Vers l'utilisation des m thodes formelles pour 
le d veloppement de linguiciels 
Bi le l  Gargour i ,  Mohamed Jma ie l ,  Abde lmaj id  Ben  Hamadou 
Laboratoire LARIS 
FSEG-SFAX, B.P. 1088 
3018 SFAX, TUNISIA 
E-mail: {Abdelmajid.Benhamadou@fsegs.rnu.tn} 
Abst ract  
Formal methods have'nt been applied enough in 
the development process of lingware although 
their advantages have been proved in many 
other domains. In this framework, we have 
investigated some applications dealing with 
different processing levels (lexical analyses, 
morphology, syntax, semantic and pragmatic). 
These investigations has mainly led to the 
following observations. First of all, we have no- 
ticed a lack of use of methodologies that cover 
all the life cycle of a software development. The 
formal specification has not been used in the 
first development phases. In addition, we have 
noticed the lack of formal validation and 
consequently the insufficient guarantee of the 
developed software results. Moreover, there 
has been no appeal to rigorous methods of 
integration to solve the dichotomy of data 
and processing problem. However, the use of 
the formal aspect in the Natural Language 
Processing (NLP) has generally been limited to 
describing the natural anguage knowledge (i.e., 
grammars) and specifying the treatments using 
algorithmic languages. Few are those who have 
used a high level specification language. 
This paper focuses on the contributions of 
formal methods in developing natural anguage 
software starting from an experimentation 
carried out on a real application and which 
consists in specifying and validating the sys- 
tem CORTEXA (Correction ORthographique 
des TEXtes Arabes) using the VDM formal 
method. 
First of all, we review the advantages of formal 
methods in the general software development 
process. Then, we present he experimentation 
and the obtained results. After that, we place 
the formal methods advantages in the context 
of NLP. Finally, we give some methodological 
criteria that allow the choice of an appropriate 
formal method. 
438 
Rdsumd : 
Les mkthodes formelles n'ont pas ktd surf- 
isamment utiliskes dans le processus de 
ddveloppement des linguiciels, alors qu'elles 
ont fait leurs preuves dans d'autres domaines. 
Le prdsent article essaye de mettre en relief 
les avantages des mkthodes formelles dans le 
contexte des langues naturelles, partant des 
rksultats d'une expkrience rkaliske sur une ap- 
plication rkelle. Dans un premier temps, nous 
rappellons les avantages globaux des mkthodes 
formelles dans le processus de dkveloppement 
d'un logiciel. Ensuite, nous pla?ons ces 
avantages dans le contexte des langues na- 
turelles. Enfin, nous donnons les crithres 
mkthodologiques pour le choix d'une mkthode 
formelle approprike. 
1 In t roduct ion  
L'automatisation des langues naturelles a 
bdnkficik jusqu'k nos jours de nombreuses 
anndes de recherches et continue encore 
faire l'objet de plusieurs travaux, notamment 
dans le domaine du gknie linguistique pour le 
dkveloppement d'applications spkcifiques. 
L'ktude des approches de dkveloppement des 
applications likes au Traitement Automatique 
des Langues Naturelles (TALN), k tous ses 
niveaux (i.e., lexical, morphologique, syntax- 
ique, skmantique et pragmatique), (Fuchs, 1993; 
Sabah, 1989) nous a permis de constater une 
quasi-absence de l'utilisation de mdthodologies 
de dkveloppement qui inthgrent toutes les 
phases du cycle de vie d'un logiciel. En par- 
ticulier, au niveau des premihres dtapes, nous 
avons constatk l'absence quasi-totale de la phase 
de spkcification formelle. 
D'un autre c5t4, nous avons constatd une dif- 
ficultk, voire absence de validation formelle 
des approches utilisdes dans le dkveloppement 
et par consdquent de garantie sur les perfor- 
mances des rksultats obtenus. De m~me, nous 
avons remarqu6 le non recours ? des mdthodes 
rigoureuses d'intkgration pour rksoudre le 
problhme de la dichotomie donn6es-traitements. 
L'utilisation des outils formels s'est limitke, 
dans la plupart des cas, k la description du lan- 
gage (i.e., les grammaires) et k la spdcification 
des traitements r~duite, g@nkralement, k l'usage 
d'un langage algorithmique. Rares sont ceux 
qui ont utilisk un langage de spkcification 
formelle de haut niveau (Zajac, 1986; Jensen 
et al, 1993). 
Aprhs une prksentation des avantages qu'offrent 
les mkthodes formelles dans le processus de 
dkveloppement d'un logiciel, d'une manihre 
gknkrale, cet article essaye de mettre en re- 
lief les avantages pecifiques au domaine de 
TALN partant d'une expkrience mende au sein 
de notre kquipe en utilisant la mkthode VDM 
(Dawes, 1991; Jones, 1986). I1 donne, ~ la fin, 
des crithres permettant le choix d'une mkthode 
formelle approprike. 
2 Rappe l  des pr inc ipaux  avantages  
des mdthodes  fo rmel les  
L'int@gration des mkthodes formelles dans le 
processus de dkveloppement de certaines ap- 
plications critiques comme les systhmes temps 
rdel et les systhmes distribu'ks a donnk ses 
preuves ces dernihres annkes (Barroca and Der- 
mid, 1992; Dick and Woods, 1997; Ledru, 
1993). C'est ce qui a motivk leur utilisation 
dans le ddveloppement de logiciels traitant des 
problhmes complexes au niveau industriel (Hui 
et al, 1997). 
Une mkthode formelle est considkrke comme 
une ddmarche de dkveloppement de logiciels 
baske sur des notations mathdmatiques t des 
preuves de validation formelles (Habrias, 1995). 
Cette dkmarche utilise un processus de raiTine- 
ment qui part d'une spkcification abstraite des 
besoins pour dkboucher sur une spkcification 
raffinke et exkcutable (ou directement codable 
en un langage de programmation). Les princi- 
paux avantages des mkthodes formelles peuvent 
~tre rksumks dans les points suivants :
La prdcision et la non ambiguitd : l'utilisation 
d'un langage bask sur des notations formelles 
et prkcises permet d'kviter toute ambiguitk et 
toute redondance dans la spkcification. 
La ddteetion d'erreurs conceptueUes le plus tSt 
possible : l'application de preuves de validation 
de la spkcification tout le long du processus 
de raffinement de cette dernihre, garanti la 
ddtection des erreurs de conception le plus tSt 
possible dans le processus de dkveloppement 
de l'application. En l'absence d'une telle 
validation, les erreurs de conception e seront 
439 
d~tect4es qu'aprhs la phase d'impl4mentation 
ce qui engendrera un c6ut suppl~mentaire. 
La satisfaction de la conception 
(dventuellement de l'impldmentation ) par 
rapport aux besoins : elle est garantie gr?ce 
au processus de raffinement qui part d'une 
sp4cification des besoins et applique des rhgles 
coh~rentes de transformation pour aboutir ~ la 
conception finale. 
Le contrble de la cohdrence donndes- 
traitements : qui est directement pris en charge 
gr?ce aux preuves de validation. 
La rdutilisation : le raffinement des 
specifications formelles et leurs d~compositions 
successives permettent de mettre en ~vidence 
des niveaux d'abstraction int~ressants pour la 
r~solution du probl~me t pour promouvoir la 
r~utilisation (des sp4cifications). 
3 P resentat ion  et  r~su l ta ts  de  
l 'exp~r imentat ion  
3.1 Cho ix  et  d~marche  uti l is4e 
Pour mesurer l' impact de l'utilisation des 
m~thodes formelles dans le contexte du TALN, 
nous avons effectu~ la specification complhte 
et valid~e du systhme CORTEXA (Correction 
ORthographique des TEXtes Arabes) (Ben- 
Hamadou, 1993) d~velopp~ au sein de notre lab- 
oratoire. 
Outre la disponibilit~ de la documentation, en 
mati~re de conception et d'impl~mentation, le 
choix du syst~me CORTEXA est aussi motiv~ 
par la diversit~ des approches utilis~es pour la 
representation des connaissances t des traite- 
ments. En effet, il se compose : 
? d'un module de d~tection des erreurs bas~ 
sur une analyse affixale qui utilise un 
systhme ~ 4tats finis (les r~seaux de tran- 
sitions augment~es : ATN). L'analyse af- 
fixale effectue la d~composition d'un mot 
en ses composants premiers : pr~fixe, in- 
fixe, suffixe et racine en se r~f~rant ? un 
ensemble de lexiques et de structures de 
donn~es, 
? d'un module de correction des erreurs or- 
thographiques qui utilise un systhme ~ base 
de rhgles et 
? d'un autre module de correction des erreurs 
typographiques qui se base sur un systbme 
mixte. 
Le choix de VDM pour la specification de COR- 
TEXA est motive, d'une part, par le fait que 
cette m~thode se base sur les pr~dicats qui don- 
nent un haut pouvoir expressif, et d'autre part, 
pour sa notation simple et riche. Aussi, VDM 
a fait ses preuves dans le d~veloppement de 
plusieurs systhmes d'information. Contraire- 
ment aux environnements de specification des 
donn~es linguistiques tels que D-PATR (Kart- 
tunen, 1986), EAGLES (Erbach et al, 1996), 
etc, VDM permet de specifier ? la fois des traite- 
ments et des donn~es (dans notre contexte des 
donn~es linguistiques) et offre une m~thodologie 
de d~veloppement d'applications se basant sur 
des raffinements etdes transformations valid~es. 
Partant de la description informelle des be- 
soins, nous avons d6velopp~ la spficification 
abstraite du systbme CORTEXA (appelfie 
aussi spgcification implicite) qui englobe, en- 
tre autres, la spficification formelle de ses fonc- 
tions, de ses actions et de ses rbgles de correc- 
tion. Cette sp~cification a fit6, ensuite, validfie 
en utilisant des preuves formelles. Enfin, nous 
avons g~n~ralis~ la sp~cification de conception 
(appel~e aussi spficification explicite ou directe) 
partir de la sp~cification abstraite moyen- 
nant des rbgles relatives ? la m6thode VDM. 
Cette sp4cification de conception est facile- 
merit transform6e en code pour rfialiser la phase 
d'implfimentation. 
3.2 R~su l ta ts  obtenus  
L'utilisation de la m~thode formelle VDM pour 
la sp6cification complbte et valid~e du systbme 
CORTEXA a conduit, entre autres, aux con- 
stats suivants :
InsuJfisance n r~gles : l'utilisation des preuves 
formelles nous a permis de mettre en relief, par 
rapport ~ \[a specification initiale, certaines itu- 
ations non prises en compte. En particulier, les 
preuves qui permettent de s'assurer que pour 
chaque type d'erreur dolt exister au moins une 
rhgle de correction ous ont permis de constater 
que l'ensemble des rbgles de correction, initiale- 
ment propos~, ne permet pas de prendre en 
charge toute la typologie d'erreurs. 
Exemple  1: preuve relative ? l'erreur de sup- 
440 
pression Exemple  3: 
(Vw' ?~ CH, Vw ~ Lex).(Del(w, w')A 
w' ?_ Lex) ~, (3R e Reg).w ~ R(w') 
oh 
Lex : le lexique de r4f~rence 
CH : l'ensemble des s~quences de chaines de 
caracthres 
Reg : l'ensemble des rhgles de correction 
R(w) : l'application de la rhgle R sur la chaine 
w. On repr~sente une rhgle en VDM par une 
fonction 
Del 0 : un pr~dicat qui v~rifie l'erreur de 
suppression de caract~re. 
La prdcision et la concision de la 
spdcification : en comparant la specification in- 
formelle du systhme CORTEXA, pr~sent~e dans 
la documentation, avec la specification formelle 
d~velopp~e, nous remarquons que eette dernihre 
est plus precise et plus concise. L'exemple 
2, donn~ ci-aprhs, qui pr~sente la specification 
formelle de la fonction de g~n~ration des 
d~compositions affixales possibles d'un mot w, 
illustre ce constat. 
Exemple  2: 
lsdecomp(w, p,i, s, root : CH)r : B 
pre  True 
post  3a, bE CH (w=p.a . i .b . sA  
root = a * b) A (Sprefixe(w, p) A 
Ssu f  f ix(w, s)/X Sin f ixe(w, i) ) 
oh 
B : le type bool~en 
Sinfixe 0 ( respectivement Sprefixe 0 et 
Ssu\]fixeO) : un pr~dicat qui v~rifie la 
propri~t~ d'un infixe (respectivementd'un 
pr~fixe t d'un suffixe) pour une chaine. 
Facilitd du ddveloppement du code : la 
specification de conception obtenue st suffisam- 
ment explicite pour les donn~es et alorith- 
mique pour les traitements. Elle est donc facile- 
ment codable en un langage de programmation. 
L'exemple 3, illustre l'usage d'une notation al- 
gorithmique dans la sp6cification des fonctions. 
Il pr~sente la fonction S-Radical de v~rification 
de la propri~t~ d'un radical (form6 par la racine 
et l'infixe). 
Sradical : CH x CH > B 
Sradieal(sl,s2) -=De\] if s, -= \[\] 
then  False 
else if Sprefixe(sl ,  s2) 
then  True 
else Sradieal(tl(sl), s2) 
oh 
riO: une fonction VDM qui retournela 
s~quence en entree priv~e de sa t~te. 
Unicitd de la notation : les m~thodes formelles 
permettent d'utiliser la m~me notation pour 
d~crire aussi bien les donn~es que les traite- 
ments. En effet, avec le langage VDM-SL, as- 
soci~ k VDM, nous avons pu specifier toutes les 
fonctions et les donn~es de r~f~rence de COR- 
TEXA. Les exemples 4 et 5 illustrent cette 
unicit~ pour la representation des donn~es com- 
posdes et des fonctions. 
Exemple  4 : l 'enregistrement relatif aux 
donn~es d'une d~composition d'un mot en un 
pr~fixe, un infixe, un suffixe et une racine. 
Decomp :: p: CH 
i: CH 
s: CH 
r :  CH 
Exemple  5: specification de l'action qui g~nhre 
les propositions de correction des suffixes par 
suppression de caracthre 
A3s(p : CH, c : CHAR)SCand : set of CH 
pre  True 
post  3 a,b, pl E CH p = aec .  b 
Apl = a ? b A Pl e Su f f ~ {Pl } C SCand 
oh 
CHAR : l'ensemble des caracthres 
SCand : les suffixes candidats k la 
correction 
Surf: l'ensemble des suffixes. 
Cohdrence donndes-traitements : l'unicit~ de 
la notation, a permis d'appliquer des preuves 
formelles k la lois sur des donn~es et des 
traitements et par consequent de contr61er la 
coherence de ces derniers. L'exemple 1 illustre 
ce contr61e dans le cas d'un systhme ~ base de 
rhgles. 
441 
La validation de chaque composant du 
syst~me : pour chaque composant ou module 
du systbme CORTEXA, nous avons appliqu6 les 
preuves de validation appropri6es, ce qui nous a 
permis de valider tousles r6sultats partiels du 
systbme. Le th6orbme de l'exemple 6, donn6 
ci-aprbs, permet de prouver qu'? la suite de 
l'application de la rbgle de correction d'une er- 
reur de substitution, les propositions de correc- 
tion obtenues appartiennent au lexique. 
Exemple  6: 
Vw' E CH, Vw ~ Lex.Sub(w, w ~) 
:. 3R ~ Reg.R(w') C_ Lex 
o~ 
Sub : un pr@dicat qui v6rifie l'erreur de 
substitution de caracthres. 
4 In t6r6ts  des  m6thodes  fo rmel les  en 
g6n ie  l ingu is t ique  
Cette exp6rimentation, bien qu'elle soit assez 
limit~e dans le temps (elle a dur~ une annie en- 
viron) et dans son contexte (elle s'est int6ress6 
un seul systhme t non k plusieurs), elle nous 
a permis d'appr@cier ? juste titre l'int@r6t de 
recourir aux m6thodes formelles dans le pro- 
cessus de d6veloppement des applications li6es 
au TALN. Elle nous a aussi permis de d6gager 
certains avantages globaux d6di6s au domaine 
du TALN qui viennent consolider ceux que 
nous avons d4j? cit6s dans un cadre g6n6ral 
de d6veloppement des Iogiciels. Ces avantages 
sp6cifiques peuvent ~tre r@sum6s et argument6s 
dans les points qui suivent. 
D'abord, au niveau de la specification des 
besoins, les applications du TALN sont 
g6n6ralement trhs ambitieuses au d6part. Or 
on connait aujourd'hui les limites des modbles 
linguistiques et des outils de repr6sentation des 
connaissances. L'utilisation d'outils formels 
dans les premibres 6tapes de d6veloppement 
(i.e., analyse) permet de mettre trbs vite en 
6vidence les limites du systbme k d6velopper, en 
particulier, sur le plan de la couverture linguis- 
tique et par cons6quent de partir pour l'6tape de 
conception sur une version valid6e du systbme 
qui sera impl@ment6 et de pr4voir d'embl6 les 
possibilit6s d'extention et de r6utilisation. 
Par ailleurs, la complexit6 des traitements li6s 
au langage naturel et la diversit6 des donn6es 
linguistiques et des fortes int6ractions qui ex- 
istent entre donn@es et traitements rendent 
la t~che de conception trbs difficile et pou- 
vant engendrer des problbmes d'incoh6rence. 
L'utilisation des m6thodes formelles au niveau 
de la conception permet d'abord, de g6rer 
la dichotomie donn6es-traitements soit par 
l'int6gration (i.e., en utilisation l'approche ob- 
jet), soit par le contrSle de coh6rence (i.e., 
par des preuves de validation) et ensuite de 
mettre en 6vidence, par des regroupements 
et des raffinements successifs, des abstractions 
int6ressantes r6utilisables telsque des modules 
ou des sous-systbmes pouvant ~tre disponibles 
dans une bibliothbque (Darricau et al, 1997). 
Ces abstractions correspondent par exemple 
des modules standards du TALN traitant le 
niveau phon6tique, morphologique, syntaxique, 
etc. Notons ? ce propos que, la r6utilisation 
de sp6cifications (i.e., de conception) peut se 
faire directement ou moyennant des adapta- 
tions. Les m6thodes formelles offrent des 
environnements qui facilitent ces adaptations 
(6diteurs,..) et qui permettent la validation des 
nouvelles p6cifications. 
Enfin, l'utilisation d'une notation uniforme 
donne la possibilit6 d'int6grer dans la m@me 
application une vari6t@ de connaissances sur la 
langue sp6cifi@es avec des formalismes diff6rents 
(i.e., grammaires d'unification, HPSG, Gram- 
maires Formelles, etc). Ce qui permet- 
tera d'avoir une meilleure coh6rence dans la 
sp6cification finale k produire. 
5 Les c r i tb res  de  cho ix  d 'une  
m6thode  fo rmel le  pour  le TALN 
L'utilisation de la m~thode VDM pour la 
specification complhte et valid~e du systhme 
CORTEXA a @t@ ? titre d'essai. Toute- 
lois, le choix d'une m~thode formelle pour 
le d~veloppement d'une application de TALN 
reste crucial. Ce choix dolt tenir compte des 
sp~cificit~s du domaine des langues naturelles 
sur le plan du langage de specification et sur 
celui de la m~thodologie appliqu~e. Dans ce qui 
suit, nous donnons quelques crithres que nous 
jugeons pertinents dans le choix d'une m~thode 
formelle dans le contexte de TALN : 
442 
? Le pouvoir expressif de la 
m~thode : possibilit~ d'int~grer dans la 
m~me specification des connaissances lin- 
guistiques vari~es d~crites avec des formal- 
ismes diff4rents. Le langage de sp4cification 
doit pouvoir unifier la representation des 
diff4rentes expressions. Le pouvoir expres- 
sif concerne aussi la specification conjointe 
des donn~es linguistiques et les traitements 
qui leurs sont appliques. 
? Simplicit~ de la notation et de la 
m~thodologie d  d~veloppement. 
? Couverture maximale du cycle de vie du 
logiciel ~ d4velopper. 
? Existance d'Ateliers de G~nie Logiciel 
(AGLs) qui supportent la m~thode. 
? Possibilit~ de supporter l'architecture du 
systhme envisag~ (i.e., s~quentielle, dis- 
tribu~e, parallhle, etc). 
6 Conc lus ion  
L'utilisation des m~thodes formelles dans le 
contexte des langues naturelles permet, non 
seulement de consolider les avantages globaux 
de ces methodes dans le cadre g~n~ral de 
d~veloppement de logiciels, mais aussi de rap- 
porter de nouveaux profits sp~cifiques au do- 
maine. Cette utilisation concerne aussi bien 
le processus de d~veloppement des applications 
que leur maintenance. Cependant, le choix 
d'une m~thode appropri~e r ste li~ ? la disponi- 
bilit~ d'outils logiciels associ4s qui facilitent sa 
mise en oeuvre et k la construction d'une bib- 
liothhque de specifications r~utilisables. 
Actuellement, nos travaux se concentrent sur 
la finalisation d'une approche que nous avons 
d~velopp~e pour g~n~raliser l'utilisation des 
m~thodes formelles (VDM ou autres) dans 
le processus de d~veloppement des linguiciels. 
Cette approche inthgre les principaux formal- 
ismes existants de description des connaissances 
linguistiques (i.e., Grammaires d'Unification, 
Grammaires Formelles, HPSG, etc). 
References  
L. M. Barroca and J. A. Mc Dermid. 1992. For- 
mal methods : use and relevance for the de- 
velopment of safety-critical systems. The Com- 
puter Journal, 35(6). 
A. BenHamadou. 1993. Vdrification et correc- 
tion automatiques par analyse affixale des textes 
dcrits en langage naturel : le cas de l'arabe non 
voyelld. Ph.D. thesis, Facult~ des Sciences de 
Tunis. Thhse Es-Sciences en Informatique. 
M. Darricau, H. Hadj Mabrouk, and J.G. 
Ganascia. 1997. Une approche pour la 
r~utilisation des sp6cifications de logiciels. 
Gdnie Logiciel, (45):21-27, September. 
J. Dawes. 1991. The VDM-SL reference guide. 
Pitman Publishing. 
J. Dick and E. Woods. 1997. Lessons learned 
from rigorous ystem software development. In- 
formation and Software Technology, 39:551- 
560. 
G. Erbach, J. Dorre, S. Manandhar, and 
H. Uszkoreit. 1996. A report on the draft ea- 
gles encoding standard for hpsg. In Actes de 
TALN-96, Marseille, France, May. 
C. Fuchs. 1993. Linguistique et Traitements 
Automatiques des Langues. Hachette. 
H. Habrias. 1995. Les specifications formelles 
pour les systhmes d'informations quoi ? 
pourquoi ?comments ? Ingdnierie des syst~mes 
d'information, 3 (2) :.205-253. 
J. Hui, L. Dong, and X. Xiren. 1997. Using 
formal specification language in industrial soft- 
ware development. In Procedings of the IEEE 
International Conference on Intelligent Process- 
ing Systems, pages 1847-1851, Beijing, China, 
October. 
K. Jensen, G.E. Heidorn, and S. D. Richard- 
son. 1993. NLP: The PLNLP Approach. Kul- 
wer academic publishers. 
C. B. Jones. 1986. Systematic software devel- 
opment using VDM. Printice Hall. 
L. Karttunen. 1986. D-patr : A development 
environment for unification-based grammars. In 
In Proceedings of the ~ lth International Confer- 
ence on Computational Linguistics, pages 74- 
80, Bonn, Germany. 
Y. Ledru. 1993. Developing reactive systems in 
a vdm framework. Science of Computer Pro- 
gramming, 20:51-71. 
G. Sabah. 1989. L'intelligence artificielle et le 
langage. Hermes. 
R. Zajac. 1986. Scsl : a linguistic specification 
language for rot. In Procedings of COLING'86, 
pages 25-92, Bonn, Germany, August. 
443 
