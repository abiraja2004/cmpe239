LFG ~ystsm in Prolog 
H ide~ Ya~u'~awa 
The Second Laboratory 
Institute for New Generation Computer Technology (ICOT) 
To~/o, 108, Japan 
ABSTRACT 
In order to design and maintain a latE? scale 
grammar, the formal system for representing 
syntactic knowledEe should be provided. Lexlcal 
Functional Grammar (LFG) \[Kaplan, Bresnan 82\] is a 
powerful formalism for that purpose, In this 
paper, the Prolog implementation of LFG system is 
described. Prolog provides a Eood tools for the 
implementation of LFG. LFG can be translated into 
DCG \[Perelra,IIarren 80\] and functional structures 
(f-structures) are generated durlnK the parsing 
process. 
I INTRODUCTIOr~ 
The fundamental purposes of syntactic 
analysis are to check the Eramnatlcallty and to 
clariDI the mapping between semantic structures 
and syntactic constituents. DCG provides tools 
for fulfillln 6 these purposes. But, due to the 
fact that the arbitrary 9rolog programs can be 
embedded into DCG rules, the grammar becomes too 
complicated to understand, debug and maintain. 
So, the develo~ent of the formal system to 
represent syntactic knowled~es is needed. The 
main concern is to define the appropriate set of 
the descriptive primitives used to represent the 
syntactic knowledges. LFG seems to be promising 
formalism from current llngulstlc theories which 
satisfies these requirements. LFG is adopted for 
our prelimlna~y version of the formal system and 
the Prolog implementation of LFG is described in 
this paper. 
ii SII:~.Z OVERVI~ OF LFG 
in this section, the simple overview of LF~ 
is described (See \[Eaplan, Bresnan 82\] for details 
). LFG is an e::tention of context free grammar 
(C~'G) and has two-levels of representation, i.e. 
c-structures (constituent structures) and 
f-~tructures (functional structures). A 
c-structure is generated by CFG and represents the 
surface uord and phrase configurations in a 
~entence, and the f-structure is generated by the 
functional equations a=sociated with the o~rammar 
rules and represents the conflo~uratlon of the 
surface ~ra=matical functions. Fi~. I shows the 
c-structure and f-structure for the sentence "a 
e~f.rl handed the baby a toy" ( \ [Kap lan ,Bresnan 82 \ ] ) .  
np 
I 
det---n 
I 
I 
f 
a 
s 
I 
.... Vp 
I 
v ...... np- ...... np 
det---n det--n 
glrl hands the baby a toy 
(a) c-structure 
subJ spec a 
hum ng 
pred "glrl" 
tense past 
pred "hand<(T subJ)(T obJ2)(T obJ)>" 
obJ spec the 
num sg 
pred "baby" 
obJ2 spec a 
num sg 
pred "toy" 
(b) f-structure 
Fig. 1 The eY~mgle c-structure and f-structure 
As shown in Fig. I, f-structure is a 
hierarchical structure constructed by the pairs of 
at~rlbute and its value. An attribute represents 
~ra=matlcal function or syntactic feature. 
Lexlcal entries specify a direct mappinE betueen 
semantic arguments and confizuratlons of surface 
grammatlcal functions, and ~rammar rules specify a 
direct mapping between these surface Cr~umatlcal 
functions and particular constituent structure 
conflguratlons. To represent these Cra=matlcal 
relations, several devices and schemata are 
provided in LFG as shown below. 
(a) meta variables 
(1) T & $ (immediate dominance) 
(il) ~ & ~ (bounded dominance) 
(b) functional notations 
a designator (T subj) indicates 
the aSubja attribute of the 
f- structure. 
(c) Equational schema 
l l) ( functional equation) 
ii) ~ (set inclusion) 
the va!ue of 
mother node's  
358 
(d) Constrainln~ schema 
{i) =c (equational constraint) 
(ii) d (existential constraint) 
where d is a desIcnator 
(ill) negation of (1) and (il) 
Fi~. 2 sh~#s the e~anple ~ra~uar rules and 
le"~ical entries in LF~, wl~ch senerate the 
c-structure and the f-structure in Fig. 1. 
1. s -> np vp 
(T subJ)=+ T=+ 
2. np -> det n 
1=~ T=~ 
3. vp -> v np np 
T=+ (T obJ)=~ CT obJ2)=+ 
~. det-> \[a\] 
(T spec):a (T num):s~ 
5. det -> \[the\] 
(T spec) =the 
6. n-> \ [g i r l \ ]  
(T nu~):sg ('~ pred):'glrl" 
7. n -> \[baby\] 
(T nun):sg (T pred)='baby" 
8. n -> \[toy\] 
(r num)=sg (T pred)='toy" 
9. v -> \[handed\] 
(T tense) =past 
(T pred)='hand<(~ subJ)(T obJ2)(T obJ)>" 
FiE. 2 Example ~rammar rules and lex~oal entries 
of LFG. (from \[Kaplan,Bresnan 82\]) 
As sh~n in Fi~. ~, the prlnltlves to 
re~resent ~r3~.atlcal relations are encoded in 
~ra~:aar rules and le~cal  entries. Each syntaotle 
node h~s i~s own f-structure and the partial value 
of the f-structure is defined by the Equational 
~ch~m. For exauple, the functional equation "(~ 
sub~)=$" associated with the dau~hter "np" node of 
~r~-u~r rule I. of Fi~. 2 specifies that the 
value of the "sub~" attribute of the f-structure 
of th~ ~other "s" node is the f-structure o/ its 
d~u~ter "np" node. ~ne value constraints on the 
f-~tructure are specified by the Constraln~r~ 
schema, i:oreover, the o~rauatlcallty of the 
sentence is defined by the three conditions shown 
bel~. 
(I) ~nlqueness: a particular attribute may have at 
:cost one value in a ~iven f-structure. 
(2) Completeness: a f-structure must contain all 
the ~overnable ~r~uatical functions ~overned by 
It~ predicate. 
(~) Coherence: all the ~overr~ble ~ran~uatlcal 
functions that a f-structure contain must be 
~overned by its predicates. 
ZZZ Z;~L~L:TATIO:~ OF L,.'G P~--~rTZVE~ 
As indicated in section iI, two distinct 
~chenata ~re enploycd in the constructions of 
f-~trucbures. In the current lupleuentatlon, 
f-3tructures are ~enerated durln~" the ~arslr~ 
process by executin~ the functional equations and 
~et inclusions associated with each syntactic 
node. After ~e  .,~urslr~ is done, the f-structures 
~.~ checked whether their value assicr~ents are 
consistent ~ith the value conutralnts on them. 
The Completeness condition on ~r~at lc~ l !~y  is 
also checked after the parsln~. ~e L~'~J 
primitives are realized by the Prolo~ procra~s and 
embedded into the DCG rules. The Equational 
schema is executed durln~ the parsln~ process by 
the execution of DCG rules. The functional 
equation can be seen as the extension of ~e  
unification Of Prolog by introduclr~ equality on 
f-structures. 
A. Representations of Data Types 
The prlnltlve data types constructi.~ 
f-structures are symbols, semantic predicates, 
subsidiary f-structures, and sets of sy=bols, 
semantic predicates, or f-structures. In current 
implementation, these data types are represented 
as fol lows: 
I) symbols ==> atem or In te~r  
2) semantic predicates ==> sea(X) 
where X is a predicate 
3) f-structure ==> Id:Obt 
where the "Id" is an identifier variable 
(ID-varlable). Each syntactic node has unique 
ID-variable which is used to Identify its 
f-structure. The "Obt" is a ordered blrmry 
tree each leaf contains the pair of an 
attribute and its value. 
q) set ==> {elementl, element2, ..., element;!} 
A f-structure can be seen as a partially 
defined data structure, because its value is 
partially Emnarated by the Equational schema 
during the paralng process. An ordered binary 
tree, obt for short, is suitable for representln~ 
partially defined data. An obt is a binary tree 
whose labels are ordered. A binary tree "Obt" is 
represented by an term of the following foru. 
Obt = obt(v(Attr,Value),Less,Greater) 
The "v(Attr,Value)" is a leaf node of the 
tree. The "Attr" is an attribute name and used as 
the  labe l  of  the lea f  node, and the "Value" i s  i t s  
va lue .  The "Less"  and "Greater"  are  a l so  b inary  
t rees .  The "Obt" i s  o rdered when the  "Less"  
( "Greater" )  i s  a l so  ordered and each labe l  of  i t s  
lea f  nodes i s  less  (g reater )  than the labe l  of 
"ObtW,i .e.  "At t r " .  I f  none of the lea f  of a t ree  
is defined, it is represented by a logical 
variable, l~en its label is defined later, the 
logical variable is In~antlated. The insertion 
of a label and its value into an obt is done by 
only oneunlflcatlon, without rewrltln~ the tree. 
This is the merit in uslnE an ordered blna~j tree. 
For m Y-mple, the f-structure for the noun 
phrase "a glrl", the value of the "subJ" in Fi~.1 
(b), can be ~-a~leal ly represented in Fig. 3. 
The "Vi"'s in Fig. 3 are the variables 
representing the unlnstantlated subtrees. 
B. Functional !~otatlon 
359 
iD-variable --> v(spec,a) 
v( nun ,  aS)  . . . . . . . . . .  + 
I 
~-- ..... v(per3,3) 
~i~. 3 
+. . . .+  
Vl v2 v3 v~ 
the ~raphical representalon of an obt 
The functional notations are represented by 
!D-variables instead of l~ta variables ~ and $, 
i.e. ~Mta variables must be replaced by the 
object level variable. For example, the 
designator (7 subj) associated with the category 
3, i s  described as \[subJ, IdS\], where Ida is the 
ZD-variable for S. ~e  meta variables for bounded 
dominance are represented by the terms 
controllee(Cat) and controller(Cat), where the 
"Cat" is the name of the syntactic category of the 
controller or ccntrollee. 
C. Predicates for LFG Primitives 
The predicates for each LFG primitives are as 
follows : (d,dl,d2 are designators, s is a set, 
and " is a negation symbol) 
I) dl = d2 -> equate(dl,d2,01d,New) 
2) d & s -> include(d,s,Old,New) 
3) dl =c d2 -> eonstrain(dl,d2,01dC,NewC) 
4) d -> exlst(d,OldC,~lewC) 
5) "(dl =c d2) -> ne&_constraln(dl,d2,01dC,~ewC) 
6) "d -> not_exist(d,OldC,~ewC) 
The "Old" and "New, are global value 
assIcnnenta. ~%ey are used to propagate the 
chan~es of ~iobal value assignments made by the 
execution of each predicate. The "OldC" and 
"~;ewC" are constraint lists and used to gather all 
the constraints in the analysis. 
Desides these predicates, the additional 
predicates are provided for checking a constraints 
durln~ the parsing process. They are used to k~ll 
the parsing process zeneratlng inconsistent result 
as soon as the inconsistency is found. 
~e  predicate "equate" gets the temporary 
values of the desi~nators dl and d2, consulting 
the global value assignments. Then "equate" 
performs the unification of their values. The 
unification is similar to set-theoretlc union 
except that it is only defined for sets of 
nondistlnct attributes. Fig. 4 shows the example 
trace output of the "equate" in the course of 
analyzing the sentence "a girl hands the baby a 
~oy". 
in order to keep grammar rules highly 
understandable, it would be better to hide 
unnecessary data, such as c!obal value assicr~ents 
or constraint lists. The macro notations similar 
to the original notation of LFG are provided to 
users for that purpose. The macro expander 
translates the macro notations into Prolog 
programs corresponding to the LFG primitives. 
The value of the designator Det is 
spec the 
The value of the designator ~! is 
hum sg 
per 3 
pred aeu(glrl) 
Result of unification is 
spec the 
hum sg 
per  3 
pred sem(glrl) 
Fig. 4 Tracing results of equate. 
This macro expansion results in considerable 
improvement of the wrltability and the 
understandability of the grammar. 
The syntax of macro notations are : 
(a) d l  = d2 -> eqCd l ,d2)  
(b )  d e s -> InclCd,s) 
Co) d l  =c d2 -> o(d l ,d2)  
(d) d -> ex(d)  
(e) "(dl  =c d2) -> not_c(dl ,d2)  
( f )  "d -> not~ex(d) 
These macro notations for LFG primitives are 
placed at the third arsument of the each predicate 
in DCG rules correspondln~ to syntactic categories 
as shown in Fig. 5 (a), which corresponds to the 
grammar rule I. in Fig. 2. 
s(s(Np, Vp),Id_$,\[\]) --> 
np(Np, I~_Np,\[eq(\[subJ,Id..S\],Id..:Ip\]), 
vp(Vp, Id_Vp,\[eq(I~_S, Id..Vp)\]). 
(a) The DCG rule with macro for LF~ 
s( s( Np, Vp), I~_$, Old, :;ew, 01dO, I~ewC) --> 
np( Np, IdJ1p, Old, Oldl, OldC, OldC1 ), 
{equate( \[subj, Id_S\], Id_~Ip, Oldl, 01d2) }, 
vp( Vp, Id__Vp, Old2,01d3, OldC1, ~ewC), 
{equate(Id_S, Id_Vp, Old3 ,New) }. 
(b) The result of macro expansion 
Fig. 5 Example DCG rule for LFG analysis 
The variables "~d_S", ,IdjIp,, and "Id_Vp" 
are the ID-variables for each syntactic category. 
For example, the ~rs=mar rule in Fi~. 5 (a) is 
translated into the one shown in Fig. 5 (b). 
~cro  descriptions are translated Into the 
corresponding predicate in the case of a ~r~ar  
rule. In the case of a le:cical entry, macro 
descriptions are translated into the corresponding 
predicate, which is executed further more and the 
f-structure of the lexical entry is generated. 
D. Issues on the Implementation 
Though f-structures are constructed durin~ 
the parsing process, the execution of the 
Equational schema is independent of the parsing 
360 
strate~'. This is necessary to keep the crayuaar 
rules highly declarative. There are some 
advantages of using Prolog in implementin~ LFG. 
First, the Uniqueness condition on a f-structure 
is fulfilled by the ori~inal unification of 
Prolog. Second, an ordered binary tree is a good 
data structure for representing a f-structure. 
The use of an ordered binary tree reduces the 
processin~ time by 30 percents compared with the 
case using a llst for representing a f-structure. 
And third, the use of ID-varlable also effective, 
because the sharing of a f-structure can be done 
oaly by one unification of the corresponding 
!D-variables. 
Though the computational complexity of the 
~quational schema is very expensive, the LF~ 
provides expressive and natural account for 
lin~ulstic evidence. In order to overcome the 
inefficiency, the introduction of parallel or 
concurrent execution mechanism seems to be a 
promising approach. The computation model of LFG 
is similar to the constraint model of computation 
\[Steele 80\]. 
~qe Prolos implementation of LF~ by Reyle and 
Fray \[Reyle, Frey 83\] aimed at more direct 
translation of functional equations into DCG. 
Although their implementation is more efficient, 
it does not treat the Constraining schema, set 
inclusions, the compound functional equation such 
as (" vco:~p subj), and the bounded dominance. And 
their z r~ar  rules seem to be too complex by 
direct encoding of f-structures into them. In 
order to provide an formal system havlr~ powerful 
description capabilities for representing 
syntactic knowled~es, the more LFG primitives are 
realized than their implementation and the ~rammar 
rules are more understandable and can be more 
easily modified in my implementation. 
Time used in analysis is 
972 ms. (parsing) 
19 ms.(checkin~ constraints) 
~I ms. (for checFin~ completeness) 
subJ spec the 
nun sg 
per 3 
pred sem(glrl) 
pred sam(persuade (\[subj, A\], \[obJ, A\], \[ vcomp, A\]) ) 
obj  spec the 
num sg 
per 3 
pred sam(baby) 
tense past 
vcomp subj spee the 
hUm sg 
per 3 
pred sam(baby) 
Inf ? 
pred sam(so ( \[ subJ, B\] ) ) 
to ? 
Fig. 6 The result of analyzi.~ the sentence, 
? the glrl persuaded the baby to So" 
VII. AC~I~!LEDGE~NTS 
The author is thankful to Dr. K. Furuka~a, 
the chief of the second research laboratory of 
ICOT Research Center, and the me, bars of the 
natural language processing ~roup in ICOT Research 
Center, both for their discussion. The author is 
grateful to Dr. E. Fuchl, Director of the ICOT 
Research Center, for providing the opportunity to 
conduct this research. 
!'~. ~i'-" RESULT OF A~' EXPER~NT 
Fig. 6 shows the result of analyzing the 
sentence "the ~irl persuaded the baby to go". LFG 
system is written in Dec-10 Prolog \[Pereira,et.al. 
73\] and executed on Dec 2060. 
As shorn in Fi~. 6, the functional control 
\[::aplan, Eresnan 82\] is realized in the f-structure 
of vp. ~e  value of the "subj" attribute of the 
"vcoup" is functionally controlled by the "obJ" of 
i;he f-structure of the "s" node. The time used 
for syntactic analysis includes the time consumed 
by parsinj process and the time consumed ~j 
~quational schema. 
V. CO:ICLUSTON 
The Prolog implementation of LFG is 
described. It is the first step of the formal 
nysteu for represent!nz syntactic kno~;ledzes. As 
"- result, it beco.&es quite obvious that Prolos is 
suitable for i:iD!e:~entln.- LFG. 
Further research on the for::al syster~ will be 
carried by analyzing the wider variety of actual 
utt-rznce~ to e':tract the more pri:~i tlves 
~-eces~.r." for the analyses, and to ~ive the 
;:ccesaary sc:-e:~aca for tho~e pri_~itives. 
VIII. REFEREIICE$ 
\[Kaplan, Bresnan 82\] "Lexical-Functlonal Gr~ar :  
A Formal System for Grammatical Representation" in 
~lental Representation of Grammatical Relations", 
Bresnan ads., I ET Press, 1982 
\[Reyle,Frey 83\] "A Prolog T_mplementation of 
Lexlcal Functional Grammar", Pros. of L/CAI-83, 
PP. 693-695, 1983 
\[ Perelra, at. al. 78\] "User' s Guide to D~C 
System- I0 Prolog", Department of Artificial 
Intelligence, Univ. of Edlnbur-:h, 1978 
\[Pereira,'.;arren 30\] "Definite Clause Gr-~--_r for 
Language Analysis -- A Survey of the For~...allsm and 
a Comparison with Au~ented Transition -'.'etworks", 
Artificial Intelligence, 13, PP. 231-278, I%80 
\[Steele 80\] "The Definition and !mpl-~uentation of 
a Computer Pr ogr -~.unin~. Lanzuase base~ on 
Constraints", .~ET AI-TR-595, 19~0 
361 
