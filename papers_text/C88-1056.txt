ILK',AI',LY ~V~NS\ ]  <{%{i~kq AND DEPENDENC~I PIHRSING 
J~ppinen, }hrri, Imssila~ \]~ro~ mld Lehtola,Aarr~ 
KI~Z,IKONE-project 
SITRA Foundation 
.P.Oo Plox 329~ 00121 Helsinki~ VINIAND 
'BJ-::~ paper desc\[J.~s the notion of \]pcall.y gove~:ned 
t~:ees as a n<x\]el of sttuCtu17ally \[estrfcted dependency 
st~:uctures of sentenc.eSo 2~n abstract umchine and its 
supporting softwa~:e to*. the building of local ly 
goqerned t~:ees is intr_(~iuced. The rest of  the paper 
dis~:usse,q \[.ew uuaM\]iguous~ ~<-'\].\]-for,~d local\]y governed 
i:~:ees can be parsed i l l  l.i\[~ea~: tia~ ~{~en cxertain 
~'tructural ~x~nstr~int's a~e in fuzce o 
'i~le phrase st~.ucture 1.ttle is a widely used primitive 
m)tation in literature when synt~Ictic structures of 
~euteuces d~?e discussed in a rJ.gorous ~f~nner o A 
n~ajority o;5 syntactic ~;:~rsJ.ng pr~jratt~ also utilize 
phrase st~.0cture rules in one vary or  another? 
Phrase: structure rules reflect the i~Kl-diate 
{79nstihuent analysis of sentences? Fach :1lle names a 
~x)nstituent 6rod its specified ordered e\].~-\[~nts on the 
lower levc\].o ~ts primitive ,~\]ations are {~erefo~'e 
part.~of-a--.~ho\]e and ooncatenationo In parsing, phrase 
structure rules arc used to s~u.'ch a hierarchical 
c~nstituen~ orgsnizatiop of the word string of a 
sentence o Phrase structure ~\ ]es  discover the 
hierarchicsl organization of a sentence~ but they do 
not tell. whdch words are the heads of the phrases (save 
f i le  X-trot theory /Jackendoff 1977/) nor de they 
further: sf?e<cify %~le ty\[x~s of the structural relations? 
Dependlency grau~-/rs ? in cxontrast ~ indicate the 
bi1~ary re).atious that hold between the words in 
sentences /~{@ys \].964 ~ ?-/aifamn \] 965, Robinson 1970, 
2~0m\]erson 1971~ Hellwig 1986, St~trostm 1986/. Neither 
non. 4~=~rmim!l sy~i~ol.s nor phrase struct\[~e rules have 
any ;cole to play because constituents are not looked 
for,, A p~ser  which ~0ploys dependency rules (rather 
than pbras,; structure rules) nmkes the beads and the 
\[types of binding celations explicit, but does not 
indicate the hierarchical constituent tx\]nfigurations of 
~sentences explicitly? We argue that dependency gra,~nars 
suit ~yet|-er than phrase structure rnles to 
non-oonfigt~ational~ free-word~rder languages~ 
\]\[nsofi~r as defxmdency r'elations are local (that 
is~ they hold bet~.en adjacent words or trees) and 
@~trttctive (that .i.s~ a recxx\]nized dependant is rex~oved 
p~o~,~)'tly from processing) deten~inistic parsing in 
'line.ar ti~,e often results? Fig= la illustrates this 
point for a si~zple intransitive-verb Finnish sentence 
~q, ienen ~-~jan "~iti t~uroi" (A/the ~s l l  boy's ~K)ther 
/ 
Adj~ttv C~tt?  Subject 
~=uuvui / 
G~i- .Subjcd 
. /  
~aje(~ G~s=~hth f J  
5 
P i~n poJwh glti l~ulol hw~kam laulu.. 
~J~ttr Go~tlr Subject t~J~t\]r '~- 
Obj~t 
l,mul~,i 
Subject , / "~ Object 
~lV~tt r ..~tl laulu=* 
~ojall . /hd jAt t  r 
MJ~ttr/ ~uskan 
ple~u 
b) A r~)n-nK)notonous dependency tree 
Fig? I. Parsing dependency trees 
Linear time is preserved in parsing also in many 
typical Finnish non-monotonous dependency trees if t ~s 
a default control ruler a word attenK0ts first to govern 
its left neigh|~ro ~ is  strategy is natural for Finnish 
as most i?odifieL's are of prepositional type? This rule 
was already ini01J.cit Jn Fig? la. (There are of cx)urse 
exceptions which must overrule this default strategy. 
For exan~gle, prepositions have their dependants, not 
their regents~ on their right side. ) 
Finnish sentences have typically SVO structure. 
Fig~ ib shows the l~rsing of an ordinary transitive- 
verb sentence "Pienen pojan ~\[iti lauloi hauskan laulu~l" 
(A/the small boy's r~ather sang a merry song). Parsing 
steps are indicated by the numbers between the words. 
This |roper elaborates the locality principle in 
de~endency parsing. First, we specify the ideas of 
local goverm~ent and locally governed trees? Then we 
describe a ~msic machine and its supporting software as 
an i~Kolementation of the locality principle for 
\]~rsing arbitrary locally governed trees. ~\]e parsing 
syste~l has been itKole/~ented for Finnish. Occasio~lly 
our  parser invokes expensive search because no 
prerequisites restrict trees ( save locality ). We 
discuss how parsing can be speeded up into linear time 
if certain rmtural structural constraints are in force. 
LOCAL CaOVF/RNMENT r LOCALLY GOVERNFa3 'IR~ES, AND 
DE~PENDENCY PARSING 
The ideological mlderpinning of local dependency 
parsing is to focus on adjacent word pairs and see if a 
binary dependency relation holds between them. The 
words of a sentence l~ve various attributes in our 
parser? Some of the attributes have been extracted by a 
Iro~l~bological preprocessor /J~ippinen and Ylilammi 
1986/~ while others are tagged during the parsing 
process o 
Local C~)ver m~nt  
Let <w I w2.. own> be an ordercml list of words? We say 
that a ~K)rd wj locally governs another word wj if| j = 
i-1 or i+l anti w i R wa where R is a binary dependency 
relatlon such that w i is the governor (or the regent) 
of the pair and .wj is the de~dant?  In other words, a 
word locally governs another one if they are adjacent 
(at the ~mt  of the testing) and a dependency 
relation holds between them. 
275 
The governor alone represents its government: once 
a local government has been established between two 
adjacent words the dependant is linked with the 
governor and disappears thereafter from sight. An 
elementary destructive processing step takes place, 
reducing the number of visible werds by one (shown by 
arrows in Fig. i). 
Government is transitive. If w i locally governs 
wj, and wj locally governs Wk, then w i governs w k. 
G6vernment-is also antisy~retric and irreflexive. 
Locally Governed Trees 
Due to the destructive processing step explained above, 
a governor gets a new neighbor immediately after a 
local government has been built. This new nelghbor 
qualifies for a local government as well. A single word 
may therefore locally govern a number of other words, 
and two initially distant words may later on establish 
a local government between themselves. If a word is the 
governor of several words simultaneously, we say that 
it governs a locally governed tree of depth one 
(LGT-I). In fact, we can view a (binary) local 
government as a LGT-I having just a single branch. 
LGT-I ' s are elementary trees. Relational trees 
which preserve the locality principle and can reach 
arbitrary depth are called locally governed trees 
(LGT). LGT's are defined recursively as follows: 
i. Any LGT-I is a LGT. 
ii. A tree formed by a word which locally governs 
LGT's is itself a LGT. 
\[~t <w I w 2 ... Wn> be a sequence of words. If 
there exists a LGT which governs all the words, the LGT 
is a parse tree of the words. Figure 1 portrays two 
parse trees. 
Parsing Strategy 
In the implemented parser the parsing strategy is based 
on the following two control principles: (i) parsing 
focuses first on the leftmost word (the initial word 
principle); (2) the parser always tries first to 
establish a focused word as a governor to its left 
neighbor and then shifts focus to the right neighbor 
(preferred direction principle). 
The resulting parsing strategy is a left-corner-up 
strategy. The strategy is tuned to efficiently bind 
prepositional attributes as dependants. 
TI~E MACHINE 
We have designed and implemented a parsing system for 
LGT's. The underlying abstract machine has one focus 
register and two stacks which bold the left and the 
right contexts of the focused word, respectively 
/Nelimarkka et al 1985/. Locality is enforced by 
permitting a focused word to bind dependants only from 
top of either stack - the left stack being preferred. 
The machine has also instructions for contextual 
testing. These tests may penetrate the stacks. 
THE SOFTWARE 
A high-level language FUNDPL (Functional Dependency 
Parsing Language) was designed for parsing locally 
governed trees /J~ppinen et al 1986b/. A precursor w~s 
a more procedural language DPL /Nelimarkka et al 
1985/. The system includes a con~piler and supporting 
progranming environment for the developmental work 
/Lehtola et al 1985/. 
A grammar description has three parts in FUhDPL. 
The initial part declares data types. The second part 
describes valid binary dependency relations. For each 
named binary relation the user specifies valid word 
pairs using morphological and/or lexical attribute 
values. The notation permits concise use of boolean 
operations on attributes. 
276 
The third part of a grammar description defines a 
set of functional schemata. Functional schemata have 
beth declarative and procedural readings. From the 
declarative point of view, functional schemata define a 
set of valid LGT-I's. Each schema describes a regent 
and its possible local governments? 
A local government is either mandatory or 
optional, and an optional one may recl~ By default the 
surface ordering of local gover~nents is free. 
Sometimes stringent ordering constraints exist l~t~een 
local governments; sometimes it is advantageous t~ give 
probabilistic information about the ordering of 
positionally free governments. Such structural 
information may be written in a schema. 
Schemata have also procedural reading which is yet 
another distinguishing feature from phrase structure 
rules. A schema actively controls the build-~up of 
the LGT-I it represents. From the preoedural 
viewpoint a schema monitors function calls of local 
governments using blackboard control regime /Valkonen 
et al 1987/. 
THE SEARCH PROBLEM OF PARSING ARBITRARY LGTgS 
To discover a parse tree for an arbitrary If&T is a 
complicated search process even in a bettom-up 
strategy (in top-down problems would be worse)? The 
basic problem is this: how does an algorit~n know on 
which level in the hierarchy a given word belongs to? 
That is, when parsing proceeds from left to right and 
an attempt is made to establish the right neighbor of a 
governor as a dependant, the link is possible only if 
that word is not a governor of a yet incomplete T~To 
Our left-corner-up strategy occasionally has to invoke 
coraplex search for this reason. 
If a language constrains the structures of its 
possible LGT's, LGT's become computationally much more 
economical devices. The problem discussed above does 
not arise with constituent grammars and phrase 
structure rules because these rules indicate hierarchy 
implicitly through the naming of the constituents. 
CONSTRAINED LGT ' S 
Finnish is a highly inflectional, agglutinating 
language. Both verbs and nominals have numerous 
distinct surface forms which distinguish between 
different syntactic functions the words can have in 
sentences. Word forms carry, among other things, such 
syntactic information which in configurational 
languages is indicated by the precedence relation. Word 
order in Finnish is relatively free. 
The basic Finnish sentence configuration is SVO. a 
subject LGT is followed by a verb, an object LGT, and 
possible adverbial LGT's. Topicalization, wh-movement, 
and other movements create variations to this basic 
configuration. 
The shape of nominal LGT~s is markedly distorted. 
They have almost all modifiers on their left hand side 
forcing them to lean to the right. The most important 
modifiers are adjectival and genitive? Adjectival 
attributes modify the head noun iterativelyf as in the 
phrase (i). 
(i) Nuori pitk~ vieh~tt~v~ tytt6 
Young tall charming girl 
Genitive attributes, themselves nominals~ im~dify 
head nominals recursively, as in the phrase (2). 
(2) X~tSn is~n tySnantajan auto 
Girl (gen) father (gen) employex (gem) car 
(A/the girl's father's esloloyer'S car) 
Other prepositional modifiers for nouns are 
quantifiers and demonstrative pronouns. Prepositional 
modifier types can be mixed (under certain 
restrictions) as in the phrase ( 3). 
(3) T~m~n nuoren vieh~tt~v~n tytb'n vanha kiero is~ 
This young charming girl (gen) old crooked father 
(This young charming girl's old crooked father) 
Prepesitionality of Finnish is also demonstrated 
by the fact that postpositions are common but 
preposition.3 rare. Nouns have also occasional 
postpositio,~ll nondnal modifiers, but these modifiers 
can be governed only by the maximal nominal heads of a 
LGT (the governors which fill the valencies of verbs) 
or by anolJler postpositionally modifying r~T. For 
example, the nominal phrase (4) 
(4) suuren ~niehen pieni auto talon takana 
big man (gen) small car (nora) house (gen) behind 
(a/the big man's small car behind the house) 
has the I~.I',. ~ shown in Fig. 2. The postpositionally 
n~xlifying adverbial LGT "talon takana" (behind the 
house) cannot modify the genitive attribute: *suuren 
miehen talon takana pieni auto. 
GonAttr auto  AdvAt tr 
? .~-~-~ i 
m~ehen ~Ad Attr"tr'-'~II~ akana 
AdjA~ra?" IJie~i " ta lo l~Objoct  
SIIIII'611 
Fig. 2? Postpositional modifier. 
AN EFFICIENT PARSING ALGORITHM FOR LGT'S 
The basic left-corner-up algorithm can be modified so 
that it hierarchically first builds nominal LGT' s 
without post0ositional modifiers, then LGT's governed 
by prepositions and postpesitions, then mgminal IGT's 
with postpositional modifying nominal LGT's, and 
finally the LGT governed by the finite verb. The 
structural constraints of LGT's prune search, and it 
can be p~oved that the algorithm 1~en parses 
unambiguous sentences in linear time. The following 
restrictions are assumed: 
i o Adjectives, quantifiers, and adverbs have nnly 
prepositional modifiers. 
ii. Nouns have postpositional modifiers only on the 
maximal level. On lower levels they have only 
prepositional modifiers. 
AMBIGUITY A~) WELL-FORM~DNESS 
The modified algorithm presumes that LGT' s are 
unambiguous. None of the bound dependants should not 
qualify as a dependant to any other governor than the 
one chosen. Because the algorithm removes dependants 
after binding, it cannot cope with alternative 
relations. 
Albeit r ich morphology greatly helps to make 
unique distinctions between different binary relations 
in Finnish, it leaves some residual ambiguity. The most 
prominent example is caused by the genitive surface 
case. That ~mse signals either accusative case, the 
object of a ~,~entence, or possession. The governor of an 
adverbial n~i~ also be ambiguous. The basic algorithm 
solves ambi9%~ity by backtracking. 
In their "pure, form beth algorithms parse only 
well-formed \]~T's. 'Ilhere are, however, soa~.~ well known 
syntactic phenomena which cannot be represented by 
iGT's. TG-theory postulates oertain transformations 
which result in long-distance dependencies. In modern 
GB-theory tl~se displacement operations 9~) under the 
general rubric "move-alpha". 
For exanple, certain fronting n~vements 
(wh-movement and topicalization) remove an element and 
may transport it across clause boundaries onto a 
landing site in the beginning of the main sentence. A 
I~T which originally was governed locally becomes 
distant to its governor and is no more within its 
reach. 
The algorithm can be augmented to handle 
long-distance fronting movements. At one point the 
algorithm has built nominal and adverbial LGT's. The 
valencies for a verb are filled first locally and, if a 
filler cannot be found, a search is made from the 
fronted LGT's. The resulting LGT is not well-formed. 
OONCLUSION 
We have introduced the notions of local government and 
locally governed trees to express restricted dependency 
structures. Their ecmputational counterparts are binary 
dependency relations ( for local government ) and 
functional schemata (for locally governed trees of 
depth one). We then briefly mentioned a parsing system 
which we have implemented for parsing dependency 
structures of Finnish sentences. We then discussed how 
the algorithm can be augmented into a multilevel model 
which takes into account varying structural c~nstraints 
in different levels of sentence hierarchies. Linear 
parsing time ensues for unambiguous well-formed locally 
governed trees. 
REFERENC~ 
Anderson, J.M., Dependency and grammatical functions. 
Foundations of Language 7, 1971, 30-37. 
Gaifman, H., Dependency systems and phrase-structure 
systems. I Information and control 8, 1965, 
304-337. 
Hays, D., Dependency theory: a formalism and some 
observations. Language 40, 1964, 511-525. 
Hellwig, P., Dependency unification grammar? COLING'86, 
Bonn 1986. 
Hudson, R., Arguments for a Non-transforn~tional 
Grammar. The University of Chicago Press, \]976. 
Jackendoff, R., X-bar Syntax: A study of Phrase 
Structure. Linguistic Inquiry, Monograph Series 
Two, The FLIT Press, 1977. 
Jgppinen, H. and Ylilammi, M., Associative model of 
morphological analysis: an empirical inquiry. 
Computational Linguistics, Vol. 12, No. 4, 1986a. 
J~ippinen, H., Lehtola, A., and Valkonen, K., ~%mctional 
structures for parsing dependency constraints. 
Proc. COLING86, Bonn, 1986b. 
Lehtola, A., J~ppinen, H., and Nelimarkka, E., 
Language-based environment for natural language 
parsing. Proc. 2nd EUROACL, Geneve, 1985. 
Nelimarkka, E., J~ippinen, H., and Lehtola, A., Parsing 
an inflectional free word order language with 
two-way finite automata. In O'Shea, T. (Ed.), 
Advances in Artificial Intelligence. 
North-Holland, 1985. 
Robinson, J., Dependency structure and transformational 
rules. Language, Vol. 46, No. 2, 1970. 
Starosta, S. and Nomura, H., Lexicase parsing: a 
lexicon-driven approach to syntactic analysis. 
OOLING'86, Bonn, 1986. 
Va\]\]~onen, K., J~ippinen, H., and Lehtola, A., 
Blackboard-based dependency parsing. IJCAI87, 
Milan, 1987. 
277 
