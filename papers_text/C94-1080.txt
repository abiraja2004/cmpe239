CONCURRENT LEXICALIZED DEPENDENCY PARSING: 
A BEHAVIORAL VIEW ON ParseTalk EVENTS 
Susanne Schacht, Udo tlahn & Norbert Br6ker 
CL I \ ] -  Computational Linguistics Research Group 
Freiburg University 
D-79085 I:reiburg, Germany 
email: {sue, hahn, nobi }@coling.uni-freiburg.dc 
Abstract. The behavioral specification of an obj~t-ori- 
cnted grammar model is considered. The model is based 
on full lexicalization, hcad-oricntation via valency con- 
straints and dependency relations, inhcritancc as a means 
for non-redundant lexicon specification, and conct, rrcncy 
of computation. The compntation model relies upon the 
actor l)aradigm, with concurrency entering throt~gh asyn- 
~:hronous message passing between actors. In pa,ticular, 
we here elaborate on principlcs of how the global lyzhavior 
of a lexically distributexl grammar and its corresponding 
parser can be specified in terms of evcnt ype networks and 
cvent networks, resp. 
1 INTRODUCTION 
In this paper, we propose a grammar model that combines 
lexical organization of grammatical knowledge with lexi- 
calized control of the corresponding parser in a coherent 
object-oriented specification framework. We build upon 
recent developments in the lield of linguistic grammar the- 
ory which have already iekled a rigid lexical mod,lariza- 
tion, but extend thcm by assigning full procedural auton- 
omy to lexical units. In particular, we treat lexic,'ll items as 
active lexieal processes commtnticating with each other by 
message passing. Titus, they dynamically establish etero- 
geneous communication lines in order to dctcnninc each 
lexical item's fimctional role. While the issue of lexieali- 
ze(I control has early becn invcstigatcd in the l)aradigm of 
conceptual parsers (e.g., Riesbcck & Schank 1978), and 
word expell parsing in particular (Small & Ricger, 1982), 
we here elaborate on improving ils lcxical commtmication 
facilities by formalizing the parscr's message passing pro- 
tocol according to actor computation principles. As this 
protocol allows for asynchronous message passing, con- 
currency enters as a theoretical notion at the level of grant- 
mar specification, ot only as an implcmentational fcatttrc. 
Correspondingly, we introduce a behavioral description in 
terms of event ype networks which rcpresent grammatical 
interrelations at the level of actor definitions, while event 
networks represent the I)arsing process in terms of actual 
messages exchanged between instantiated actors. The Par- 
seTalk model outlined in this paper can thereft)re be con- 
sidcred as an attempt o rcmedy the lack of theoretical 
integration of parallelism at the level of grammar design. 
2 ParseTalk's GRAMMAR MODEL 
The ParseThlk grammar mcxlel (of. Br6kcr, Hahn & 
Schacht (1994) for a more comprehensive treatment) con- 
siders dependency relations between words as the funda- 
meatal notion of lingnistic analysis. This corresponds to 
the head-orientation found in most modern grammar theo- 
ries. Grammatical spccilications are given in the format of 
valency constraints attached to each lexical unit, on which 
lhe comptttalion of concrete dependency relations is 
based. A modilicr is said to depend on its head if the mod- 
ifier satisfies the constraints placed on it. These constraints 
incorl?)rate iulormation about the hierarchy of word 
classes (encapsulating declarative and behavioral proper- 
ties of lexical items), nmrphosyntax (containing Ihe gram- 
malical conditions of the combination of lcxical items to 
l)hrascs as expressed by a unification \[ormalism, similar to 
Shieber, 1986), linear ordering (stating precedence rela- 
tions between ahead and its modiliers), and permitted con- 
ceptnal roles (expressed in terms of a hybrid, classilica- 
tion-based knowledge represenlation formalism; cf. Mac- 
Gregor, 1991). Dependencies are thus asymmelric binary 
relations that can be established by local computations 
involving only two lexical items 1 and simnllaneonsly ake 
grammatical s well as conceptual well-formedness crite- 
ria into account. 
P,y way of inheritance (for a rcccnt survey of apl)lying 
inheritance mechanisms in modern gramlnar theory, of. 
l)aclemans, I)e Sine(It & Gazdar, 1992) the cnlirc collec- 
tion of lexical items is nrganizc(l in a lexieal hierarchy, the 
lexical items forming its leaves and the intermediary nodes 
representing grammatical generalizations in terms of word 
classes. This form of specification is similar to variotts 
proposals currently investigated within the unification 
grammar connnunity (e.g., Evans & Gazdar, 1990). 
t We exlend this definition to incoqxmLtc the notion of phrases as well. 
Ahhough phrases are not explicitly represenled (c,g., by non-lexical 
categories), we consider each complete suhtrce of Ihe delx~ndency tree 
a phrase (Ihis definition allows discontinuous phrases as well). A 
dependency is thus not trealed a~: a relation between words (as in Word 
Grammar (lludson, 199(\], p.1171, but between a word and a dependent 
phrase (as in l)epcndency Unification (\]rammar (llellwig, 1988)). The 
root of a phrase is taken to be the rel~resent:ttlve of tim whole phrase, 
489 
3 ParseTalk 's  COMPUTATION MODEL 
Although the object-oriented pm-adigm seems to bc well 
suitexl to support he distribution of data through encapsu- 
lation and the distribution of control via message passing, 
most object-based calculi rely on synchronous messages 
and dmrcfore do not provide for concurrency. One of the 
few exceptions that aim at the methodologically clean 
combination of object-oriented features with concurrency 
and distribution is the actor model of computation (Agha 
& Hewitt, 1987). It assumes a collection of independent 
objects, the actors, communicating via asynchronous, 
point-to-point message passing. All messages art guaran- 
teed to be delivered and processed, but in an unpredictable 
order and indeterminate ime. Each actor has an identity 
(its mail address), a state (consisting of the addresses of its 
acquaintances, i.e., the set of other actors it may send mes- 
sages to) and a behavior (i.e., its reaction to incoming mes- 
sages). Tile arrival of it message at an actor is called an 
event; it triggers an action described by the corresponding 
method definition, a composition of the following atomic 
actions: creating a new actor (create actorType (acquain- 
tances)); sending a message to an acqtminted or a newly 
created actor (send actor message); or specifying new 
acquaintances for itself (become (acquaintances)). An 
actor system is dynamic, since new actors can be created 
and the communication topology is reconfignrable in the 
course of actor computations. 
The actor model does not contain synchronization 
primitives, but we assume one-at-a-time s rialized actors 
for our specification, i.e., actors that cannot process more 
than out message at a time and that process each message 
step by step (cf. Hcwitt & Atkinson (1979) for expressing 
this convention in terms of patterns of simple actors). The 
distribution of comlmtation among the collection of actors 
is dins dm only source of parallelism. Furthermore, in or- 
der to compute complex, but well understo~x\[ and locally 
determined linguistic conditions and functions, such as 
unification of feature structures iuld queries ent to a (con- 
ceptual) knowledge base, we esud)Iish a synchronous re- 
quest-reply protocol (of. Licberman, 1987). 
The ParseTalk model extends Ihe formal foundalkms 
of the basic actor model according to the requirements set 
up by tilt natural anguage processing application. These 
extensions are expressible by the primitives of the basic 
model. We distinguish between word actors, relations 
between word actors and a special set of messages word 
actors exchange. 
? Word Actors: The grammatical knowledge associated 
with each lexieal item is represented in a word actor 
definition. Upon instantiation of a specific word actor, 
d~e acquaintances specilied in the definition will be ini- 
tialized with actors which stand for the lexical item's 
morphosyntactic features, its conceptu,'d representation, 
valency constraints and, after instantiation and subse- 
quent parsing events, governed lexical items and further 
grammatical relations (e.g., adjacency, textual rela- 
tions). 
? Word actor relations: Acquainumces of word actors 
are tagged according to linguistic criteria in order to 
serve as navigation aids in linguistic structures (the 
message distribution mechanism described below). Tex- 
tual relations, e.g., are distinguished from linear adja- 
cency and hierarchical dependency relations. Tagging 
imposes a kind of typing onto acquaintances that is 
missing in odmr actor systems. 
? Word actor messages: In contrast o simple messages 
which unconditionally trigger the execution of the cor- 
responding method at the receiving actor, we define 
complex word actor messages as full-lledgcd actors 
with independent computational capabilities. Departure 
and arrival of complex messages are actions which are 
performed by the message itself, laking the sender and 
the target actors as parameters. Upon arrival, '~ complex 
message determines whether a copy is forwarded to se- 
lected acquaintances of its receiver and whether the re- 
ceiver may process the message on its own. Hence, we 
redefine an arrival event to be an uninterruptable s - 
quence of a computation event and distribution events. 
The computation event corresponds to an re'rival of a 
simple message at the receiving word actor, i.e. an event 
in the basic model; it consists of the execution of an ac- 
tor's lee(hod that may change the actor's tate and trig- 
ger additional messages. The distribution events pro- 
vide for the lorwarding of the message and are realized 
by cre,qtiug new complex mess.ages. They depend on the 
(unchanged) state of the receiving actor or on the result 
of the computation event and take place before and after 
the computaliou event. This extension accounts for the 
complexity of interactions I)ctween word actors. 
We define tl~c semantics of an actor program in terms of 
two kinds of networks. First, we consider event types 
which refer to message keys and can easily be determined 
from ,'1 given actor program. Next, we turn to actual events 
that involve instantiated actors. Both, event types and 
events, arc partially ordered by the transitive closures of 
relations alll()ng them, causes t and causes, resp., that give 
rise to event type networks and event networks. 
A program (in our apl)lication: a lexical grammar) is 
given by a set of actor d@nitions. The definition charac- 
lerizcs the type ()1" an actor. Given a program, event types, 
written as I* <- key\], can be syntactically deterlnined by 
inspecting the method delinitions wilhin the program. Let 
an actor type aName I)e defined by: 
.?kelg?J.~ aName (acquaintance 1 ... acquaintancek) 
meth key 1 (param 1 ... paramrn ) (action1) 
. . .  
meth key n (param 1 ... paraml) (actionn) 
with action i delincd by the following grammar fragment: 
action ::= action; action 
\] if condition (action) \[ ~ (action) \] 
I .keJ3?L actor messageKey ( param* ) 
\] becom_____~e ( acquaintance* ) 
Wc may now map message keys to sets of message keys, 
defining the function sctipt~,r~zm e as follows: 
490 
scriptaNa,ne : Keys -4 2 7(?~. 
scriptaA(ome (keYi) = send(action!) with 
sent{(action) := 
{msgKey } if action = send actor msgKoy (param, ...) 
setu{(al) u sertd{a2) if action = \[\[ condition a I else a 2 
sent{(al) if action = if condition a 1 
sentf((at) u senaC(a2) if action = a l ;  a2 
else 
For a program P, script is the union of all given script,m,, e 
with name e { aroma I P contains a delinition for aNamo } 
and yields a set containing the keys of those messages that 
can be provoked by a ,nessage with the key mKey. Now, a 
relation between event types is delined hy causes!: 
(\[* ?= mKey\], \[* ?=- nKey\])  < cat tses  t 
:<=> nKey ~ scrit)t(mKey ). 
Turning to actual events now, we define an actor a/as being 
composed of an identity n (taken from lhe set of natural 
numbers, N), a state e Sand a behavior e 9{. l lence, .9/, 
the set of actors, is a subset of N x S x O~. 
,5 = 2 { (y: z,) ly is an identifier, z e A\ ] ,  an  element of`5 asso- 
ciates acqna in tance  names  and va lues ,  wh ich  are  actors .  
Since actors change their acquaintances, their state is valid 
in lime, i.e. lit a par t i cn la r  event .  The  state  o f  an ac tor  a. 
receiving a message m will be written as S?l a <= ml' Slate 
changes caused by the message apply at the end of the 
event \[a <=- m\] (by executing a become action). 
q# is a set of fnnetions, delhted as folk>ws: The state 
s<, e of an lictor ,X'flt tile event e (the reception of a mc.ssage 
m) is determined by iL,; initial state given after its creation 
event, arid the repeated application of its state transition 
function, transit~c, which maps pairs of stales (s c S) and 
messages (m ~ 9?1 c .90 to new slates: 
tra,sitx: (`5 x 9t4} -> ,5 
The sand actions an actor ,1" perlk)rms at a partictflar event 
are expressed as pairs of target actors and messages to be 
sent; the target actors are either ,'lcqnainlances o\[" the send- 
ing actor or supplied as message parluneters. They are de- 
termined by the function 
task~ (,5 x Ov 6 -> 2 (m('q) ? ~6 
where ~l(N) denotes the projection onto the first compo- 
!tent of N, viz. N. 
The behavior of an actor A'can then be stated by the 
function be~ar;e~Ce q~ that comhines transit,@nd tas~.,,f.in 
that it maps pairs of suites and messages to pairs consisting 
of the new slate of the actor and a set of pairs of target 
actor identities and ,nessages, viz., 
bebave~: (S x 9v~ -> ( S x 2 (Tq(& x 94)). 
Abstracting from a local actor perspective the behavior 
of an entire actor system (in our applicatkm: lhe lexical 
parser composed of a collection of word actors) is deter- 
mined by the way multiple events are related under Ihe 
causes relation (though events are written as \[actor <= 
,nessagel, the message key is used as an abbreviation for 
the messages in Section 5): 
( \ [a~ nil, \[,6<=- hi)< ca,ses 
:?~ (Xl(&, '0 e tasfCa(Sa,\[a~ ml, "0. 
Event.'.; that ;ire not ordered by the transitive closure of 
causes can take place in parallel or, if they refer to the 
same lictor, ill an arbitrary order. 
4 EVENTTYPE NI . , ;TWORK SPECIF ICAT ION 
OF  A GRAMMAR FRAGMENT 
The protocol (messages and associated actions) for estab- 
lishing dependencies on!lined below encodes structural 
restrictions of the dependency structure (projectivity), 
ensures incremental general!on of dependency trees, and 
provides a domesticated fornl of concurrency. 
Consider a newly instantiated word actor wn (cf. Fig. 1) 
se,'!rching bottom-up for its head by sending a search- 
Head message to its immediate left neighbor, w,. l. The 
searchHead message is recursivcly forwarded by a se- 
quence of distrihution events to the head of each receiving 
actor (i.e., w,,_ I, w k, wj); mess,'lges only p.'lss the outer 
fringe of the already eslablished dependency tree (these 
am circled in lvig.1). Since only the actors receiving the 
searchHead message may later govern w n, projective 
trees are generated 2. 
""X -~- - - searchHead \] 
, /  " ' ~  i,j,k,n: text positions / 
z z .~  " ' -o  
?'i ~ ....... % 
I;iflure l, \[:olwarding a search message 
To allow for domesticated concurrency as required for 
adequate linguistic and cognitive processing (Clark & 
Gibson, 1988), a receipt protocol allows w n to keep track 
of all events (transitively) caused by its searchHead mes- 
sage. This protocol requires each actor receiving a search- 
Head message to reply Io the initiator of the searchHead 
message hy a receipt message when the receivers compu- 
lalion has linished 3. Since complex messages can be 
quasi-recursively forwarded, the number of replies cannot 
be determined in advance. Therefore, the receipt message 
contains all actors to which the searchHead message has 
been dislrihnted, enabling the initiator w n to keep Irack of 
all receivers and wait for a receipt message from each 4. 
Only after all events caused by the searchHead message 
have terminated, the next word actor w,,~l is instantiated 
by sendiag a scanNext message to the text scanning actor. 
2 Of coutse w may be l, ovemed by any word actor govemhlg w. lml ' ' I1  J ,p  
due (o Ih? incremenlality of the analysis, each head c,f wj must Im 
hx!ated to Ihe right of w n. 
3 Note Ihat "eom\[\]tllalioll" here may irldlltIe a tll.llllbef of evetlls Lhat are 
caused by Ihe soarchHoad message, viz. the hoadFound and hoadAa- 
copted messages described below. 
,I We plall I0 extend our algolilhm It, a gCllefic \[efl1"litla|\[olI dcteclion 
scheme similar to tim proposal in Shavit & France;,,, 1986. 
491 
I I'1O Cotlslrailll / I conxtraml I / ..~./;~o~,, t 
\[satisf ied / \[ ..... ;",.~,,/ \[ / . . . . .  J~ '~J  Istructural \] 
.. ~ . ~ ' ~  / l ambigm' ty  J ~ ~ , 
L - " t. I )..,i,.. I 
? , ? .- modijiers' 
j ( ,.<=-,.,,...,-o, j \]i<-.,,o. I..o..,, . . . .  , , L'/J 
Figure 2. Event type network 
Upon reception of a searchHead message,  a word 
actor w k checks whether w n satisfies the couslraints for 
one of Wk'S valencies. If no constraints are satislied, a 
receipt message is sent back to signal termination of this 
particular event at w k. If w n may Iill a valency of w k, a 
headFound message is sent back to w,, thus possibly 
imposing additional grammatical restrictions on the tar- 
geted item. If w, is still ungoverned, it adjusts its gram- 
matical description (and those of iLs modiliers, if neces- 
sary, by sending updateFoatures to each) and signals 
acceptance of the new head hy a headAccepted message 
directed to w k. These interrelations are sttmmarized in the 
event ype network in Fig.2. 
This three-step protocol allows ,qlternative attachmenL,; 
to be checked in parallel (concurrent processing of 
searchHead messages at different actors). Structural 
ambiguities are detected whenever a headFound message 
arrives at an actor w n which is already governed. In this 
case, w n duplicates itself and its modifiers (using the 
copyStrueture message), resulting in w,, and asks the 
prospective head to copy itself (hy sending a duplicat- 
eStructure message), w n becomes head of the copies of 
the modifiers of w n (because ach is answering the copy- 
Structure message with a hoadAccepted message) and 
will be governed by the copy of the head (because the 
copy sends another headFound message to wn; for a more 
detailed discussion, of. Hahn, Schacht & BrOker, forth- 
coming). 
The unpacked representation f antbiguity is necessary 
because of the simultaneous incorpor,'~tion of conceptual 
analysis into the parsing process. Difl'ercnt syntactic struc- 
tures result in different conceptual nalyses, which means 
fllat there is no common structure to share anymore (cf. 
Akasaka (1991) for a similar argument). The set of actors 
representing several readings of one lexical item can pro- 
ceed concurrently, thus introducing further concurrency. 
5 EVENT NETWORK SPECIF ICAT ION OF A 
SAMPLE PARSE 
We will now consider a partM event network in order to 
illustrate the parse of "Compaq entwickelt  einen Notebook 
mit  einer 120-MByte-Hardd isk  "5. At some point after 
reading the sentence, the configuration shown on I7ig.3 
will h;tve been reached. The preposition \[mit\] 6 is not yet 
integrated ue to a mandatory valency that must tm satis- 
lied prior to making conceptual restrictions available. 
Upon establishment of a corresponding dependency be- 
tween Imit\] and \[ttarddisk\] (Fig.3), \[mit\] slarts to search 
for its head. This search results in the dependency tree 
depicted on Fig.4. 
enlwickelt 
Compaq No|el)ook 
einen 
mit 
120-MB-ltarddisk 
/ s~Jec  
einer 
Figure 3. Contiguration before application of "mit" via saarehHead 
entwickelt 
Compaq Notebook 
einen m i %  
120-M B-I larddisk 
einer i 
Figure 4. After establishment of dependency 
The events caused by the satisfaction of the mandatory 
valency at \[mit\] (headAecepted event at top left of Fig.5) 
\[mit\] <= ileadAt:cepted ) 
i 
l,'igure 5. Event network 
5 A rough English translation of this reads as "Compaq develops a note- 
book with a 120-MByte haul divE'. Notice that from a syntactic per- 
speclive cilher Ihe verb "entwicla~lt" or the noun "Notebook" may take 
a preposilional phrase wifll "mlt" specifying an instrument or a part, 
resp. This |x~teutial stnlctural ambiguity dc~s not (recur in our m~xlel 
due to parallel evalualicm of constraints in different knowledge sources. 
6 Word actors represenllng a lexical item "x" will be wrilten as \[x\]. 
492 
are specified in tim event network in Fig.5. The dotted line 
indicates an alternative possibility how the seanNext 
event could have been triggered. Of the two receipt events, 
the last one taking place triggers the seanNext event (note 
that both involve the same actor, (mitt, so that they must 
be ordered, even in a distril)utcd system without global 
lime). 
6 CONCLUSIONS 
The ParseTalk model of natural language understanding 
aims at the integration of a lexically distributed, depen- 
dency-I)ased grammar Sl)CCification with a solid formal 
foundation for concurrent, object-oriented parsing. The 
associated concurrent compu~ttion model is based el} the 
actor paradigm of object-oriented programming, with sev- 
eral extensions relating to special reqtfirements of natura l  
langtmge processing. These cover mechanisms for com- 
plex message distribution, synchronization i  terms of 
request-reply protocols, and the distinction of dislriht, tion 
and computation events. We have shown how the semantic 
specification of actor systems can be used for the consider- 
ation of global interrelatious of word actors at the gram- 
mar level (event ype networks) and the parser level (event 
networks). While event type networks provide a general, 
global view on the behavioral aspects of ottr grannnar 
specification, the current formalism slill lacks the ability to 
stlPi)ort ret inal  reasoning about computat iona l  prope, rties 
of distributed systems, such as deadlock freeness, termina- 
tion. On tim oflmr hand, event networks illustrate the cont- 
imtations during real parses, but do not allow predictions 
in general cases. Providing a type discipline for actor deti- 
nitions may Ix: a reasonable apl)roach to till the method- 
ological gap between both layers of description. 
The ParseT?flk model has been exlmritnentally vali.. 
dated by a prototype system, aparser for Germ;re. The cur- 
rent fifll-form lexicon contains a hierarchy of 54 word- 
class specifications and nearly 1000 lexieal entries; amod- 
ule for lnorphological nalysis is trader development. The 
parser's coverage is currently restricted to the analysis of 
assertional sentences, with focus on complex noun and 
prepositional phrases. The Parse'l?flk system is imple- 
inented in Smalltalk, with extensions that allow for coarse- 
grained parallelism through physic,'d distribution in a 
workstation cluster (Xu, 1993) and asynchronous ntessage 
passing. It is loosely coupled with lhe l.OOM knowledge 
representation system (MacGregor & Bates, 1987). We 
currently use a knowledge base with 120 concept delini- 
}ions covering the domain of information technology. Fur- 
thennore, an interactive graphical grammar/parser ngi- 
neering workbench is supplied which supports the devel- 
opment and maintenance of the ParseTalk grammar sys- 
leln. 
Acknowledgments 
The work reported in this paper is funded by grants fl'om 
DFG (grants no, l la 2097/1-l, t la 2097/1-2) within a spe- 
cial research programme on cognitive linguistics. We like 
to thank our colleagues, P. Neuhaus, M. Klenner, and Th. 
llanneforth, for valuable comments and supllort. 
References 
AGIIA, G. & IIEWI'Iq; C, (1987). Concurrent programming using 
actors, In A.Yonezawa & M. Tokoro, Eds. Object-Oriented Concur- 
rent l'rogramming, pp.37-53. MIT Press. 
AKASAKA, K. (1991). Parallel parsing system based on dependency 
grammar. In C. ltmwn & G. Koch, Fxls. Natural Language Under. 
standing and logic Programming, IlL pp, 147-157. North-I lolland. 
BR(')KF.R, N.; \]IAIIN, U. & SCI1ACIIT, S. (1994). Concurrent lexicali- 
zed dependency parsing: the l'arseTalk model COLIN(; '94: Prec. 
15th Intl. Conf. on Computational Linguistics (this volume). 
CI.ARK, R. & (\]\]I~.SON, E. (1988), A parallel m(xlel for adult sentence 
processing. Prc, c. lOth Annual Conf. of the Cognitive Science Soci- 
ety. pp.270-276, l lillsdale, N J: 1.. F.rllxmm. 
DAFI.EMANS, W.; l)e SMEDT, K. & GAZI)AI~, (1. (1992), Inheritance 
in natural language processing. Computational l,inguistics, lg (2), 
205-218. 
FVANS, R, & GAZI)AR, G. (199(}). "lTae DATR Papers, Vol. 1, Univ. of 
Sussex, IIrighlon. (Cognitive Science Research Paper, CSRP 139). 
IIAIIN, U.; SCIlACIIT, S. & FIR()KF.R, N. (fonficoming). Concurrent, 
object-oriented natural language parsing: tire ParseThlk m(xlel. 
International Journal of Ilnman-Computer Studies, SF, ecial Issue 
on Object-oriented Approaches in Artificial Inlelligenee and 
Ilnman-Computer Interaction, 
tlF.I.I~WIG, 1~ (1988). C.fiart parsing accolding to tire slot and filler prin- 
ciple. COLING '88: Prec. 12th Intl. Conf. on Computational Lin- 
guistics. Vol.l, pp.242-244. 
IIF.WITI', C. & ATKINSON, R, (1979). Specification and proof tech- 
niques R~r smializers. Iied;J ;. Trans'actiom" on Software Engit;eering, 
SI,;-S (1), 10-23. 
l l lJ D.'q O N, R. (1990). English Word (;ram*mar. I~ a sil 1~ lack well, 
I.II:nI{I,IMAN, I1. (1987). Concmrenl object-orle,ted programming in 
Act 1. In A. Yollezawa & M. Tokoro, F.ds. Object-Oriented Concur- 
rent Prograt~uning. pp.9-36. MI'I' Press. 
MaeGRFZ~OI~, R. (1991). "Itm cw~lving technology of classilicalion- 
based knowledge representation syslems. In J. Sowa, l!d. Principh!s 
of Semantic NetworL~'. Exploration,~" in the Representation of 
Knowledge. pp.3g5-4(X). Morgan Kaufmam*. 
MacGl~liGOl(, R. & I~A'I'F.S, R. (1987). The LOOM Knowledge Repte. 
sentation System. University of Sou}hem California (ISI Reprint 
Series, ISI/RS-87-188) 
RIF.SI\]F.CK, C, & SCIIANK, R, (1978). Comprehensioll by computer: 
CXlW.ctation-based ;tmdysis of sentences in eonlext, In W.J,M \[.ev- 
eh & G.IL Flores d'Arcais, Eds. ShMies in the Perception ofl.an. 
St}age. pp.247-293. J. Wiley, 
SIIAVIT, N & FRANCI'~Z, N. (1986). A new approach to detection of 
locally indicative stability. In 1+. Kolt, Ed. AutotmJla, Languages 
and I'rogramming. Proceedings ICALP 1986. Springer. 
SIIIF.I~ER, S. (1986). An In}redaction to Unifteation-based Approache,~. 
to Gratmnar. Chicago University Press 
SMALl., S & RIF.GFI~., C. (1982). Parsing and comprehending wiHI 
word exlmrts (a Iheop), alld its realization). In W. l.efinmt & M. Rin- 
gle, Eds. Strategies for Natural l~Jnguage Proce.~wing. pp.g9-147. 
L. l:.llhaum. 
X U, W. (1993), l)L~'trilmted, Shared and PersLvtent Objects. A Model for 
Distributed Object Oriented Programmblg. l.ondol~ Universily, 
l)ept, of Computer Science (Ph.l),l)iss.). 
493 
