G/JNEY G6NENg 
UNIQUE DECIPHEKABILITY OF CODES 
WITH CONSTRAINTS 
WITH APPLICATION TO SYLLABIFICATION 
OF TURKISH WORDS 
1. INTRODUCTION 
Information lossless automata were first studied by D. A. HUFFMAN 
(1959). Huffman also devised tests for information losslessness (IL) and 
information losslessness of finite order (ILF). By treating finite State 
machines as encoders and decoders, the tests for IL and ILF can be ap- 
plied to coding theory. This is done by S. EV~.N (1962, 1963, 1965) 
who devised testing methods for unique decipherability (UD) and 
unique decipherability of finite delay (UDF), concepts hown to be 
parallel to IL and ILF. 
In this paper, tests for UD and UDF for codes with constraints are 
investigated. The basis of the proposed method is Even's procedure. 
The constraints are of the form " code word X never follows code 
word Y" for specific ordered pairs (X, Y) of code words. 
The need for testing UD and UDF for codes with constraints orig- 
inally arised in the syllabification prob\]em for Turkish words. The 
problem is, essentially, to find an algorithm for syllabification of words 
for a given printed Turkish text. The construction of syllables in Turk- 
ish language is very regular and hence it is not difficult to find such 
algorithms intuitively, by trial and error. By a thorough analysis of 
the UD and UDF properties of printed word - syllable structure con- 
version, it is also possible to investigate he effects of the flood of for- 
eign (mostly French) words on the syllable structure of Turkish. 
In part 2 some basic definitions are given. In part 3 Even's proce- 
dure for testing UD and UDF is discussed briefly. The test for codes 
with constraints i presented in part 4. Finally, in part 5, applications 
on Turkish syllable structure are discussed briefly. 
184 GUNEY GONEN~ 
2. NOTATION AND BASIC DEFINITIONS t 
Source symbols will be shown by capital etters A, B, ..... L, W, X, 
Y, Z. Code symbols will be shown by 0 and 1. A concatenation f a 
finite number of code symbols is called a code word. A code consists of 
a finite number of code words of fmite length, each representing a 
source symbol. A coded message is obtained by concatenating code words, 
without spacing or any other punctuation. Variable-length codes in 
which code words are not necessarily of the same length, will only be 
considered. 
A code is said to be uniquely decipherable if and only if every coded 
message can be decomposed into a sequence of code words in only 
one way. A code is said to be uniquely decipherable offinite delay N if 
and only if N is the least integer, so that the knowledge of the first N 
symbols of the coded message suffices to determine its first code word. 
3. TESTS FOR UD AND UDP 
By treating finite state machines as encoders and decoders, tests for 
UD and UDF can be converted into tests for IL and ILF (S. EVEN, 1965; 
Z. KOHAVr, 1970). Without going into tests for IL and ILF, we shall 
give Even's testing procedure for UD and UDF here. At the same time 
we shall demonstrate the procedure on a binary code T which consists 
of 4 code words: 
A=O,  B=IO,  C=01,  and D=101.  ~ 
Procedure 1. 
(! a) Insert aseparation symbol S at the beginning and end of eacl~ Code word 
in the code. . . . . .  
(lb) Let code word X be of length n. Insert he separation Symbol Xi be- 
tween i-th and (i + 1)-th symbol of Code word X for 1 ~ i ~ n-1. Do 
1 Basic definitions in parts 2 and 3 follows Z. KOHAW (1970). 
I f  0 denotes vocal and I denotes consonant, hen A, B, C, and D are four of the 
12 syllable types of Turkish. 
UNIQUE DECIPHERABILITY OF CODES WITH CONSTRAINTS 185 
this for all code words for which n ~> 2. For example, after steps (la) 
and (lb), D = 101 becomes D = S1DIODzlS. 
(lc) The separation symbol to the right of the code symbol t is called the 
t-successor f the separation symbol to the left of the same code symbol. 
For example, D 1 is the 1-successor f S, D2 is the 0-successor f D1, and 
S is the 1-successor lD2, in code word D. 
Two separation symbols are said to be compatible if 
(I) They are t-successors of S, for some code symbol t, or, 
(II) They are t-successors of two separation symbols which are them- 
selves compatibles. 
I f  (WX) is a compatible pair, and if Y and Z are t-successors of W and 
X, respectively, then the compatible pair (YZ) is said to be implied by 
(WX) under t. 
Construct a testing table as follows: the column headings are the code 
symbols. The first row heading is S. The entries in the first row are 
compatible pairs found by (I) above, under corresponding column t. 
The other row headings are the compatible pairs. The entries in row 
(WX), column t, are the compatible pairs implied by (WX) under t. 
The testing table for code T is shown in fig. 1. 
code T 
A: 0 . . . . .  
B: 10 
C:I O1 - 
D: 101 
A: SOS 
B: S1B~OS 
C: SOGlS 
D: S1DtOD, IS 
0 
s (SC,) 
SG 
B,D, (SD,) 
sB, (sc,) (ss) 
SD, (C,D,) (SD,) 
SD, 
C~D, 
1 
(B ol) 
(sn,) (so,) 
(sn,) (SD ) 
(ss) 
Fig. 1. Code T 
(ld) If the tabl e contains pai r  (SS) then the code is not UD, otherwise it is 
LID. Since there are (SS) pairs in the testing table for code T, it is not 
LID. By tracing back the compatibles, tarting from a (SS) pair, one 
can arrive the symbo| S (possibly through several paths). 
The sequence of code symbols corresponding to this traceback path 
gives an ambiguous message. In fig. 2 some of these ambiguous mes- 
sages are shown for code T. 
186 
S ?.-~SC ~----SB ?--~-.SS 
S?  SC, ~-2-SO,? C,D, ~----SS 
S ~-L-B,O,?SD,2--SB, ?---SS 
S1.-~B1Dl ?-~SD21.-~SDl ?-LC1D~ l--~-SS 
GONEY G6NEN~ 
010 = AB or CA 
0101 = AD or CC 
1010 = BB or DA 
10101 = BD or DC 
Fig. 2. Some ambiguous messages in code T 
(le) If no (SS) pair is generated, then a testing raph is constructed from the 
table as follows: corresponding to every row in the table there is a vertex 
in the graph. If (YZ) is implied by (WX) under t, then a directed arc 
labeled t leads from vertex (WX) to vertex (YZ) in the graph. 
(1./') A code is uniquely decipherable of finite delay N if and only if its test- 
ing graph is loop-free. If the graph is loop-free and the length of the 
longest path in the graph is r, then N = r + 1. 
4. CONSTRAINTS ON CODE WORD OCCURRENCES 
In the above discussion, there was no constraint whatsoever regard- 
ing the occurrence of any code word at any point of  the message. On 
the other hand there may be such a case that, for some specific code, 
the code word X never follows the code word Y. These constraints 
may arise from the physical nature of  the encoder (for example no letter 
other than u can follow letter q in an English text) or may be deliberat- 
ely imposed upon a code to achieve LID or UDF properties. 
The constraints of the fo rm"  code word X never follows code word 
Y" will be termed a first-order constraint. For the codes with first order 
constraints, a testing procedure is given below: 
Procedure 2. 
(2a) Insert a separation symbol Px at the beginning and a separation symbol 
Qx at the end of each code word X in the code. 
(2b) Insert separation symbols X~ as in (lb). For example after steps (2a) 
and (2b), D = 101 becomes PnlDlOD21QD. 
(2c) Let a number e(X, Y) be defined for every ordered pair of code words 
(X, Y) in the following way: 
UNIQUE DECIPHERABILITY OF CODES WITH CONSTRAINTS 187 
re(X, 1,')= 1 if the code word X is allowed to occur immediately 
after the code word Y, 
-- 0 otherwise. 
A constraint matrix M in which there is one row and one column for 
each Code word can be defined such that the element of M in the row 
X, column Y is re(X, Y). 
For example, consider code T of part 3. Let the following four con- 
straints be imposed on this code: A never follows C,. C never follows 
C, A never follows D, and C never follows D. These four constraints 
can also be expressed as " a code word starting with a 0 never follows 
a code word ending with a 1 ". The resulting code, called code \[7, and 
its constraint matrix is shown in fig. 3. 
code U 
A: 0 P 
B: 10 QAC, 
C: O1 
B~D~ 
D: 101 
Qc B` 
A: Pa0Qa QGDa 
B: PB1Bt0QB QBDa 
C: Pc0G11Qc 
QDBx D: PD1D, ODalQD 
QDD~ 
0 
(QAC1) 
(q~D.) 
J 
(BIDI) 
(QcB,) (QcD,) 
(QDB,) (QDDa) 
ABCD 
B ! 1 
M=C 1 0 
D 1 1 
Fig. 3. Code U 
(2d) The separation symbol to the right of the code symbol t is called the 
t-successor f the separation symbol to the left of the same code symbol. 
Furthermore, a separation symbol X~ (Qx) is the t-successor of the sep- 
aration symbol Qv if X} (Qx) is a t-successor of Px and re(X, Y) = 1. 
Two separation symbols are said to be compatible if 
(I) They are t-successors of Px and Pr  for some t, X, and Y, or 
188 CONEY GONEN~ 
(II) They are t-successors?of two separation symbols which are them- 
selves compatible. 
Construct he testing table as in (lc), with the change: the first row 
heading is P. The testing table for code U is shown in fig. 3. 
(2e) If the table contains any pair (QxQy) for some X and Y (possibly iden- 
tical), then the code is not UD. Otherwise it is UD. For example it is 
seen from fig. 3 that code U is UD. If the code is not UD, then a trace- 
back of compatibles which implied a pair (QxQY) gives an ambiguous 
message. 
(2e) If the code is UD, then one can construct the testing graph as in (le). 
The testing graph for code U is shown in fig. 4. 
Fig. 4. Testing raph for code U 
The longest path in this graph has length 3. Hence the code is UDF of 
order 4; in other words the knowledge of the first 4 code symbols uf- 
fices to determine the first code word, but 3 is not sufficient. To demon- 
strate that the knowledge of the first 3 code symbols is not sufficient, 
consider apath of length 3 in the graph, for example the path 101 from 
P to QnD1. When we receive 101 we can not decide whether this is 
word D, or word B (= 10) occurred and a word D (----- 101) has just 
started (the last vertex QnD1 actually points to this ambiguity). But, 
if the fourth .symbol received is a 0 we can now decide that the first 
code word was B, andif  the fourth symbol isa 1 we decide that the 
first code word was D. 
There may be other types of constraints present on the code. A con- 
straint of the form " code word X never follows YZ ", where Y and 
UNIQUE DECIPHERABILITY OF CODES WITH CONSTRAINTS 189 
Z are distinct, will be termed a second order constraint. If there exists 
such a constraint, hen it can be converted into the following first order 
constraints: create a new code word ;~, identical in structure to Z. Then 
impose the constraints "X  never follows Z, Z never follows Y"  (for 
simplification purposes one can impose the additional constraints: 
" Z, never follows Z,, X, or Z "). Higher order constraints can be han- 
dled similarly. 
5. SYLLABLE STRUCTURE OF TURKISH LANGUAGE 
In Turkish language there are 12 syllable types. These are shown 
in Table 1. 
TABLE 1. 
SYLLABLE TYPES OF TURKISH LANGUAGE 
(0 denotes vowel, 1 denotes consonant) 
Symbol Structure Example 
A 0 a~lk (open) 
B 10 baba (father) 
C 01 ekmek (bread) 
D 101 altm (gold) 
E 011 erk (power) 
F 1011 tiirk (turkish) 
G 110 kraliqe (queen) 
H 1101 kontrol (control) 
I 1110 strateji (strategy) 
J 11101 stronsiyum (strontium) 
K 11011 tren~kot (trench coat) 
L 10111 kontrbas (cello) 
The first six syllable types (types A-F) are syllable types of proper 
Turkish language. The remaining six types (types G-L) came into 
Turkish with foreign borrowings. These are somewhat characterized 
by consonant clusters, which are totally alien to the language. In spok- 
en language, especially as spoken by not-well-educated people, these 
clusters are simplified by the addition of a vowel before or within the 
190 GUNEY G6NEN~ 
cluster, thereby increasing the number of syllables in the word (G. L. 
LEwis, 1967). Since our main concern is printed texts we shall not deal 
with these and other aspects of the spoken language. 
The treatment of printed Turkish words as messages encoded into 
a code in which syllables are code words and letters are code symbols 
enables us to syllabify printed texts automatically. This is important 
because of the following reasons: 
1) Automatic syllabification makes it possible to recognize 
and count (mainly for statistical purposes) syllable types and/or syllables 
from texts read into the computer without any syllable separation 
markers. 
2) Automatic syllabification is necessary in automatic type- 
setting, without automatic syllabification words to be separated at 
line ends can not be properly syllabified. 
3) Automatic syllabification gives insight into the syllable 
structure, its deformation under some effects, and the relation between 
spoken and printed .language, thereby helping linguists working on 
the subject. 
The first six syllable types a without any constraints obviously form 
a non-UD code. For example a word 0110 can be decoded as 01.10 
(CB) or as 011.0 (EA). On the other hand the phonetic rules of the lan- 
guage put some constraints as to which syllable type can not follow a 
given syllable type. The set of constraints inherent in the language can 
be summarized as "each vowel takes the first consonant before it into 
its syllable " (T. BANGUO~Ltl, 1959). In our notation, the constraint 
set can be summarized as "no syllable starting with a vowel (0) can 
follow a syllable ending with a consonant (1) ". The constraint matrix 
corresponding to this set is shown below. 
A 
B 
C 
D 
E 
F 
A BC D EF  
-1 1 0 0 0 0 -  
1 1 1 1 1 1 
1 1 0 0 0 0 
1 1 1 1 1 1 
1 1 0 0 0 0 
1 1 1 1 1 1 
3 Turkish alphabet consists of  eight vowels (a, e, z, i, o,//, u, //) and 21 consonants 
(b, c, ~, d,f, g, ~, h, .i, k, l, m, n, p, r, s, .s, t, v, y, z). Only one vowel can be present 
in any syllable. There are no diphtongs in Turkish. 
UNIQUE DECIPHERABILITY OF CODES WITH CONSTRAINTS 191 
Now, by constructing the testing table and graph, it can be shown 
thatthis code is UDF of order 5. 4 This simply means that there is an 
algorithm, to syllabify any proper Turkish word which operates in the 
following manner: 
1) The only information required about the characters in the 
text is about their being vowel, consonant or "other " (such as blank, 
comma, numeral etc.). 
2) When a word is being scanned, its first syllable will be 
decided upon atthe fifth character of the word or before. Since the code 
is UD the decision process is completed when the word ends (i.e. upon 
first blank). 
The introduction of the syllable types G, H, ..., L of Table 1 into the 
language causes the "invention" of new constraints. These are not 
yet thoroughly investigated or explained. One set of constraints can be 
summarized as: "no syllable starting with two or more consonants can 
follow a syllable ending with a vowel ".5 With the addition of this set 
of contraints, the constraint matrix becomes 
A 
B 
C 
D 
E 
F 
G 
H 
I 
J 
K 
L 
A B C D E F G H I J K L 
-1  1 0 0 0 0 1 0 1 0 0 0 -  
1 1 1 1 1 1 1 1 1 1 1 1 
1 1 0 0 0 0 1 0 1 0 0 0 
1 1 1 1 1 1 1 1 1 1 1 1 
1 1 0 0 0 0 1 0 1 0 0 0 
1 1 1 1 1 1 1 1 1 1 1 1 
0 0 1 1 1 1 0 1 0 1 1 1 
0 0 1 1 1 1 0 1 0 1 1 1 
0 0 1 1 1 1 0 1 0 1 1 1 
0 0 1 1 1 1 0 1 0 1 1 1 
0 0 1 1 1 1 0 1 0 1 1 1 
1 1 1 1 1 1 1 1 1 1 1 1 
' It is also interesting to note that the first order constraints to make the code A, B, 
. . . .  F uniquely decipherable of  finite delay are found to be precisely those constraints 
inherent in the language. 
No mention of this kind of constraint is found in the literature. This rule, and the 
one given before must clearly be the result of the shape of vocal organs. We should also 
mention that no exception at all to these two rules exists. 
192 GUNEY GSNEN~ 
The code thus generated can be shown to be still non-UD. Some 
typical ambiguities concerning the existing words are shown below: 
Message Ambiguous 
(word) syllabification Examples 
01110 CG 01.110 em.pri.me, is.pri.fiz.ma 
EB 011.10 ens.ti.ti~, esk.ka.va.tSr 
101110 DG 101.110 kon.gre, kom.pra.dor 
FB 1011.10 fark.h, kiirk4ii 
011101 CH 01.1101 mtran.ca, ak.tris 
ED 011.101 eks.per 
1011101 DH 101.1101 kan.gren, kon.trat 
FD 1011.101 tabl.dot, teks.til 
A careful and thorough search (through all borrowings in the lan- 
guage) revealed one fact: if we increase the code symbols from two 
(vowel, consonant) to three (v ----- vowel, r-----letter " r  ", ~ = conso-~ 
nant other than " r  ") then the resulting code becomes UD, and act- 
ually UDF of delay 7 for all existing foreign (and of course all native) 
words. The examples given above hints this. Simply note that the words 
in the upper line in each set have an r as the second letter of second 
syllable, whereas a letter other than r appears at the same position of the 
word, for words of the lower lines, e.g. emprime and enistitii. 
Finally, with these considerations an algorithm for tlae syllabificat- 
ion is programmed (in rOX~TaAN). This algorithm is based on the 
state-table of the inverse of the finite state machine which is taken as 
the encoder device 4,7. The input to the program is a printed text, the 
output is the same text (numerals etc. skipped), all the words being 
syllabified. There are minor additions to the program. For example 
unsyllabifiable words (due to punching errors, etc.) are printed out as 
they are, but in brackets. The program is run on mM 360/40. An example 
of input data and corresponding printouts are shown in fig. 5. 
UNIQUE DECIPHERABILITY OF CODES WITH CONSTRAINTS 193 
HECE AYIRMA PROGRAMI GELENEK AKARYAKIT UYGULAMA 
HE*CE A*YIR*MA PROG*RA*MI GE*LE*NEK A*KAR*YA*KIT UY*GU*LA*MA 
TORTU KONGRE KORKAK KANGREN TABLDOT KONTRAT TANJANT 
TOR*TU KON*GRE KOR*KAK KAN*GREN TABL*DOT KON*TRAT TAN*JANT 
STEREOSKOP AHMET RIZA O STRC BB ANI 
STE*RE*OS*KOP AH*MET RI*ZA O (STRC) CBB) A*NI 
. . -  . , ' 
EMPRIME ENSTITU EKSPER ISTRANCA ISTRONGILOs ISFENKS 
EM*PRI*ME ENS*TI*TU EKS*PER IS*TRAN*CA IS*TRON*GI*LOS IS*FENKS 
FBRKET CKANDIRMACAI .12/MAYIS/1971 GUSULHANE 
CFBRKETJ KAN*DIR*MA*CA MA*YIS GU*SUL*HA*NE 
SAAT TATAR AMFITEATR TELEKS KREOZOT FLAMA FLUOR 
SA*AT TA*TAR AM*FI*TE*ATR TE*LEKS KRE*O*ZOT FLA*MA FLU*OR 
AERODINAMIK AIT ARAP AORT AVURT ARKEOLOG BABA 
A*E*RO*DI*NA*MIK A*IT A-RAP A*ORT A*VURT AR*KE*O*LOG BA*BA 
TRAHOM FREKANS STRATEJI STRATOSFER ARTI 
TRA*HOM FRE*KANS STRA*TE*JI STRA*TOS*FER AR*TI 
KONTRAST EKSKAVATOR ENSTITU 
KON*TRAST EKS*KA*VA*TOR ENS*TI*TU 
Fig. 5. Computer printouts of the syllabification program. In each set of two lines, the upper line 
the input data, the lower line is the output. 
13 
REFERENCES 
T. BANGUOC, LU, Tiirk Grameri-Ses Bilgisi, 
Ankara, 1959. 
S. Evmq, Generalized Automata nd Their 
Information LossIessness, in Switching 
Circuit Theory and Logical Design, 
AIEE Special Publication, S-141, 1962, 
pp. 144-147. 
S. Ev~, Tests for Unique Decipherabitity, 
in,  IEEE Trans. Information Theory ~, 
vol. IT-9 (April 1963), pp. 109-112. 
S. EVEN, On Information Lossless Automata 
of Finite Order, in ~ IEEE Trans. Elec. 
Comp. ~, vol. EC-14 (August 1965), 
pp. 561-569. 
D. A. HUFFMAN, Canonical Forms for 
Information Lossless Finite State Ma- 
chines, in ~ IR.E Trans. Circuit Theory ~, 
vol. CT-6, Special Supplement (May 
1959), pp. 41-59. 
G. L. Lmwls, Turkish Grammar, London, 
1967. 
Z. KO~L~W, Switching and Finite Automata 
Theory, New York, 1970. 
